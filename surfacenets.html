<html>
<head>
<style>
html,body {
	width:100%;
	height:100%;
	margin:0;
}
</style>
</head>
<body>

<script src="/lib/jquery-1.11.0.min.js"></script>
<script>

var params=deparam();

var cube_edges = new Int32Array(24);	// surfacenets
var edge_table = new Int32Array(256);	// surfacenets
var buffer = new Int32Array(4096);		// surfacenets
var brain={};

var renderer,scene,camera,trackball;

//var path="/data/Sloth_bear/Atlas.nii.gz";
//var path="/data/Gray_wolf/Telencephalon.nii.gz";
var path="/data/Gorilla/Atlas.nii.gz";
var level=1;

path=params.path;

init_surfacenets();

loadScript("/lib/three.min.js")
.then(function(){return loadScript("/lib/TrackballControls.js")})
.then(function(){return loadScript("/lib/pako/pako.min.js")})
.then(function(){return loadNifti(path)})
.then(function(){
	var g=SurfaceNets(brain.data,brain.dim,brain.pixdim,level);
	createMesh(g);
	animate();
});

function deparam() {
    var search = location.search.substring(1);
    var result = search?JSON.parse('{"' + search.replace(/&/g, '","').replace(/=/g,'":"') + '"}',
                     function(key, value) { return key===""?value:decodeURIComponent(value) }):{};
    return result;
}

function loadScript(script) {
	var def=new $.Deferred();
	var s = document.createElement("script");
	s.src = script;
	s.onload=function(){console.log("loaded",script,new Date());def.resolve();}
	s.onerror=function(e){console.log("unable to load",script);def.reject();}
	document.body.appendChild(s);
	return def.promise();
}

function init_surfacenets()
{
	var k = 0;
	for(var i=0; i<8; ++i) {
		for(var j=1; j<=4; j<<=1) {
			var p = i^j;
			if(i <= p) {
				cube_edges[k++] = i;
				cube_edges[k++] = p;
			}
		}
	}
	for(var i=0; i<256; ++i) {
		var em = 0;
		for(var j=0; j<24; j+=2) {
			var a = !!(i & (1<<cube_edges[j]));
			var b = !!(i & (1<<cube_edges[j+1]));
			em |= a !== b ? (1 << (j >> 1)) : 0;
		}
		edge_table[i] = em;
	}
}
function SurfaceNets(data, dims, pixdims, level)
{ 
	var vertices = [];
	var faces = [];
	var n = 0;
	var x = new Int32Array(3);
	var R = new Int32Array([1, (dims[0]+1), (dims[0]+1)*(dims[1]+1)]);
	var grid = new Float32Array(8);
	var buf_no = 1;

	if(R[2] * 2 > buffer.length)
		buffer = new Int32Array(R[2] * 2);

	for(x[2]=0; x[2]<dims[2]-1; ++x[2], n+=dims[0], buf_no ^= 1, R[2]=-R[2])
	{
		var m = 1 + (dims[0]+1) * (1 + buf_no * (dims[1]+1));
		for(x[1]=0; x[1]<dims[1]-1; ++x[1], ++n, m+=2)
		for(x[0]=0; x[0]<dims[0]-1; ++x[0], ++n, ++m)
		{
			var mask = 0, g = 0, idx = n;
			for(var k=0; k<2; ++k, idx += dims[0]*(dims[1]-2))
			for(var j=0; j<2; ++j, idx += dims[0]-2)      
			for(var i=0; i<2; ++i, ++g, ++idx)
			{
				var p = data[idx]-level;
				grid[g] = p;
				mask |= (p < 0) ? (1<<g) : 0;
			}
			if(mask === 0 || mask === 0xff)
				continue;
			var edge_mask = edge_table[mask];
			var v = [0.0,0.0,0.0];
			var e_count = 0;
			for(var i=0; i<12; ++i)
			{
				if(!(edge_mask & (1<<i)))
					continue;
				++e_count;
				var e0 = cube_edges[ i<<1 ];       //Unpack vertices
				var e1 = cube_edges[(i<<1)+1];
				var g0 = grid[e0];                 //Unpack grid values
				var g1 = grid[e1];
				var t  = g0 - g1;                  //Compute point of intersection
				if(Math.abs(t) > 1e-6)
					t = g0 / t;
				else
					continue;
				for(var j=0, k=1; j<3; ++j, k<<=1)
				{
					var a = e0 & k;
					var b = e1 & k;
					if(a !== b)
						v[j] += a ? 1.0 - t : t;
					else
						v[j] += a ? 1.0 : 0;
				}
			}
			var s = 1.0 / e_count;
			for(var i=0; i<3; ++i)
				v[i] = x[i] + s * v[i];
			buffer[m] = vertices.length;
			vertices.push(v);
			for(var i=0; i<3; ++i)
			{
				if(!(edge_mask & (1<<i)) )
					continue;
				var iu = (i+1)%3;
				var iv = (i+2)%3;
				if(x[iu] === 0 || x[iv] === 0)
					continue;
				var du = R[iu];
				var dv = R[iv];
				if(mask & 1)
				{
					faces.push([buffer[m], buffer[m-du-dv], buffer[m-du]]);
					faces.push([buffer[m], buffer[m-dv], buffer[m-du-dv]]);
				}
				else
				{
					faces.push([buffer[m], buffer[m-du-dv], buffer[m-dv]]);
					faces.push([buffer[m], buffer[m-du], buffer[m-du-dv]]);
				}
			}
		}
	}
	return { vertices: vertices, faces: faces };
}

function loadNifti(path) {
	var def=$.Deferred();
	var oReq = new XMLHttpRequest();
	oReq.open("GET", path, true);
	oReq.addEventListener("progress", function(e){console.log(parseInt(100*e.loaded/e.total)+"% Loaded")}, false);
	oReq.responseType = "arraybuffer";
	oReq.onload = function(oEvent)
	{
		var	inflate=new pako.Inflate();
		inflate.push(new Uint8Array(this.response),true);
		var data=inflate.result.buffer;
		var	dv=new DataView(data);
		var	sizeof_hdr=dv.getInt32(0,true);
		var	dimensions=dv.getInt16(40,true);
		
		brain={dim:[],pixdim:[]};
		brain.dim[0]=dv.getInt16(42,true);
		brain.dim[1]=dv.getInt16(44,true);
		brain.dim[2]=dv.getInt16(46,true);
		brain.datatype=dv.getInt16(72,true);
		brain.pixdim[0]=dv.getFloat32(80,true);
		brain.pixdim[1]=dv.getFloat32(84,true);
		brain.pixdim[2]=dv.getFloat32(88,true);
		var	vox_offset=dv.getFloat32(108,true);

		switch(brain.datatype)
		{
			case 2:
			case 8:
				brain.data=new Uint8Array(data,vox_offset);
				break;
			case 16:
				brain.data=new Int16Array(data,vox_offset);
				break;
			case 32:
				brain.data=new Float32Array(data,vox_offset);
				break;
		}

		console.log("dim",brain.dim[0],brain.dim[1],brain.dim[2]);
		console.log("datatype",brain.datatype);
		console.log("pixdim",brain.pixdim[0],brain.pixdim[1],brain.pixdim[2]);
		console.log("vox_offset",vox_offset);
		def.resolve();		
	};
	oReq.send();

	return def.promise();
}
function createMesh(g) {

	renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setClearColor(0x000000);
	var W=window.innerWidth;
	var H=window.innerHeight;
	renderer.setSize(W,H);
	document.body.appendChild(renderer.domElement);

	camera = new THREE.PerspectiveCamera(50,W/H,1,2000 );
	camera.position.z = 200;
	scene = new THREE.Scene();

	trackball = new THREE.TrackballControls(camera,renderer.domElement);

	window.addEventListener( 'resize', onWindowResize, false );
		
	var geometry=new THREE.Geometry();
	geometry.vertices.length=0;
	geometry.faces.length=0;
	var o={x:0,y:0,z:0};
	for(var i=0; i<g.vertices.length; ++i) {
		var v = g.vertices[i];
		o.x+=v[0];
		o.y+=v[1];
		o.z+=v[2];
	}
	o.x/=g.vertices.length;
	o.y/=g.vertices.length;
	o.z/=g.vertices.length;
	for(var i=0; i<g.vertices.length; ++i)
	{
		var v = g.vertices[i];
		var	z=0.5;
		geometry.vertices.push(new THREE.Vector3((v[0]-o.x)*z,(v[1]-o.y)*z,(v[2]-o.z)*z));
	}
	for(var i=0; i<g.faces.length; ++i) {
		var f = g.faces[i];
		if(f.length === 3) {
			geometry.faces.push(new THREE.Face3(f[0], f[1], f[2]));
		} else if(f.length === 4) {
			geometry.faces.push(new THREE.Face4(f[0], f[1], f[2], f[3]));
		}
	}
	geometry.computeFaceNormals();
	geometry.computeVertexNormals();

	var material=new THREE.MeshNormalMaterial();
	var	mesh=new THREE.Mesh(geometry,material);
	scene.add(mesh);
}
function animate()
{
	requestAnimationFrame( animate );
	render();
}

// render the scene
function render() {
	renderer.render( scene, camera );
	trackball.update();
}
function onWindowResize(event) {
	var W=window.innerWidth;
	var H=window.innerHeight;
	renderer.setSize( W, H );
	camera.aspect = W/H;
	camera.updateProjectionMatrix();
}	

</script>
</body>
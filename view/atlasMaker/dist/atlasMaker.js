var AtlasMakerWidget=function(t){var c={};function n(e){if(c[e])return c[e].exports;var g=c[e]={i:e,l:!1,exports:{}};return t[e].call(g.exports,g,g.exports,n),g.l=!0,g.exports}return n.m=t,n.c=c,n.d=function(t,c,e){n.o(t,c)||Object.defineProperty(t,c,{enumerable:!0,get:e})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,c){if(1&c&&(t=n(t)),8&c)return t;if(4&c&&"object"==typeof t&&t&&t.__esModule)return t;var e=Object.create(null);if(n.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:t}),2&c&&"string"!=typeof t)for(var g in t)n.d(e,g,function(c){return t[c]}.bind(null,g));return e},n.n=function(t){var c=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(c,"a",c),c},n.o=function(t,c){return Object.prototype.hasOwnProperty.call(t,c)},n.p="",n(n.s=9)}([function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v3.2.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2017-03-20T18:59Z\n */\n( function( global, factory ) {\n\n\t"use strict";\n\n\tif ( typeof module === "object" && typeof module.exports === "object" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require("jquery")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( "jQuery requires a window with a document" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n"use strict";\n\nvar arr = [];\n\nvar document = window.document;\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\n\n\n\tfunction DOMEval( code, doc ) {\n\t\tdoc = doc || document;\n\n\t\tvar script = doc.createElement( "script" );\n\n\t\tscript.text = code;\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = "3.2.1",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor \'enhanced\'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android <=4.0 only\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array\'s method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === "boolean" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== "object" && !jQuery.isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we\'re merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && Array.isArray( src ) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don\'t bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: "jQuery" + ( version + Math.random() ).replace( /\\D/g, "" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type( obj ) === "function";\n\t},\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\n\t\t// As of jQuery 3.0, isNumeric is limited to\n\t\t// strings and numbers (primitives or objects)\n\t\t// that can be coerced to finite numbers (gh-2662)\n\t\tvar type = jQuery.type( obj );\n\t\treturn ( type === "number" || type === "string" ) &&\n\n\t\t\t// parseFloat NaNs numeric-cast false positives ("")\n\t\t\t// ...but misinterprets leading-number strings, particularly hex literals ("0x...")\n\t\t\t// subtraction forces infinities to NaN\n\t\t\t!isNaN( obj - parseFloat( obj ) );\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== "[object Object]" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, "constructor" ) && proto.constructor;\n\t\treturn typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\n\t\t/* eslint-disable no-unused-vars */\n\t\t// See https://github.com/eslint/eslint/issues/6125\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + "";\n\t\t}\n\n\t\t// Support: Android <=2.3 only (functionish RegExp)\n\t\treturn typeof obj === "object" || typeof obj === "function" ?\n\t\t\tclass2type[ toString.call( obj ) ] || "object" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tDOMEval( code );\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Support: IE <=9 - 11, Edge 12 - 13\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android <=4.0 only\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t"" :\n\t\t\t( text + "" ).replace( rtrim, "" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === "string" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === "string" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: Date.now,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === "function" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),\nfunction( i, name ) {\n\tclass2type[ "[object " + name + "]" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn\'t used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && "length" in obj && obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === "function" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === "array" || length === 0 ||\n\t\ttypeof length === "number" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.3\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-08-08\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = "sizzle" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it\'s faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = "[\\\\x20\\\\t\\\\r\\\\n\\\\f]",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = "(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = "\\\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +\n\t\t// Operator (capture 2)\n\t\t"*([*^$|!~]?=)" + whitespace +\n\t\t// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"\n\t\t"*(?:\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\"|(" + identifier + "))|)" + whitespace +\n\t\t"*\\\\]",\n\n\tpseudos = ":(" + identifier + ")(?:\\\\((" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t"(\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\")|" +\n\t\t// 2. simple (capture 6)\n\t\t"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|" + attributes + ")*)|" +\n\t\t// 3. anything else (capture 2)\n\t\t".*" +\n\t\t")\\\\)|)",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + "+", "g" ),\n\trtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)" + whitespace + "+$", "g" ),\n\n\trcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),\n\trcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),\n\n\trattributeQuotes = new RegExp( "=" + whitespace + "*([^\\\\]\'\\"]*?)" + whitespace + "*\\\\]", "g" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( "^" + identifier + "$" ),\n\n\tmatchExpr = {\n\t\t"ID": new RegExp( "^#(" + identifier + ")" ),\n\t\t"CLASS": new RegExp( "^\\\\.(" + identifier + ")" ),\n\t\t"TAG": new RegExp( "^(" + identifier + "|[*])" ),\n\t\t"ATTR": new RegExp( "^" + attributes ),\n\t\t"PSEUDO": new RegExp( "^" + pseudos ),\n\t\t"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(" + whitespace +\n\t\t\t"*(even|odd|(([+-]|)(\\\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +\n\t\t\t"*(\\\\d+)|))" + whitespace + "*\\\\)|)", "i" ),\n\t\t"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(" +\n\t\t\twhitespace + "*((?:-\\\\d)?\\\\d*)" + whitespace + "*\\\\)|)(?=[^-]|$)", "i" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( "\\\\\\\\([\\\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = "0x" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +"0x"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === "\\0" ) {\n\t\t\t\treturn "\\uFFFD";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + "\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn "\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a "Permission Denied"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tdisabledAncestor = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && ("form" in elem || "label" in elem);\n\t\t},\n\t\t{ dir: "parentNode", next: "legend" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can\'t trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== "string" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a "get*By*" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don\'t exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + " " ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== "object" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( "id" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( "id", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = "#" + nid + " " + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( "," );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( "id" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, "$1" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + " " ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + " " ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement("fieldset");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split("|"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === "input" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === "input" || name === "button") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( "form" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a "form" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( "label" in elem ) {\n\t\t\t\t\tif ( "label" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can\'t be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn\'t\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( "label" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== "undefined" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn\'t yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== "HTML" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( "unload", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( "onunload", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = "i";\n\t\treturn !el.getAttribute("className");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName("*") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment("") );\n\t\treturn !el.getElementsByTagName("*").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don\'t pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter["ID"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute("id") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find["ID"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== "undefined" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter["ID"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== "undefined" &&\n\t\t\t\t\telem.getAttributeNode("id");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find["ID"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== "undefined" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode("id");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode("id");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find["TAG"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== "undefined" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don\'t have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === "*" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE\'s treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = "<a id=\'" + expando + "\'></a>" +\n\t\t\t\t"<select id=\'" + expando + "-\\r\\\\\' msallowcapture=\'\'>" +\n\t\t\t\t"<option selected=\'\'></option></select>";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but "safe" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll("[msallowcapture^=\'\']").length ) {\n\t\t\t\trbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\'\'|\\"\\")" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and "value" are not treated correctly\n\t\t\tif ( !el.querySelectorAll("[selected]").length ) {\n\t\t\t\trbuggyQSA.push( "\\\\[" + whitespace + "*(?:value|" + booleans + ")" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {\n\t\t\t\trbuggyQSA.push("~=");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(":checked").length ) {\n\t\t\t\trbuggyQSA.push(":checked");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {\n\t\t\t\trbuggyQSA.push(".#.+[+~]");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = "<a href=\'\' disabled=\'disabled\'></a>" +\n\t\t\t\t"<select disabled=\'disabled\'><option/></select>";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement("input");\n\t\t\tinput.setAttribute( "type", "hidden" );\n\t\t\tel.appendChild( input ).setAttribute( "name", "D" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll("[name=d]").length ) {\n\t\t\t\trbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(":enabled").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( ":enabled", ":disabled" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE\'s :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(":disabled").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( ":enabled", ":disabled" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll("*,:x");\n\t\t\trbuggyQSA.push(",.*:");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it\'s possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, "*" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, "[s!=\'\']:x" );\n\t\t\trbuggyMatches.push( "!=", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, "=\'$1\']" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + " " ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9\'s matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don\'t get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + "").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( "Syntax error, unrecognized expression: " + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = "",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === "string" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t">": { dir: "parentNode", first: true },\n\t\t" ": { dir: "parentNode" },\n\t\t"+": { dir: "previousSibling", first: true },\n\t\t"~": { dir: "previousSibling" }\n\t},\n\n\tpreFilter: {\n\t\t"ATTR": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === "~=" ) {\n\t\t\t\tmatch[3] = " " + match[3] + " ";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t"CHILD": function( match ) {\n\t\t\t/* matches from matchExpr["CHILD"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === "nth" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t"PSEUDO": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr["CHILD"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || "";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t"TAG": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === "*" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t"CLASS": function( className ) {\n\t\t\tvar pattern = classCache[ className + " " ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );\n\t\t\t\t});\n\t\t},\n\n\t\t"ATTR": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === "!=";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += "";\n\n\t\t\t\treturn operator === "=" ? result === check :\n\t\t\t\t\toperator === "!=" ? result !== check :\n\t\t\t\t\toperator === "^=" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === "*=" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === "$=" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t"CHILD": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== "nth",\n\t\t\t\tforward = type.slice( -4 ) !== "last",\n\t\t\t\tofType = what === "of-type";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? "nextSibling" : "previousSibling",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven\'t yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === "only" && !start && "nextSibling";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t"PSEUDO": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( "unsupported pseudo: " + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, "", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t"not": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, "$1" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don\'t keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t"has": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t"contains": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// "Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element\'s language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by "-".\n\t\t// The matching of C against the element\'s language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name."\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t"lang": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || "") ) {\n\t\t\t\tSizzle.error( "unsupported lang: " + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t"target": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t"root": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t"focus": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t"enabled": createDisabledPseudo( false ),\n\t\t"disabled": createDisabledPseudo( true ),\n\n\t\t"checked": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);\n\t\t},\n\n\t\t"selected": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t"empty": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t"parent": function( elem ) {\n\t\t\treturn !Expr.pseudos["empty"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t"header": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t"input": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t"button": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === "input" && elem.type === "button" || name === "button";\n\t\t},\n\n\t\t"text": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === "input" &&\n\t\t\t\telem.type === "text" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"\n\t\t\t\t( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t"first": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t"last": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t"even": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t"odd": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos["nth"] = Expr.pseudos["eq"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + " " ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don\'t consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, " " )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we\'re just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = "";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === "parentNode",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can\'t set arbitrary data on XML nodes, so they don\'t benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we\'re done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[" "],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })\n\t\t\t\t\t).replace( rtrim, "$1" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = "0",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find["TAG"]( "*", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn\'t visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a "00" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + " " ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle\'s compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === "function" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split("").sort( sortOrder ).join("") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren\'t passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement("fieldset") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property "interpolation"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = "<a href=\'#\'></a>";\n\treturn el.firstChild.getAttribute("href") === "#" ;\n}) ) {\n\taddHandle( "type|href|height|width", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute("value")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = "<input/>";\n\tel.firstChild.setAttribute( "value", "" );\n\treturn el.firstChild.getAttribute( "value" ) === "";\n}) ) {\n\taddHandle( "value", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === "input" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute("disabled") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ ":" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\n\n\nfunction nodeName( elem, name ) {\n\n  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\n};\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== "string" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Simple selector that can be filtered directly, removing non-Elements\n\tif ( risSimple.test( qualifier ) ) {\n\t\treturn jQuery.filter( qualifier, elements, not );\n\t}\n\n\t// Complex selector, compare the two sets, removing non-Elements\n\tqualifier = jQuery.filter( qualifier, elements );\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;\n\t} );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = ":not(" + expr + ")";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== "string" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $("p:first").is("p:last") won\'t return true for a doc with two "p".\n\t\t\ttypeof selector === "string" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(""), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === "string" ) {\n\t\t\tif ( selector[ 0 ] === "<" &&\n\t\t\t\tselector[ selector.length - 1 ] === ">" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== "string" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there\'s no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don\'t pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === "string" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, "parentNode" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, "parentNode", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, "nextSibling" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, "previousSibling" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, "nextSibling" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, "previousSibling" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, "nextSibling", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, "previousSibling", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n        if ( nodeName( elem, "iframe" ) ) {\n            return elem.contentDocument;\n        }\n\n        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n        // Treat the template element as a regular one in browsers that\n        // don\'t support it.\n        if ( nodeName( elem, "template" ) ) {\n            elem = elem.content || elem;\n        }\n\n        return jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== "Until" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === "string" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * "fired" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest "memorized"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === "string" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn\'t re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we\'re done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we\'re done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = "";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( jQuery.isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = "";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = "";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject, noValue ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && jQuery.isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn\'t unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.apply( undefined, [ value ] );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ "notify", "progress", jQuery.Callbacks( "memory" ),\n\t\t\t\t\tjQuery.Callbacks( "memory" ), 2 ],\n\t\t\t\t[ "resolve", "done", jQuery.Callbacks( "once memory" ),\n\t\t\t\t\tjQuery.Callbacks( "once memory" ), 0, "resolved" ],\n\t\t\t\t[ "reject", "fail", jQuery.Callbacks( "once memory" ),\n\t\t\t\t\tjQuery.Callbacks( "once memory" ), 1, "rejected" ]\n\t\t\t],\n\t\t\tstate = "pending",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t"catch": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + "With" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( "Thenable self-resolution" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === "object" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === "function" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( jQuery.isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it\'s otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = "resolved" (i.e., fulfilled)\n\t\t\t\t\t\t// state = "rejected"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + "With" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\n\t\t\t\t!remaining );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( master.state() === "pending" ||\n\t\t\t\tjQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn master.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t}\n\n\t\treturn master.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we\'re already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( "DOMContentLoaded", completed );\n\twindow.removeEventListener( "load", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals "interactive" too soon\nif ( document.readyState === "complete" ||\n\t( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( "DOMContentLoaded", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( "load", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it\'s a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === "object" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === "string" ) {\n\t\t\tcache[ jQuery.camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ jQuery.camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the "read" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === "string" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the "set" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( Array.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( jQuery.camelCase );\n\t\t\t} else {\n\t\t\t\tkey = jQuery.camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there\'s no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module\'s maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support "private" and "user" data.\n//\t4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === "true" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === "false" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === "null" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn\'t change the string\n\tif ( data === +data + "" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === "string" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn\'t changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( "data-" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, "hasDataAttrs", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === "object" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to "discover" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn\'t exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || "fx" ) + "queue";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || "fx";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === "inprogress" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === "fx" ) {\n\t\t\t\tqueue.unshift( "inprogress" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + "queueHooks";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( "once memory" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + "queue", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== "string" ) {\n\t\t\tdata = type;\n\t\t\ttype = "fx";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === "fx" && queue[ 0 ] !== "inprogress" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || "fx", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== "string" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || "fx";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + "queueHooks" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );\n\n\nvar cssExpand = [ "Top", "Right", "Bottom", "Left" ];\n\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === "none" ||\n\t\t\telem.style.display === "" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tjQuery.contains( elem.ownerDocument, elem ) &&\n\n\t\t\tjQuery.css( elem, "display" ) === "none";\n\t};\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted,\n\t\tscale = 1,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, "" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\tdo {\n\n\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t// Use string for doubling so we don\'t accidentally see scale as unchanged below\n\t\t\tscale = scale || ".5";\n\n\t\t\t// Adjust and apply\n\t\t\tinitialInUnit = initialInUnit / scale;\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t// Break the loop if scale is unchanged or perfect, or if we\'ve just had enough.\n\t\t} while (\n\t\t\tscale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\n\t\t);\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, "display" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === "none" ) {\n\t\tdisplay = "block";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === "none" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, "display" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = "";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== "none" ) {\n\t\t\t\tvalues[ index ] = "none";\n\n\t\t\t\t// Remember what we\'re overwriting\n\t\t\t\tdataPriv.set( elem, "display", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === "boolean" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i );\n\nvar rscriptType = ( /^$|\\/(?:java|ecma)script/i );\n\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// Support: IE <=9 only\n\toption: [ 1, "<select multiple=\'multiple\'>", "</select>" ],\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, "<table>", "</table>" ],\n\tcol: [ 2, "<table><colgroup>", "</colgroup></table>" ],\n\ttr: [ 2, "<table><tbody>", "</tbody></table>" ],\n\ttd: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],\n\n\t_default: [ 0, "", "" ]\n};\n\n// Support: IE <=9 only\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== "undefined" ) {\n\t\tret = context.getElementsByTagName( tag || "*" );\n\n\t} else if ( typeof context.querySelectorAll !== "undefined" ) {\n\t\tret = context.querySelectorAll( tag || "*" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t"globalEval",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], "globalEval" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, contains, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( jQuery.type( elem ) === "object" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( "div" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = "";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = "";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), "script" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( contains ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || "" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( "div" ) ),\n\t\tinput = document.createElement( "input" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( "type", "radio" );\n\tinput.setAttribute( "checked", "checked" );\n\tinput.setAttribute( "name", "t" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn\'t clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = "<textarea>x</textarea>";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n} )();\nvar documentElement = document.documentElement;\n\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 only\n// See #13393 for more info\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === "object" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== "string" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === "string" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards\' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Don\'t attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element\'s event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || "" ).match( rnothtmlwhite ) || [ "" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( "." )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we\'re the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element\'s handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || "" ).match( rnothtmlwhite ) || [ "" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( "(^|\\\\.)" + namespaces.join( "\\\\.(?:.*\\\\.|)" ) + "(\\\\.|$)" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === "**" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it\'s no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, "handle events" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tvar event = jQuery.event.fix( nativeEvent );\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\t\t\thandlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === "click" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don\'t check non-elements (#13208)\n\t\t\t\t// Don\'t process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don\'t conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + " ";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: jQuery.isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: "focusin"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: "focusout"\n\t\t},\n\t\tclick: {\n\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don\'t fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn nodeName( event.target, "a" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn\'t alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This "if" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the \'new\' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn\'t have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t"char": true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\n\twhich: function( event ) {\n\t\tvar button = event.button;\n\n\t\t// Add which for key events\n\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t}\n\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\tif ( button & 1 ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ( button & 2 ) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tif ( button & 4 ) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn event.which;\n\t}\n}, jQuery.event.addProp );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: "mouseover",\n\tmouseleave: "mouseout",\n\tpointerenter: "pointerover",\n\tpointerleave: "pointerout"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + "." + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === "object" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === "function" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t/* eslint-disable max-len */\n\n\t// See https://github.com/eslint/eslint/issues/3229\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\t/* eslint-enable */\n\n\t// Support: IE <=10 - 11, Edge 12 - 13\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked="checked" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n// Prefer a tbody over its parent table for containing new rows\nfunction manipulationTarget( elem, content ) {\n\tif ( nodeName( elem, "table" ) &&\n\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {\n\n\t\treturn jQuery( ">tbody", elem )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute( "type" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.access( src );\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === "input" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === "input" || nodeName === "textarea" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tisFunction = jQuery.isFunction( value );\n\n\t// We can\'t cloneNode fragments that contain checked, in WebKit\n\tif ( isFunction ||\n\t\t\t( l > 1 && typeof value === "string" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( isFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, "script" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, "script" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || "" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, "globalEval" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won\'t run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, "" ), doc );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, "script" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, "<$1></$2>" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, "script" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, "script" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove\'s overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = "";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === "string" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: "append",\n\tprependTo: "prepend",\n\tinsertBefore: "before",\n\tinsertAfter: "after",\n\treplaceAll: "replaceWith"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rmargin = ( /^margin/ );\n\nvar rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they\'re executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdiv.style.cssText =\n\t\t\t"box-sizing:border-box;" +\n\t\t\t"position:relative;display:block;" +\n\t\t\t"margin:auto;border:1px;padding:1px;" +\n\t\t\t"top:1%;width:50%";\n\t\tdiv.innerHTML = "";\n\t\tdocumentElement.appendChild( container );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== "1%";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = divStyle.marginLeft === "2px";\n\t\tboxSizingReliableVal = divStyle.width === "4px";\n\n\t\t// Support: Android 4.0 - 4.3 only\n\t\t// Some styles come back with percentage values, even though they shouldn\'t\n\t\tdiv.style.marginRight = "50%";\n\t\tpixelMarginRightVal = divStyle.marginRight === "4px";\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn\'t be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,\n\t\tcontainer = document.createElement( "div" ),\n\t\tdiv = document.createElement( "div" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = "content-box";\n\tdiv.cloneNode( true ).style.backgroundClip = "";\n\tsupport.clearCloneStyle = div.style.backgroundClip === "content-box";\n\n\tcontainer.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +\n\t\t"padding:0;margin-top:1px;position:absolute";\n\tcontainer.appendChild( div );\n\n\tjQuery.extend( support, {\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelMarginRight: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelMarginRightVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\n\t\t// Support: Firefox 51+\n\t\t// Retrieving style before computed somehow\n\t\t// fixes an issue with getting wrong values\n\t\t// on detached elements\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// getPropertyValue is needed for:\n\t//   .css(\'filter\') (IE 9 only, #12537)\n\t//   .css(\'--customProperty) (#3144)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the "awesome hack by Dean Edwards"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + "" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we\'ll check on the first run if it\'s really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it\'s not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except "table", "table-cell", or "table-caption"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trcustomProp = /^--/,\n\tcssShow = { position: "absolute", visibility: "hidden", display: "block" },\n\tcssNormalTransform = {\n\t\tletterSpacing: "0",\n\t\tfontWeight: "400"\n\t},\n\n\tcssPrefixes = [ "Webkit", "Moz", "ms" ],\n\temptyStyle = document.createElement( "div" ).style;\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\n// Return a property mapped along what jQuery.cssProps suggests or to\n// a vendor prefixed property.\nfunction finalPropName( name ) {\n\tvar ret = jQuery.cssProps[ name ];\n\tif ( !ret ) {\n\t\tret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;\n\t}\n\treturn ret;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined "subtract", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i,\n\t\tval = 0;\n\n\t// If we already have the right measurement, avoid augmentation\n\tif ( extra === ( isBorderBox ? "border" : "content" ) ) {\n\t\ti = 4;\n\n\t// Otherwise initialize for horizontal or vertical properties\n\t} else {\n\t\ti = name === "width" ? 1 : 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin, so add it if we want it\n\t\tif ( extra === "margin" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === "content" ) {\n\t\t\t\tval -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// At this point, extra isn\'t border nor margin, so remove border\n\t\t\tif ( extra !== "margin" ) {\n\t\t\t\tval -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\n\t\t\t}\n\t\t} else {\n\n\t\t\t// At this point, extra isn\'t content, so add padding\n\t\t\tval += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );\n\n\t\t\t// At this point, extra isn\'t content nor padding, so add border\n\t\t\tif ( extra !== "padding" ) {\n\t\t\t\tval += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with computed style\n\tvar valueIsBorderBox,\n\t\tstyles = getStyles( elem ),\n\t\tval = curCSS( elem, name, styles ),\n\t\tisBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";\n\n\t// Computed unit is not pixels. Stop here and return.\n\tif ( rnumnonpx.test( val ) ) {\n\t\treturn val;\n\t}\n\n\t// Check for style in case a browser which returns unreliable values\n\t// for getComputedStyle silently falls back to the reliable elem.style\n\tvalueIsBorderBox = isBorderBox &&\n\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t// Fall back to offsetWidth/Height when value is "auto"\n\t// This happens for inline elements with no explicit setting (gh-3571)\n\tif ( val === "auto" ) {\n\t\tval = elem[ "offset" + name[ 0 ].toUpperCase() + name.slice( 1 ) ];\n\t}\n\n\t// Normalize "", auto, and prepare for extra\n\tval = parseFloat( val ) || 0;\n\n\t// Use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? "border" : "content" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + "px";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, "opacity" );\n\t\t\t\t\treturn ret === "" ? "1" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don\'t automatically add "px" to these possibly-unitless properties\n\tcssNumber: {\n\t\t"animationIterationCount": true,\n\t\t"columnCount": true,\n\t\t"fillOpacity": true,\n\t\t"flexGrow": true,\n\t\t"flexShrink": true,\n\t\t"fontWeight": true,\n\t\t"lineHeight": true,\n\t\t"opacity": true,\n\t\t"order": true,\n\t\t"orphans": true,\n\t\t"widows": true,\n\t\t"zIndex": true,\n\t\t"zoom": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t"float": "cssFloat"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don\'t set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we\'re working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name ),\n\t\t\tstyle = elem.style;\n\n\t\t// Make sure that we\'re working with the right name. We don\'t\n\t\t// want to query the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we\'re setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert "+=" or "-=" to relative numbers (#7345)\n\t\t\tif ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = "number";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren\'t set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\tif ( type === "number" ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone\'s values\n\t\t\tif ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {\n\t\t\t\tstyle[ name ] = "inherit";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( "set" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tif ( isCustomProp ) {\n\t\t\t\t\tstyle.setProperty( name, value );\n\t\t\t\t} else {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && "get" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name );\n\n\t\t// Make sure that we\'re working with the right name. We don\'t\n\t\t// want to modify the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && "get" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert "normal" to computed value\n\t\tif ( val === "normal" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === "" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ "height", "width" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, "display" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = extra && getStyles( elem ),\n\t\t\t\tsubtract = extra && augmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.css( elem, "boxSizing", false, styles ) === "border-box",\n\t\t\t\t\tstyles\n\t\t\t\t);\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || "px" ) !== "px" ) {\n\n\t\t\t\telem.style[ name ] = value;\n\t\t\t\tvalue = jQuery.css( elem, name );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, "marginLeft" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + "px";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: "",\n\tpadding: "",\n\tborder: "Width"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === "string" ? value.split( " " ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as "10px" are parsed to Float;\n\t\t\t// complex values such as "rotate(1rad)" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, "" );\n\n\t\t\t// Empty strings, null, undefined and "auto" are converted to 0.\n\t\t\treturn !result || result === "auto" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: "swing"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, inProgress,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction schedule() {\n\tif ( inProgress ) {\n\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n\t\t\twindow.requestAnimationFrame( schedule );\n\t\t} else {\n\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n\t\t}\n\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ "margin" + which ] = attrs[ "padding" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We\'re done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = "width" in props || "height" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, "fxshow" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, "fx" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, "fx" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === "toggle";\n\t\t\tif ( value === ( hidden ? "hide" : "show" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a "show" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict "overflow" and "display" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 13\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, "display" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, "display" );\n\t\tif ( display === "none" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, "display" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, "float" ) === "none" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === "none" ? "" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = "inline-block";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = "hidden";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( "hidden" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` "reverses"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a "hide" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, "fxshow" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( Array.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && "expand" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won\'t overwrite existing keys.\n\t\t\t// Reusing \'index\' because we have the correct "name"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don\'t match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won\'t allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\t// If there\'s more to do, yield\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t}\n\n\t\t\t// If this was an empty animation, synthesize a final progress notification\n\t\t\tif ( !length ) {\n\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t}\n\n\t\t\t// Resolve the animation and report its conclusion\n\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\treturn false;\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( jQuery.isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tjQuery.proxy( result.stop, result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\t// Attach callbacks from options\n\tanimation\n\t\t.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\treturn animation;\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t"*": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ "*" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off\n\tif ( jQuery.fx.off ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== "number" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> "fx"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = "fx";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won\'t be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, "finish" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== "string" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || "fx", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + "queueHooks",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn\'t forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || "fx";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + "queue" ],\n\t\t\t\thooks = data[ type + "queueHooks" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === "boolean" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( "show" ),\n\tslideUp: genFx( "hide" ),\n\tslideToggle: genFx( "toggle" ),\n\tfadeIn: { opacity: "show" },\n\tfadeOut: { opacity: "hide" },\n\tfadeToggle: { opacity: "toggle" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Run the timer and safely remove it when done (allowing for external removal)\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tjQuery.fx.start();\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( inProgress ) {\n\t\treturn;\n\t}\n\n\tinProgress = true;\n\tschedule();\n};\n\njQuery.fx.stop = function() {\n\tinProgress = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || "fx";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( "input" ),\n\t\tselect = document.createElement( "select" ),\n\t\topt = select.appendChild( document.createElement( "option" ) );\n\n\tinput.type = "checkbox";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be "on"\n\tsupport.checkOn = input.value !== "";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( "input" );\n\tinput.value = "t";\n\tinput.type = "radio";\n\tsupport.radioValue = input.value === "t";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don\'t get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === "undefined" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && "set" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + "" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === "radio" &&\n\t\t\t\t\tnodeName( elem, "input" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( "type", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don\'t get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && "set" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn\'t always return the\n\t\t\t\t// correct value when it hasn\'t been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, "tabindex" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t"for": "htmlFor",\n\t\t"class": "className"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule "no-unused-expressions" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: "off" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: "off" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t"tabIndex",\n\t"readOnly",\n\t"maxLength",\n\t"cellSpacing",\n\t"cellPadding",\n\t"rowSpan",\n\t"colSpan",\n\t"useMap",\n\t"frameBorder",\n\t"contentEditable"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( " " );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( "class" ) || "";\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( typeof value === "string" && value ) {\n\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( " " + clazz + " " ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + " ";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( "class", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( "class", "" );\n\t\t}\n\n\t\tif ( typeof value === "string" && value ) {\n\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( " " + clazz + " " ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( " " + clazz + " ", " " );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( "class", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === "boolean" && type === "string" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( type === "string" ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = value.match( rnothtmlwhite ) || [];\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === "boolean" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, "__className__", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we\'re passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( "class",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t"" :\n\t\t\t\t\t\tdataPriv.get( this, "__className__" ) || ""\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = " " + selector + " ";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t"get" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, "value" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === "string" ) {\n\t\t\t\t\treturn ret.replace( rreturn, "" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? "" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as ""; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = "";\n\n\t\t\t} else if ( typeof val === "number" ) {\n\t\t\t\tval += "";\n\n\t\t\t} else if ( Array.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? "" : value + "";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, "value" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === "select-one",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn\'t update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don\'t return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!nodeName( option.parentNode, "optgroup" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don\'t need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ "radio", "checkbox" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( Array.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( "value" ) === null ? "on" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, "type" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don\'t do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we\'re not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( "." ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( "." );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( ":" ) < 0 && "on" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === "object" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( "." );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( "(^|\\\\.)" + namespaces.join( "\\\\.(?:.*\\\\.|)" ) + "(\\\\.|$)" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, "handle" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don\'t do default actions on window, that\'s where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don\'t re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\njQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +\n\t"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +\n\t"change select submit keydown keypress keyup contextmenu" ).split( " " ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\n\n\nsupport.focusin = "onfocusin" in window;\n\n\n// Support: Firefox <=44\n// Firefox doesn\'t have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = jQuery.now();\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== "string" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {\n\t\tjQuery.error( "Invalid XML: " + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( Array.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && jQuery.type( obj ) === "object" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = jQuery.isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + "=" +\n\t\t\t\tencodeURIComponent( value == null ? "" : value );\n\t\t};\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the "old" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( "&" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for "elements" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, "elements" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( ":disabled" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( ":disabled" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( Array.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, "\\r\\n" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, "\\r\\n" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol "*" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to "*" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol "*" can be used\n\t * 3) selection will start with transport dataType and THEN go to "*" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = "*/".concat( "*" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( "a" );\n\toriginAnchor.href = location.href;\n\n// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to "*"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== "string" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = "*";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === "+" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || "*";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === "string" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );\n}\n\n// A special extend for ajax options\n// that takes "flat" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === "*" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );\n\t\t}\n\t}\n\n\t// Check if we\'re dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There\'s only work to do if current dataType is non-auto\n\t\t\tif ( current === "*" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== "*" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + " " + current ] || converters[ "* " + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( " " );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + " " + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ "* " + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: "parsererror",\n\t\t\t\t\t\t\t\terror: conv ? e : "No conversion from " + prev + " to " + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: "success", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: "GET",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: "application/x-www-form-urlencoded; charset=UTF-8",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t"*": allTypes,\n\t\t\ttext: "text/plain",\n\t\t\thtml: "text/html",\n\t\t\txml: "application/xml, text/xml",\n\t\t\tjson: "application/json, text/javascript"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: "responseXML",\n\t\t\ttext: "responseText",\n\t\t\tjson: "responseJSON"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall "*") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t"* text": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t"text html": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t"text json": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t"text xml": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn\'t be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn\'t be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === "object" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( "once memory" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = "canceled",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + "" )\n\t\t\t.replace( rprotocol, location.protocol + "//" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];\n\n\t\t// A cross-domain request is in order when the origin doesn\'t match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( "a" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 13\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor\'s host property isn\'t correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + "//" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== "string" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don\'t fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( "ajaxStart" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we\'re toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, "" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it\'s not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, "$1" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change \'%20\' to \'+\' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, "+" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( "Content-Type", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t"Accept",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :\n\t\t\t\ts.accepts[ "*" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = "abort";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, "No Transport" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( "timeout" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || "";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( "Last-Modified" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( "etag" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === "HEAD" ) {\n\t\t\t\t\tstatusText = "nocontent";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = "notmodified";\n\n\t\t\t\t// If we have data, let\'s convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = "error";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + "";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( "ajaxStop" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, "json" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, "script" );\n\t}\n} );\n\njQuery.each( [ "get", "post" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: "GET",\n\t\tdataType: "script",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\t\t"throws": true\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( "body" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won\'t change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {\n\t\t\t\t\theaders[ "X-Requested-With" ] = "XMLHttpRequest";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === "abort" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === "error" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== "number" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, "error" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || "text" ) !== "text"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== "string" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = callback( "error" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( "abort" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn\'t been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: "text/javascript, application/javascript, " +\n\t\t\t"application/ecmascript, application/x-ecmascript"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t"text script": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache\'s special case and crossDomain\njQuery.ajaxPrefilter( "script", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = "GET";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( "script", function( s ) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( "<script>" ).prop( {\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t} ).on(\n\t\t\t\t\t"load error",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === "error" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: "callback",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t"url" :\n\t\t\ttypeof s.data === "string" &&\n\t\t\t\t( s.contentType || "" )\n\t\t\t\t\t.indexOf( "application/x-www-form-urlencoded" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && "data"\n\t\t);\n\n\t// Handle iff the expected data type is "jsonp" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ "script json" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + " was not called" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = "json";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn\'t exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn\'t screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn "script";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( "" ).body;\n\tbody.innerHTML = "<form></form><form></form>";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument "data" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== "string" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === "boolean" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( "" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document\'s URL (gh-2965)\n\t\t\tbase = context.createElement( "base" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( " " );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it\'s a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it\'s the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === "object" ) {\n\t\ttype = "POST";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If "type" variable is undefined, then "GET" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || "GET",\n\t\t\tdataType: "html",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE \'Permission Denied\' errors\n\t\t\t\tjQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets "data", "status", "jqXHR"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets "jqXHR", "status", "error"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t"ajaxStart",\n\t"ajaxStop",\n\t"ajaxComplete",\n\t"ajaxError",\n\t"ajaxSuccess",\n\t"ajaxSend"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, "position" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === "static" ) {\n\t\t\telem.style.position = "relative";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, "top" );\n\t\tcurCSSLeft = jQuery.css( elem, "left" );\n\t\tcalculatePosition = ( position === "absolute" || position === "fixed" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( "using" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar doc, docElem, rect, win,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\trect = elem.getBoundingClientRect();\n\n\t\tdoc = elem.ownerDocument;\n\t\tdocElem = doc.documentElement;\n\t\twin = doc.defaultView;\n\n\t\treturn {\n\t\t\ttop: rect.top + win.pageYOffset - docElem.clientTop,\n\t\t\tleft: rect.left + win.pageXOffset - docElem.clientLeft\n\t\t};\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n\t\t// because it is its only offset parent\n\t\tif ( jQuery.css( elem, "position" ) === "fixed" ) {\n\n\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !nodeName( offsetParent[ 0 ], "html" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset = {\n\t\t\t\ttop: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),\n\t\t\t\tleft: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )\n\t\t\t};\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {\n\tvar top = "pageYOffset" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\n\t\t\t// Coalesce documents and windows\n\t\t\tvar win;\n\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\twin = elem;\n\t\t\t} else if ( elem.nodeType === 9 ) {\n\t\t\t\twin = elem.defaultView;\n\t\t\t}\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ "top", "left" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + "px" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: "height", Width: "width" }, function( name, type ) {\n\tjQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( "outer" ) === 0 ?\n\t\t\t\t\t\telem[ "inner" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ "client" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ "scroll" + name ], doc[ "scroll" + name ],\n\t\t\t\t\t\telem.body[ "offset" + name ], doc[ "offset" + name ],\n\t\t\t\t\t\tdoc[ "client" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, "**" ) :\n\t\t\tthis.off( types, selector || "**", fn );\n\t}\n} );\n\njQuery.holdReady = function( hold ) {\n\tif ( hold ) {\n\t\tjQuery.readyWait++;\n\t} else {\n\t\tjQuery.ready( true );\n\t}\n};\njQuery.isArray = Array.isArray;\njQuery.parseJSON = JSON.parse;\njQuery.nodeName = nodeName;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\treturn jQuery;\n\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n} );\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdGxhc01ha2VyV2lkZ2V0Ly4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcz8xMTU3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFlBQVk7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUYsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsU0FBUztBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsWUFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsZ0JBQWdCLElBQUk7O0FBRXBCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVEsNkJBQTZCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFlOztBQUVmLFNBQVM7O0FBRVQ7QUFDQSxRQUFRLGlDQUFpQztBQUN6QyxRQUFRLG9CQUFvQjtBQUM1QixRQUFRLHNDQUFzQztBQUM5QyxRQUFRO0FBQ1IsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWEsRUFBRTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxVQUFVO0FBQzNFLHNDQUFzQywyQkFBMkI7QUFDakU7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLHVFQUF1RTtBQUNuRjtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0Esb0ZBQW9GOztBQUVwRjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlEQUFpRDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxVQUFVLHdDQUF3QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBLENBQUM7Ozs7QUFJRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxRQUFRLEdBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLDBCQUEwQix3QkFBd0I7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxzQ0FBc0M7QUFDOUUsb0NBQW9DLHVDQUF1QztBQUMzRSxvQ0FBb0Msc0NBQXNDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEMscUNBQXFDO0FBQ3JDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixhQUFhO0FBQ3BDLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGOztBQUVBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0JBQWdCO0FBQ2xCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDs7QUFFQTtBQUNBOztBQUVBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrREFBK0Q7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGNBQWM7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUNBQXVDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1REFBdUQ7QUFDOUU7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSwrQkFBK0I7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxxQ0FBcUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDhCQUE4QjtBQUN2Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxXQUFXO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQixzQkFBc0IsY0FBYztBQUNwQyxnQkFBZ0IsV0FBVyxZQUFZO0FBQ3ZDLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxVQUFVLFNBQVMsTUFBTSxhQUFhO0FBQzNFLGFBQWEsZUFBZTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQStEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBLFFBQVEsT0FBTzs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUEsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdCQUFnQjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlEQUFpRCwwQkFBMEI7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUEsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLGdCQUFnQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0JBQWtCO0FBQzVCLFdBQVcsa0JBQWtCO0FBQzdCLGNBQWM7QUFDZCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFFBQVEsbUJBQW1CO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQUs7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUNBQXFDOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDs7QUFFQSxXQUFXO0FBQ1gsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQiw0REFBNEQsZUFBZTtBQUMzRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxjQUFjLHNEQUFzRDtBQUNwRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pELGVBQWUsNkRBQTZEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSyxJQUEwQztBQUMvQyxDQUFDLGlDQUFrQixFQUFFLG1DQUFFO0FBQ3ZCO0FBQ0EsRUFBRTtBQUFBLG9HQUFFO0FBQ0o7Ozs7O0FBS0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBLENBQUMiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My4yLjFcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE3LTAzLTIwVDE4OjU5WlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhcnIgPSBbXTtcblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcblxudmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKCBPYmplY3QgKTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxuXG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgZG9jICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy4yLjFcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyxcblxuXHQvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcblx0cm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nLFxuXG5cdC8vIFVzZWQgYnkgalF1ZXJ5LmNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcblx0ZmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBhbGwsIGxldHRlciApIHtcblx0XHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cblx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0aWYgKCBudW0gPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdHJldHVybiBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFqUXVlcnkuaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSApIHtcblx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBBcnJheS5pc0FycmF5KCBzcmMgKSA/IHNyYyA6IFtdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzRnVuY3Rpb246IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJmdW5jdGlvblwiO1xuXHR9LFxuXG5cdGlzV2luZG93OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH0sXG5cblx0aXNOdW1lcmljOiBmdW5jdGlvbiggb2JqICkge1xuXG5cdFx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cblx0XHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdFx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0XHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblx0XHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xuXHR9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIHByb3RvLCBDdG9yO1xuXG5cdFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG5cdFx0Ly8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG5cdFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuXHRcdGlmICggIXByb3RvICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cblx0XHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcImNvbnN0cnVjdG9yXCIgKSAmJiBwcm90by5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy82MTI1XG5cdFx0dmFyIG5hbWU7XG5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0dHlwZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0XHR0eXBlb2Ygb2JqO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlICkge1xuXHRcdERPTUV2YWwoIGNvZGUgKTtcblx0fSxcblxuXHQvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTNcblx0Ly8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuXHRjYW1lbENhc2U6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG5cdC8vIGFyZ3VtZW50cy5cblx0cHJveHk6IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0XHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdFx0Y29udGV4dCA9IGZuO1xuXHRcdFx0Zm4gPSB0bXA7XG5cdFx0fVxuXG5cdFx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0XHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBTaW11bGF0ZWQgYmluZFxuXHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0XHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdFx0fTtcblxuXHRcdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRcdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdFx0cmV0dXJuIHByb3h5O1xuXHR9LFxuXG5cdG5vdzogRGF0ZS5ub3csXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cblx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy4zXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0wOC0wOFxuICovXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcblxudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0W2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXDAtXFxcXHhhMF0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXG5cdHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCBcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblxuXHQvLyBDU1MgZXNjYXBlc1xuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxuXHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cblx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHQvLyBCTVAgY29kZXBvaW50XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cblx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG5cdHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcblx0ZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG5cdFx0aWYgKCBhc0NvZGVQb2ludCApIHtcblxuXHRcdFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHRpZiAoIGNoID09PSBcIlxcMFwiICkge1xuXHRcdFx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cdFx0XHRyZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcIlxcXFxcIiArIGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFwiIFwiO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblx0XHRyZXR1cm4gXCJcXFxcXCIgKyBjaDtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fSxcblxuXHRkaXNhYmxlZEFuY2VzdG9yID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIChcImZvcm1cIiBpbiBlbGVtIHx8IFwibGFiZWxcIiBpbiBlbGVtKTtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXG5cdFx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXG5cdFx0XHRcdC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB3b3JrYXJvdW5kIHRlY2huaXF1ZVxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PThcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0fSBlbHNlIGlmICggY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRpZiAoIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkpICkge1xuXHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBcIiNcIiArIG5pZCArIFwiIFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZWwgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXG5cdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuXHRcdGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuXHRcdFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG5cdFx0XHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcblx0XHRcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG5cdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gMTFcblx0XHRcdFx0Ly8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblx0XHRcdFx0cmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHRcdC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG5cdFx0XHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdGRpc2FibGVkQW5jZXN0b3IoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0aWYgKCBwcmVmZXJyZWREb2MgIT09IGRvY3VtZW50ICYmXG5cdFx0KHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuXHRcdGlmICggc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggc3ViV2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0c3ViV2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXHRcdHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBub2RlLCBpLCBlbGVtcyxcblx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHQvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtc1tpKytdKSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZWwsIFwiKlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZWwsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUpICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6XG5cdFx0XHRcdGIgPT09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IWNvbXBpbGVyQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn07XG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbnZhciByaXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC87XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2luZ2xlIGVsZW1lbnRcblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNpbXBsZSBzZWxlY3RvciB0aGF0IGNhbiBiZSBmaWx0ZXJlZCBkaXJlY3RseSwgcmVtb3Zpbmcgbm9uLUVsZW1lbnRzXG5cdGlmICggcmlzU2ltcGxlLnRlc3QoIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcblx0fVxuXG5cdC8vIENvbXBsZXggc2VsZWN0b3IsIGNvbXBhcmUgdGhlIHR3byBzZXRzLCByZW1vdmluZyBub24tRWxlbWVudHNcblx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApO1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90ICYmIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdGlmICggZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCByZXQsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIHJldCApIDogcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuXHRcdFx0XHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuXHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbIDEgXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIGlmICggbm9kZU5hbWUoIGVsZW0sIFwiaWZyYW1lXCIgKSApIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5LCBpT1MgNyBvbmx5LCBBbmRyb2lkIEJyb3dzZXIgPD00LjMgb25seVxuICAgICAgICAvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcbiAgICAgICAgLy8gZG9uJ3Qgc3VwcG9ydCBpdC5cbiAgICAgICAgaWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0ZW1wbGF0ZVwiICkgKSB7XG4gICAgICAgICAgICBlbGVtID0gZWxlbS5jb250ZW50IHx8IGVsZW07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdGh0bWx3aGl0ZSA9ICggL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gbG9ja2VkIHx8IG9wdGlvbnMub25jZTtcblxuXHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgalF1ZXJ5LnR5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG5cdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlXG5cdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGlmICggIW1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5mdW5jdGlvbiBJZGVudGl0eSggdiApIHtcblx0cmV0dXJuIHY7XG59XG5mdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcblx0dGhyb3cgZXg7XG59XG5cbmZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QsIG5vVmFsdWUgKSB7XG5cdHZhciBtZXRob2Q7XG5cblx0dHJ5IHtcblxuXHRcdC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3Jcblx0XHRpZiAoIHZhbHVlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnByb21pc2UgKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlICkuZG9uZSggcmVzb2x2ZSApLmZhaWwoIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgdGhlbmFibGVzXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0dmFyIG1heERlcHRoID0gMDtcblx0XHRcdFx0XHRmdW5jdGlvbiByZXNvbHZlKCBkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCwgdGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggPCBtYXhEZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9ucyAyLjMuMy4xLCAzLjVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03NVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmV0cmlldmUgYHRoZW5gIG9ubHkgb25jZVxuXHRcdFx0XHRcdFx0XHRcdFx0dGhlbiA9IHJldHVybmVkICYmXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCB0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgcmV0dXJuZWQgPT09IFwiZnVuY3Rpb25cIiApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggb25GdWxmaWxsZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkZ1bGZpbGxlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDIgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMiBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWRcblx0XHRcdG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRtYXN0ZXIucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBtYXN0ZXIucmVqZWN0LFxuXHRcdFx0XHQhcmVtYWluaW5nICk7XG5cblx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdGlmICggbWFzdGVyLnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgcmVzb2x2ZVZhbHVlc1sgaSBdLnRoZW4gKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gbWFzdGVyLnRoZW4oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggcmVzb2x2ZVZhbHVlc1sgaSBdLCB1cGRhdGVGdW5jKCBpICksIG1hc3Rlci5yZWplY3QgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFzdGVyLnByb21pc2UoKTtcblx0fVxufSApO1xuXG5cbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxuLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG52YXIgcmVycm9yTmFtZXMgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcblxualF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiggZXJyb3IsIHN0YWNrICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcblx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcblx0aWYgKCB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuICYmIGVycm9yICYmIHJlcnJvck5hbWVzLnRlc3QoIGVycm9yLm5hbWUgKSApIHtcblx0XHR3aW5kb3cuY29uc29sZS53YXJuKCBcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2ssIHN0YWNrICk7XG5cdH1cbn07XG5cblxuXG5cbmpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdHRocm93IGVycm9yO1xuXHR9ICk7XG59O1xuXG5cblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG5cdHJlYWR5TGlzdFxuXHRcdC50aGVuKCBmbiApXG5cblx0XHQvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuXHRcdC8vIGhhcHBlbnMgYXQgdGhlIHRpbWUgb2YgZXJyb3IgaGFuZGxpbmcgaW5zdGVhZCBvZiBjYWxsYmFja1xuXHRcdC8vIHJlZ2lzdHJhdGlvbi5cblx0XHQuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcblx0XHRcdGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiggZXJyb3IgKTtcblx0XHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XG5cbi8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbi8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG4vLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDEwIG9ubHlcbi8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cblx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxufSBlbHNlIHtcblxuXHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xufVxuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIGpRdWVyeS50eXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIGNoYWluYWJsZSApIHtcblx0XHRyZXR1cm4gZWxlbXM7XG5cdH1cblxuXHQvLyBHZXRzXG5cdGlmICggYnVsayApIHtcblx0XHRyZXR1cm4gZm4uY2FsbCggZWxlbXMgKTtcblx0fVxuXG5cdHJldHVybiBsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggZGF0YSApIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVbIGpRdWVyeS5jYW1lbENhc2UoIHByb3AgKSBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG5cdFx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGpRdWVyeS5jYW1lbENhc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuXHRpZiAoIGRhdGEgPT09IFwidHJ1ZVwiICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcImZhbHNlXCIgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcIm51bGxcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdGlmICggZGF0YSA9PT0gK2RhdGEgKyBcIlwiICkge1xuXHRcdHJldHVybiArZGF0YTtcblx0fVxuXG5cdGlmICggcmJyYWNlLnRlc3QoIGRhdGEgKSApIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgJiZcblxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCI7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCxcblx0XHRzY2FsZSA9IDEsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uY3VyKCk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuXHRcdFx0fSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0ZG8ge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyBpdGVyYXRpb24gemVyb2VkIG91dCwgZG91YmxlIHVudGlsIHdlIGdldCAqc29tZXRoaW5nKi5cblx0XHRcdC8vIFVzZSBzdHJpbmcgZm9yIGRvdWJsaW5nIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBzZWUgc2NhbGUgYXMgdW5jaGFuZ2VkIGJlbG93XG5cdFx0XHRzY2FsZSA9IHNjYWxlIHx8IFwiLjVcIjtcblxuXHRcdFx0Ly8gQWRqdXN0IGFuZCBhcHBseVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpXG5cdFx0Ly8gQnJlYWsgdGhlIGxvb3AgaWYgc2NhbGUgaXMgdW5jaGFuZ2VkIG9yIHBlcmZlY3QsIG9yIGlmIHdlJ3ZlIGp1c3QgaGFkIGVub3VnaC5cblx0XHR9IHdoaWxlIChcblx0XHRcdHNjYWxlICE9PSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsICkgJiYgc2NhbGUgIT09IDEgJiYgLS1tYXhJdGVyYXRpb25zXG5cdFx0KTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKykvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBjb250YWlucywgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIGpRdWVyeS50eXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XG5cblx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuXHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdGkgPSAwO1xuXHR3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xuXG5cdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4Nylcblx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcblx0XHRcdGlmICggaWdub3JlZCApIHtcblx0XHRcdFx0aWdub3JlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjb250YWlucyA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGNvbnRhaW5zICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFNlZSAjMTMzOTMgZm9yIG1vcmUgaW5mb1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuXHRcdGlmICggIWVsZW1EYXRhICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcblx0XHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcblx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdHZhciBldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICk7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblx0XHRcdGhhbmRsZXJzID0gKCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yIDIpIGhhdmUgbmFtZXNwYWNlKHMpXG5cdFx0XHRcdC8vIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuXHRcdFx0XHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGpRdWVyeS5pc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcblx0XHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRvcmlnaW5hbEV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Zm9jdXM6IHtcblxuXHRcdFx0Ly8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG5cdFx0XHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcblx0XHR9LFxuXHRcdGJsdXI6IHtcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyICkge1xuXHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBGb3IgY2hlY2tib3gsIGZpcmUgbmF0aXZlIGV2ZW50IHNvIGNoZWNrZWQgc3RhdGUgd2lsbCBiZSByaWdodFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgJiYgdGhpcy5jbGljayAmJiBub2RlTmFtZSggdGhpcywgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5jbGljaygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRyZXR1cm4gbm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seVxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0XHQvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgPD02IC0gNyBvbmx5XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHR0aGlzLnRhcmdldCA9ICggc3JjLnRhcmdldCAmJiBzcmMudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkgP1xuXHRcdFx0c3JjLnRhcmdldC5wYXJlbnROb2RlIDpcblx0XHRcdHNyYy50YXJnZXQ7XG5cblx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcblx0XHR0aGlzLnJlbGF0ZWRUYXJnZXQgPSBzcmMucmVsYXRlZFRhcmdldDtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cblx0d2hpY2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQuY2hhckNvZGUgIT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgcm1vdXNlRXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0aWYgKCBidXR0b24gJiAxICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiAyICkge1xuXHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiA0ICkge1xuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LndoaWNoO1xuXHR9XG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbnZhclxuXG5cdC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzMyMjlcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKVtePl0qKVxcLz4vZ2ksXG5cblx0LyogZXNsaW50LWVuYWJsZSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzXG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJzY3JpcHRUeXBlTWFza2VkID0gL150cnVlXFwvKC4qKS8sXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4galF1ZXJ5KCBcIj50Ym9keVwiLCBlbGVtIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdHZhciBtYXRjaCA9IHJzY3JpcHRUeXBlTWFza2VkLmV4ZWMoIGVsZW0udHlwZSApO1xuXG5cdGlmICggbWF0Y2ggKSB7XG5cdFx0ZWxlbS50eXBlID0gbWF0Y2hbIDEgXTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuXHRcdFx0cGRhdGFDdXIuZXZlbnRzID0ge307XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCBpc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIGRvYyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBub2RlLm93bmVyRG9jdW1lbnQsIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlnbm9yZWQgPSBbXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdH0sIGlnbm9yZWQgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCgge1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xudmFyIHJtYXJnaW4gPSAoIC9ebWFyZ2luLyApO1xuXG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblxuXHRcdC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2Vcblx0XHRpZiAoICFkaXYgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIgK1xuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcInRvcDoxJTt3aWR0aDo1MCVcIjtcblx0XHRkaXYuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSBkaXZTdHlsZS5tYXJnaW5MZWZ0ID09PSBcIjJweFwiO1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFwiNHB4XCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gXCI1MCVcIjtcblx0XHRwaXhlbE1hcmdpblJpZ2h0VmFsID0gZGl2U3R5bGUubWFyZ2luUmlnaHQgPT09IFwiNHB4XCI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0Ly8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuXHRcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcblx0XHRkaXYgPSBudWxsO1xuXHR9XG5cblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBwaXhlbE1hcmdpblJpZ2h0VmFsLCByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjA7d2lkdGg6OHB4O2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweDtcIiArXG5cdFx0XCJwYWRkaW5nOjA7bWFyZ2luLXRvcDoxcHg7cG9zaXRpb246YWJzb2x1dGVcIjtcblx0Y29udGFpbmVyLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0fSxcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsTWFyZ2luUmlnaHRWYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA1MStcblx0XHQvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG5cdFx0Ly8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuXHRcdC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBuZWVkZWQgZm9yOlxuXHQvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksICMxMjUzNylcblx0Ly8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoIzMxNDQpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxNYXJnaW5SaWdodCgpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiBybWFyZ2luLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cmN1c3RvbVByb3AgPSAvXi0tLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH0sXG5cblx0Y3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlO1xuXG4vLyBSZXR1cm4gYSBjc3MgcHJvcGVydHkgbWFwcGVkIHRvIGEgcG90ZW50aWFsbHkgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBTaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG4vLyBSZXR1cm4gYSBwcm9wZXJ0eSBtYXBwZWQgYWxvbmcgd2hhdCBqUXVlcnkuY3NzUHJvcHMgc3VnZ2VzdHMgb3IgdG9cbi8vIGEgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5LlxuZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcblx0dmFyIHJldCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdO1xuXHRpZiAoICFyZXQgKSB7XG5cdFx0cmV0ID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG5cdH1cblx0cmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYXVnbWVudFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhLCBpc0JvcmRlckJveCwgc3R5bGVzICkge1xuXHR2YXIgaSxcblx0XHR2YWwgPSAwO1xuXG5cdC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuXHRpZiAoIGV4dHJhID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0aSA9IDQ7XG5cblx0Ly8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuXHR9IGVsc2Uge1xuXHRcdGkgPSBuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMDtcblx0fVxuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpbiwgc28gYWRkIGl0IGlmIHdlIHdhbnQgaXRcblx0XHRpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIGV4dHJhICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdGlmICggaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxuXHRcdFx0aWYgKCBleHRyYSA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgYm9yZGVyIG5vciBtYXJnaW4sIHNvIHJlbW92ZSBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQsIHNvIGFkZCBwYWRkaW5nXG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQgbm9yIHBhZGRpbmcsIHNvIGFkZCBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG5cdHZhciB2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICksXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdC8vIENvbXB1dGVkIHVuaXQgaXMgbm90IHBpeGVscy4gU3RvcCBoZXJlIGFuZCByZXR1cm4uXG5cdGlmICggcm51bW5vbnB4LnRlc3QoIHZhbCApICkge1xuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvLyBDaGVjayBmb3Igc3R5bGUgaW4gY2FzZSBhIGJyb3dzZXIgd2hpY2ggcmV0dXJucyB1bnJlbGlhYmxlIHZhbHVlc1xuXHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJlxuXHRcdCggc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IHZhbCA9PT0gZWxlbS5zdHlsZVsgbmFtZSBdICk7XG5cblx0Ly8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL0hlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG5cdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0aWYgKCB2YWwgPT09IFwiYXV0b1wiICkge1xuXHRcdHZhbCA9IGVsZW1bIFwib2Zmc2V0XCIgKyBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSBdO1xuXHR9XG5cblx0Ly8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdC8vIFVzZSB0aGUgYWN0aXZlIGJveC1zaXppbmcgbW9kZWwgdG8gYWRkL3N1YnRyYWN0IGlycmVsZXZhbnQgc3R5bGVzXG5cdHJldHVybiAoIHZhbCArXG5cdFx0YXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0bmFtZSxcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0XHRzdHlsZXNcblx0XHQpXG5cdCkgKyBcInB4XCI7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7XG5cdFx0XCJmbG9hdFwiOiBcImNzc0Zsb2F0XCJcblx0fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdFx0c3R5bGUuc2V0UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrXG5cdFx0XHRcdFx0Ly8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cblx0XHRcdFx0XHQvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB1bmxlc3MgZGlzcGxheSBpcyBjaGFuZ2VkLlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdFx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHRcdFx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0XHRcdFx0KCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCApID9cblx0XHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZXh0cmEgJiYgZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0XHRcdHN1YnRyYWN0ID0gZXh0cmEgJiYgYXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdCk7XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG5cdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggIXJtYXJnaW4udGVzdCggcHJlZml4ICkgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCB0d2Vlbi5lbGVtLnN0eWxlWyBqUXVlcnkuY3NzUHJvcHNbIHR3ZWVuLnByb3AgXSBdICE9IG51bGwgfHxcblx0XHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgaW5Qcm9ncmVzcyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBqUXVlcnkubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHR9XG5cblx0cmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcblx0dmFyIHR3ZWVuLFxuXHRcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcblx0XHRpc0JveCA9IFwid2lkdGhcIiBpbiBwcm9wcyB8fCBcImhlaWdodFwiIGluIHByb3BzLFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xuXHRpZiAoICFvcHRzLnF1ZXVlICkge1xuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRob29rcy51bnF1ZXVlZCA9IDA7XG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG5cdFx0XHRcdC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXG5cdFx0XHRcdC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxuXHRwcm9wVHdlZW4gPSAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3BzICk7XG5cdGlmICggIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlc3RyaWN0IFwib3ZlcmZsb3dcIiBhbmQgXCJkaXNwbGF5XCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xuXHRpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDEzXG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXG5cdFx0Ly8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1lcblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxuXHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVNob3cgJiYgZGF0YVNob3cuZGlzcGxheTtcblx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHR9XG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgKSB7XG5cdFx0XHRcdGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gR2V0IG5vbmVtcHR5IHZhbHVlKHMpIGJ5IHRlbXBvcmFyaWx5IGZvcmNpbmcgdmlzaWJpbGl0eVxuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwiaW5saW5lXCIgfHwgZGlzcGxheSA9PT0gXCJpbmxpbmUtYmxvY2tcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0XHRcdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuXHRcdFx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBkaXNwbGF5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRwcm9wVHdlZW4gPSBmYWxzZTtcblx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXG5cdFx0Ly8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cblx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwgeyBkaXNwbGF5OiByZXN0b3JlRGlzcGxheSB9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFwicmV2ZXJzZXNcIlxuXHRcdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRcdC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxuXHRcdFx0XHRpZiAoICFoaWRkZW4gKSB7XG5cdFx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gUGVyLXByb3BlcnR5IHNldHVwXG5cdFx0cHJvcFR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRcdHByb3BUd2Vlbi5zdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdGpRdWVyeS5wcm94eSggcmVzdWx0LnN0b3AsIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHQvLyBBdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRhbmltYXRpb25cblx0XHQucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdHJldHVybiBhbmltYXRpb247XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblxuXHR0d2VlbmVyczoge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XG5cdFx0XHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fSxcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHQvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmZcblx0aWYgKCBqUXVlcnkuZngub2ZmICkge1xuXHRcdG9wdC5kdXJhdGlvbiA9IDA7XG5cblx0fSBlbHNlIHtcblx0XHRpZiAoIHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRpZiAoIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzICkge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBqUXVlcnkubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aW5Qcm9ncmVzcyA9IHRydWU7XG5cdHNjaGVkdWxlKCk7XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpblByb2dyZXNzID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdGkgPSAwLFxuXG5cdFx0XHQvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG5cdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDExMTYyMzMzNDcvaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0aWYgKCB0YWJpbmRleCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiZcblx0XHRcdFx0XHRlbGVtLmhyZWZcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbi8vIGVzbGludCBydWxlIFwibm8tdW51c2VkLWV4cHJlc3Npb25zXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxuLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxuXHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG5cdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZnJhc3RydWN0dXJlLmh0bWwjc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSApIHtcblx0XHRcdGNsYXNzZXMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXCIgXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgaXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLztcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbDtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlT3JGdW5jdGlvbiApID9cblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uKCkgOlxuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb247XG5cblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgK1xuXHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHR9O1xuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggQXJyYXkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9IClcblx0XHQuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApXG5cdFx0Lm1hcCggZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cjIwID0gLyUyMC9nLFxuXHRyaGFzaCA9IC8jLiokLyxcblx0cmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTNcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXCIkMVwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UrKyApICsgdW5jYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuXHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcblx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuXHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXHRcdFwidGhyb3dzXCI6IHRydWVcblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiICkucHJvcCgge1xuXHRcdFx0XHRcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcblx0XHRcdFx0XHRzcmM6IHMudXJsXG5cdFx0XHRcdH0gKS5vbihcblx0XHRcdFx0XHRcImxvYWQgZXJyb3JcIixcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciBkb2MsIGRvY0VsZW0sIHJlY3QsIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0cmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0d2luID0gZG9jLmRlZmF1bHRWaWV3O1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQgLSBkb2NFbGVtLmNsaWVudFRvcCxcblx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldCAtIGRvY0VsZW0uY2xpZW50TGVmdFxuXHRcdH07XG5cdH0sXG5cblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIEZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB3aW5kb3cgKHBhcmVudE9mZnNldCA9IHt0b3A6MCwgbGVmdDogMH0sXG5cdFx0Ly8gYmVjYXVzZSBpdCBpcyBpdHMgb25seSBvZmZzZXQgcGFyZW50XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIHRoZXJlIHdoZW4gY29tcHV0ZWQgcG9zaXRpb24gaXMgZml4ZWRcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuXHRcdFx0b2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQoKTtcblxuXHRcdFx0Ly8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblx0XHRcdGlmICggIW5vZGVOYW1lKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJodG1sXCIgKSApIHtcblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcblx0XHRcdHBhcmVudE9mZnNldCA9IHtcblx0XHRcdFx0dG9wOiBwYXJlbnRPZmZzZXQudG9wICsgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApLFxuXHRcdFx0XHRsZWZ0OiBwYXJlbnRPZmZzZXQubGVmdCArIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlIClcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0dmFyIHdpbjtcblx0XHRcdGlmICggalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW07XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtLmRlZmF1bHRWaWV3O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sXG5cdFx0ZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuXHRcdFx0XHRcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcIm91dGVyXCIgKSA9PT0gMCA/XG5cdFx0XHRcdFx0XHRlbGVtWyBcImlubmVyXCIgKyBuYW1lIF0gOlxuXHRcdFx0XHRcdFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuaG9sZFJlYWR5ID0gZnVuY3Rpb24oIGhvbGQgKSB7XG5cdGlmICggaG9sZCApIHtcblx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdH1cbn07XG5qUXVlcnkuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcbmpRdWVyeS5ub2RlTmFtZSA9IG5vZGVOYW1lO1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCAhbm9HbG9iYWwgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n')},function(module,exports,__webpack_require__){eval('var require;var require;!function(t){if(true)module.exports=t();else {}}(function(){return function t(e,a,i){function n(s,o){if(!a[s]){if(!e[s]){var l="function"==typeof require&&require;if(!o&&l)return require(s,!0);if(r)return r(s,!0);var h=new Error("Cannot find module \'"+s+"\'");throw h.code="MODULE_NOT_FOUND",h}var d=a[s]={exports:{}};e[s][0].call(d.exports,function(t){var a=e[s][1][t];return n(a||t)},d,d.exports,t,e,a,i)}return a[s].exports}for(var r="function"==typeof require&&require,s=0;s<i.length;s++)n(i[s]);return n}({1:[function(t,e,a){"use strict";function i(t){if(!(this instanceof i))return new i(t);this.options=s.assign({level:_,method:c,chunkSize:16384,windowBits:15,memLevel:8,strategy:u,to:""},t||{});var e=this.options;e.raw&&e.windowBits>0?e.windowBits=-e.windowBits:e.gzip&&e.windowBits>0&&e.windowBits<16&&(e.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new h,this.strm.avail_out=0;var a=r.deflateInit2(this.strm,e.level,e.method,e.windowBits,e.memLevel,e.strategy);if(a!==f)throw new Error(l[a]);if(e.header&&r.deflateSetHeader(this.strm,e.header),e.dictionary){var n;if(n="string"==typeof e.dictionary?o.string2buf(e.dictionary):"[object ArrayBuffer]"===d.call(e.dictionary)?new Uint8Array(e.dictionary):e.dictionary,(a=r.deflateSetDictionary(this.strm,n))!==f)throw new Error(l[a]);this._dict_set=!0}}function n(t,e){var a=new i(e);if(a.push(t,!0),a.err)throw a.msg||l[a.err];return a.result}var r=t("./zlib/deflate"),s=t("./utils/common"),o=t("./utils/strings"),l=t("./zlib/messages"),h=t("./zlib/zstream"),d=Object.prototype.toString,f=0,_=-1,u=0,c=8;i.prototype.push=function(t,e){var a,i,n=this.strm,l=this.options.chunkSize;if(this.ended)return!1;i=e===~~e?e:!0===e?4:0,"string"==typeof t?n.input=o.string2buf(t):"[object ArrayBuffer]"===d.call(t)?n.input=new Uint8Array(t):n.input=t,n.next_in=0,n.avail_in=n.input.length;do{if(0===n.avail_out&&(n.output=new s.Buf8(l),n.next_out=0,n.avail_out=l),1!==(a=r.deflate(n,i))&&a!==f)return this.onEnd(a),this.ended=!0,!1;0!==n.avail_out&&(0!==n.avail_in||4!==i&&2!==i)||("string"===this.options.to?this.onData(o.buf2binstring(s.shrinkBuf(n.output,n.next_out))):this.onData(s.shrinkBuf(n.output,n.next_out)))}while((n.avail_in>0||0===n.avail_out)&&1!==a);return 4===i?(a=r.deflateEnd(this.strm),this.onEnd(a),this.ended=!0,a===f):2!==i||(this.onEnd(f),n.avail_out=0,!0)},i.prototype.onData=function(t){this.chunks.push(t)},i.prototype.onEnd=function(t){t===f&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=s.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},a.Deflate=i,a.deflate=n,a.deflateRaw=function(t,e){return e=e||{},e.raw=!0,n(t,e)},a.gzip=function(t,e){return e=e||{},e.gzip=!0,n(t,e)}},{"./utils/common":3,"./utils/strings":4,"./zlib/deflate":8,"./zlib/messages":13,"./zlib/zstream":15}],2:[function(t,e,a){"use strict";function i(t){if(!(this instanceof i))return new i(t);this.options=s.assign({chunkSize:16384,windowBits:0,to:""},t||{});var e=this.options;e.raw&&e.windowBits>=0&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(e.windowBits>=0&&e.windowBits<16)||t&&t.windowBits||(e.windowBits+=32),e.windowBits>15&&e.windowBits<48&&0==(15&e.windowBits)&&(e.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new d,this.strm.avail_out=0;var a=r.inflateInit2(this.strm,e.windowBits);if(a!==l.Z_OK)throw new Error(h[a]);this.header=new f,r.inflateGetHeader(this.strm,this.header)}function n(t,e){var a=new i(e);if(a.push(t,!0),a.err)throw a.msg||h[a.err];return a.result}var r=t("./zlib/inflate"),s=t("./utils/common"),o=t("./utils/strings"),l=t("./zlib/constants"),h=t("./zlib/messages"),d=t("./zlib/zstream"),f=t("./zlib/gzheader"),_=Object.prototype.toString;i.prototype.push=function(t,e){var a,i,n,h,d,f,u=this.strm,c=this.options.chunkSize,b=this.options.dictionary,g=!1;if(this.ended)return!1;i=e===~~e?e:!0===e?l.Z_FINISH:l.Z_NO_FLUSH,"string"==typeof t?u.input=o.binstring2buf(t):"[object ArrayBuffer]"===_.call(t)?u.input=new Uint8Array(t):u.input=t,u.next_in=0,u.avail_in=u.input.length;do{if(0===u.avail_out&&(u.output=new s.Buf8(c),u.next_out=0,u.avail_out=c),(a=r.inflate(u,l.Z_NO_FLUSH))===l.Z_NEED_DICT&&b&&(f="string"==typeof b?o.string2buf(b):"[object ArrayBuffer]"===_.call(b)?new Uint8Array(b):b,a=r.inflateSetDictionary(this.strm,f)),a===l.Z_BUF_ERROR&&!0===g&&(a=l.Z_OK,g=!1),a!==l.Z_STREAM_END&&a!==l.Z_OK)return this.onEnd(a),this.ended=!0,!1;u.next_out&&(0!==u.avail_out&&a!==l.Z_STREAM_END&&(0!==u.avail_in||i!==l.Z_FINISH&&i!==l.Z_SYNC_FLUSH)||("string"===this.options.to?(n=o.utf8border(u.output,u.next_out),h=u.next_out-n,d=o.buf2string(u.output,n),u.next_out=h,u.avail_out=c-h,h&&s.arraySet(u.output,u.output,n,h,0),this.onData(d)):this.onData(s.shrinkBuf(u.output,u.next_out)))),0===u.avail_in&&0===u.avail_out&&(g=!0)}while((u.avail_in>0||0===u.avail_out)&&a!==l.Z_STREAM_END);return a===l.Z_STREAM_END&&(i=l.Z_FINISH),i===l.Z_FINISH?(a=r.inflateEnd(this.strm),this.onEnd(a),this.ended=!0,a===l.Z_OK):i!==l.Z_SYNC_FLUSH||(this.onEnd(l.Z_OK),u.avail_out=0,!0)},i.prototype.onData=function(t){this.chunks.push(t)},i.prototype.onEnd=function(t){t===l.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=s.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},a.Inflate=i,a.inflate=n,a.inflateRaw=function(t,e){return e=e||{},e.raw=!0,n(t,e)},a.ungzip=n},{"./utils/common":3,"./utils/strings":4,"./zlib/constants":6,"./zlib/gzheader":9,"./zlib/inflate":11,"./zlib/messages":13,"./zlib/zstream":15}],3:[function(t,e,a){"use strict";function i(t,e){return Object.prototype.hasOwnProperty.call(t,e)}var n="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;a.assign=function(t){for(var e=Array.prototype.slice.call(arguments,1);e.length;){var a=e.shift();if(a){if("object"!=typeof a)throw new TypeError(a+"must be non-object");for(var n in a)i(a,n)&&(t[n]=a[n])}}return t},a.shrinkBuf=function(t,e){return t.length===e?t:t.subarray?t.subarray(0,e):(t.length=e,t)};var r={arraySet:function(t,e,a,i,n){if(e.subarray&&t.subarray)t.set(e.subarray(a,a+i),n);else for(var r=0;r<i;r++)t[n+r]=e[a+r]},flattenChunks:function(t){var e,a,i,n,r,s;for(i=0,e=0,a=t.length;e<a;e++)i+=t[e].length;for(s=new Uint8Array(i),n=0,e=0,a=t.length;e<a;e++)r=t[e],s.set(r,n),n+=r.length;return s}},s={arraySet:function(t,e,a,i,n){for(var r=0;r<i;r++)t[n+r]=e[a+r]},flattenChunks:function(t){return[].concat.apply([],t)}};a.setTyped=function(t){t?(a.Buf8=Uint8Array,a.Buf16=Uint16Array,a.Buf32=Int32Array,a.assign(a,r)):(a.Buf8=Array,a.Buf16=Array,a.Buf32=Array,a.assign(a,s))},a.setTyped(n)},{}],4:[function(t,e,a){"use strict";function i(t,e){if(e<65537&&(t.subarray&&s||!t.subarray&&r))return String.fromCharCode.apply(null,n.shrinkBuf(t,e));for(var a="",i=0;i<e;i++)a+=String.fromCharCode(t[i]);return a}var n=t("./common"),r=!0,s=!0;try{String.fromCharCode.apply(null,[0])}catch(t){r=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(t){s=!1}for(var o=new n.Buf8(256),l=0;l<256;l++)o[l]=l>=252?6:l>=248?5:l>=240?4:l>=224?3:l>=192?2:1;o[254]=o[254]=1,a.string2buf=function(t){var e,a,i,r,s,o=t.length,l=0;for(r=0;r<o;r++)55296==(64512&(a=t.charCodeAt(r)))&&r+1<o&&56320==(64512&(i=t.charCodeAt(r+1)))&&(a=65536+(a-55296<<10)+(i-56320),r++),l+=a<128?1:a<2048?2:a<65536?3:4;for(e=new n.Buf8(l),s=0,r=0;s<l;r++)55296==(64512&(a=t.charCodeAt(r)))&&r+1<o&&56320==(64512&(i=t.charCodeAt(r+1)))&&(a=65536+(a-55296<<10)+(i-56320),r++),a<128?e[s++]=a:a<2048?(e[s++]=192|a>>>6,e[s++]=128|63&a):a<65536?(e[s++]=224|a>>>12,e[s++]=128|a>>>6&63,e[s++]=128|63&a):(e[s++]=240|a>>>18,e[s++]=128|a>>>12&63,e[s++]=128|a>>>6&63,e[s++]=128|63&a);return e},a.buf2binstring=function(t){return i(t,t.length)},a.binstring2buf=function(t){for(var e=new n.Buf8(t.length),a=0,i=e.length;a<i;a++)e[a]=t.charCodeAt(a);return e},a.buf2string=function(t,e){var a,n,r,s,l=e||t.length,h=new Array(2*l);for(n=0,a=0;a<l;)if((r=t[a++])<128)h[n++]=r;else if((s=o[r])>4)h[n++]=65533,a+=s-1;else{for(r&=2===s?31:3===s?15:7;s>1&&a<l;)r=r<<6|63&t[a++],s--;s>1?h[n++]=65533:r<65536?h[n++]=r:(r-=65536,h[n++]=55296|r>>10&1023,h[n++]=56320|1023&r)}return i(h,n)},a.utf8border=function(t,e){var a;for((e=e||t.length)>t.length&&(e=t.length),a=e-1;a>=0&&128==(192&t[a]);)a--;return a<0?e:0===a?e:a+o[t[a]]>e?a:e}},{"./common":3}],5:[function(t,e,a){"use strict";e.exports=function(t,e,a,i){for(var n=65535&t|0,r=t>>>16&65535|0,s=0;0!==a;){a-=s=a>2e3?2e3:a;do{r=r+(n=n+e[i++]|0)|0}while(--s);n%=65521,r%=65521}return n|r<<16|0}},{}],6:[function(t,e,a){"use strict";e.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],7:[function(t,e,a){"use strict";var i=function(){for(var t,e=[],a=0;a<256;a++){t=a;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[a]=t}return e}();e.exports=function(t,e,a,n){var r=i,s=n+a;t^=-1;for(var o=n;o<s;o++)t=t>>>8^r[255&(t^e[o])];return-1^t}},{}],8:[function(t,e,a){"use strict";function i(t,e){return t.msg=A[e],e}function n(t){return(t<<1)-(t>4?9:0)}function r(t){for(var e=t.length;--e>=0;)t[e]=0}function s(t){var e=t.state,a=e.pending;a>t.avail_out&&(a=t.avail_out),0!==a&&(z.arraySet(t.output,e.pending_buf,e.pending_out,a,t.next_out),t.next_out+=a,e.pending_out+=a,t.total_out+=a,t.avail_out-=a,e.pending-=a,0===e.pending&&(e.pending_out=0))}function o(t,e){B._tr_flush_block(t,t.block_start>=0?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,s(t.strm)}function l(t,e){t.pending_buf[t.pending++]=e}function h(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e}function d(t,e,a,i){var n=t.avail_in;return n>i&&(n=i),0===n?0:(t.avail_in-=n,z.arraySet(e,t.input,t.next_in,n,a),1===t.state.wrap?t.adler=S(t.adler,e,n,a):2===t.state.wrap&&(t.adler=E(t.adler,e,n,a)),t.next_in+=n,t.total_in+=n,n)}function f(t,e){var a,i,n=t.max_chain_length,r=t.strstart,s=t.prev_length,o=t.nice_match,l=t.strstart>t.w_size-it?t.strstart-(t.w_size-it):0,h=t.window,d=t.w_mask,f=t.prev,_=t.strstart+at,u=h[r+s-1],c=h[r+s];t.prev_length>=t.good_match&&(n>>=2),o>t.lookahead&&(o=t.lookahead);do{if(a=e,h[a+s]===c&&h[a+s-1]===u&&h[a]===h[r]&&h[++a]===h[r+1]){r+=2,a++;do{}while(h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&r<_);if(i=at-(_-r),r=_-at,i>s){if(t.match_start=e,s=i,i>=o)break;u=h[r+s-1],c=h[r+s]}}}while((e=f[e&d])>l&&0!=--n);return s<=t.lookahead?s:t.lookahead}function _(t){var e,a,i,n,r,s=t.w_size;do{if(n=t.window_size-t.lookahead-t.strstart,t.strstart>=s+(s-it)){z.arraySet(t.window,t.window,s,s,0),t.match_start-=s,t.strstart-=s,t.block_start-=s,e=a=t.hash_size;do{i=t.head[--e],t.head[e]=i>=s?i-s:0}while(--a);e=a=s;do{i=t.prev[--e],t.prev[e]=i>=s?i-s:0}while(--a);n+=s}if(0===t.strm.avail_in)break;if(a=d(t.strm,t.window,t.strstart+t.lookahead,n),t.lookahead+=a,t.lookahead+t.insert>=et)for(r=t.strstart-t.insert,t.ins_h=t.window[r],t.ins_h=(t.ins_h<<t.hash_shift^t.window[r+1])&t.hash_mask;t.insert&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[r+et-1])&t.hash_mask,t.prev[r&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=r,r++,t.insert--,!(t.lookahead+t.insert<et)););}while(t.lookahead<it&&0!==t.strm.avail_in)}function u(t,e){for(var a,i;;){if(t.lookahead<it){if(_(t),t.lookahead<it&&e===Z)return _t;if(0===t.lookahead)break}if(a=0,t.lookahead>=et&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+et-1])&t.hash_mask,a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==a&&t.strstart-a<=t.w_size-it&&(t.match_length=f(t,a)),t.match_length>=et)if(i=B._tr_tally(t,t.strstart-t.match_start,t.match_length-et),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=et){t.match_length--;do{t.strstart++,t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+et-1])&t.hash_mask,a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart}while(0!=--t.match_length);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+1])&t.hash_mask;else i=B._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(i&&(o(t,!1),0===t.strm.avail_out))return _t}return t.insert=t.strstart<et-1?t.strstart:et-1,e===N?(o(t,!0),0===t.strm.avail_out?ct:bt):t.last_lit&&(o(t,!1),0===t.strm.avail_out)?_t:ut}function c(t,e){for(var a,i,n;;){if(t.lookahead<it){if(_(t),t.lookahead<it&&e===Z)return _t;if(0===t.lookahead)break}if(a=0,t.lookahead>=et&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+et-1])&t.hash_mask,a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=et-1,0!==a&&t.prev_length<t.max_lazy_match&&t.strstart-a<=t.w_size-it&&(t.match_length=f(t,a),t.match_length<=5&&(t.strategy===H||t.match_length===et&&t.strstart-t.match_start>4096)&&(t.match_length=et-1)),t.prev_length>=et&&t.match_length<=t.prev_length){n=t.strstart+t.lookahead-et,i=B._tr_tally(t,t.strstart-1-t.prev_match,t.prev_length-et),t.lookahead-=t.prev_length-1,t.prev_length-=2;do{++t.strstart<=n&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+et-1])&t.hash_mask,a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart)}while(0!=--t.prev_length);if(t.match_available=0,t.match_length=et-1,t.strstart++,i&&(o(t,!1),0===t.strm.avail_out))return _t}else if(t.match_available){if((i=B._tr_tally(t,0,t.window[t.strstart-1]))&&o(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return _t}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(i=B._tr_tally(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<et-1?t.strstart:et-1,e===N?(o(t,!0),0===t.strm.avail_out?ct:bt):t.last_lit&&(o(t,!1),0===t.strm.avail_out)?_t:ut}function b(t,e){for(var a,i,n,r,s=t.window;;){if(t.lookahead<=at){if(_(t),t.lookahead<=at&&e===Z)return _t;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=et&&t.strstart>0&&(n=t.strstart-1,(i=s[n])===s[++n]&&i===s[++n]&&i===s[++n])){r=t.strstart+at;do{}while(i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&n<r);t.match_length=at-(r-n),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=et?(a=B._tr_tally(t,1,t.match_length-et),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(a=B._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),a&&(o(t,!1),0===t.strm.avail_out))return _t}return t.insert=0,e===N?(o(t,!0),0===t.strm.avail_out?ct:bt):t.last_lit&&(o(t,!1),0===t.strm.avail_out)?_t:ut}function g(t,e){for(var a;;){if(0===t.lookahead&&(_(t),0===t.lookahead)){if(e===Z)return _t;break}if(t.match_length=0,a=B._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,a&&(o(t,!1),0===t.strm.avail_out))return _t}return t.insert=0,e===N?(o(t,!0),0===t.strm.avail_out?ct:bt):t.last_lit&&(o(t,!1),0===t.strm.avail_out)?_t:ut}function m(t,e,a,i,n){this.good_length=t,this.max_lazy=e,this.nice_length=a,this.max_chain=i,this.func=n}function w(t){t.window_size=2*t.w_size,r(t.head),t.max_lazy_match=x[t.level].max_lazy,t.good_match=x[t.level].good_length,t.nice_match=x[t.level].nice_length,t.max_chain_length=x[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=et-1,t.match_available=0,t.ins_h=0}function p(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=q,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new z.Buf16(2*$),this.dyn_dtree=new z.Buf16(2*(2*Q+1)),this.bl_tree=new z.Buf16(2*(2*V+1)),r(this.dyn_ltree),r(this.dyn_dtree),r(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new z.Buf16(tt+1),this.heap=new z.Buf16(2*J+1),r(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new z.Buf16(2*J+1),r(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function v(t){var e;return t&&t.state?(t.total_in=t.total_out=0,t.data_type=Y,e=t.state,e.pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?rt:dt,t.adler=2===e.wrap?0:1,e.last_flush=Z,B._tr_init(e),D):i(t,U)}function k(t){var e=v(t);return e===D&&w(t.state),e}function y(t,e,a,n,r,s){if(!t)return U;var o=1;if(e===L&&(e=6),n<0?(o=0,n=-n):n>15&&(o=2,n-=16),r<1||r>G||a!==q||n<8||n>15||e<0||e>9||s<0||s>M)return i(t,U);8===n&&(n=9);var l=new p;return t.state=l,l.strm=t,l.wrap=o,l.gzhead=null,l.w_bits=n,l.w_size=1<<l.w_bits,l.w_mask=l.w_size-1,l.hash_bits=r+7,l.hash_size=1<<l.hash_bits,l.hash_mask=l.hash_size-1,l.hash_shift=~~((l.hash_bits+et-1)/et),l.window=new z.Buf8(2*l.w_size),l.head=new z.Buf16(l.hash_size),l.prev=new z.Buf16(l.w_size),l.lit_bufsize=1<<r+6,l.pending_buf_size=4*l.lit_bufsize,l.pending_buf=new z.Buf8(l.pending_buf_size),l.d_buf=1*l.lit_bufsize,l.l_buf=3*l.lit_bufsize,l.level=e,l.strategy=s,l.method=a,k(t)}var x,z=t("../utils/common"),B=t("./trees"),S=t("./adler32"),E=t("./crc32"),A=t("./messages"),Z=0,R=1,C=3,N=4,O=5,D=0,I=1,U=-2,T=-3,F=-5,L=-1,H=1,j=2,K=3,M=4,P=0,Y=2,q=8,G=9,X=15,W=8,J=286,Q=30,V=19,$=2*J+1,tt=15,et=3,at=258,it=at+et+1,nt=32,rt=42,st=69,ot=73,lt=91,ht=103,dt=113,ft=666,_t=1,ut=2,ct=3,bt=4,gt=3;x=[new m(0,0,0,0,function(t,e){var a=65535;for(a>t.pending_buf_size-5&&(a=t.pending_buf_size-5);;){if(t.lookahead<=1){if(_(t),0===t.lookahead&&e===Z)return _t;if(0===t.lookahead)break}t.strstart+=t.lookahead,t.lookahead=0;var i=t.block_start+a;if((0===t.strstart||t.strstart>=i)&&(t.lookahead=t.strstart-i,t.strstart=i,o(t,!1),0===t.strm.avail_out))return _t;if(t.strstart-t.block_start>=t.w_size-it&&(o(t,!1),0===t.strm.avail_out))return _t}return t.insert=0,e===N?(o(t,!0),0===t.strm.avail_out?ct:bt):(t.strstart>t.block_start&&(o(t,!1),t.strm.avail_out),_t)}),new m(4,4,8,4,u),new m(4,5,16,8,u),new m(4,6,32,32,u),new m(4,4,16,16,c),new m(8,16,32,32,c),new m(8,16,128,128,c),new m(8,32,128,256,c),new m(32,128,258,1024,c),new m(32,258,258,4096,c)],a.deflateInit=function(t,e){return y(t,e,q,X,W,P)},a.deflateInit2=y,a.deflateReset=k,a.deflateResetKeep=v,a.deflateSetHeader=function(t,e){return t&&t.state?2!==t.state.wrap?U:(t.state.gzhead=e,D):U},a.deflate=function(t,e){var a,o,d,f;if(!t||!t.state||e>O||e<0)return t?i(t,U):U;if(o=t.state,!t.output||!t.input&&0!==t.avail_in||o.status===ft&&e!==N)return i(t,0===t.avail_out?F:U);if(o.strm=t,a=o.last_flush,o.last_flush=e,o.status===rt)if(2===o.wrap)t.adler=0,l(o,31),l(o,139),l(o,8),o.gzhead?(l(o,(o.gzhead.text?1:0)+(o.gzhead.hcrc?2:0)+(o.gzhead.extra?4:0)+(o.gzhead.name?8:0)+(o.gzhead.comment?16:0)),l(o,255&o.gzhead.time),l(o,o.gzhead.time>>8&255),l(o,o.gzhead.time>>16&255),l(o,o.gzhead.time>>24&255),l(o,9===o.level?2:o.strategy>=j||o.level<2?4:0),l(o,255&o.gzhead.os),o.gzhead.extra&&o.gzhead.extra.length&&(l(o,255&o.gzhead.extra.length),l(o,o.gzhead.extra.length>>8&255)),o.gzhead.hcrc&&(t.adler=E(t.adler,o.pending_buf,o.pending,0)),o.gzindex=0,o.status=st):(l(o,0),l(o,0),l(o,0),l(o,0),l(o,0),l(o,9===o.level?2:o.strategy>=j||o.level<2?4:0),l(o,gt),o.status=dt);else{var _=q+(o.w_bits-8<<4)<<8;_|=(o.strategy>=j||o.level<2?0:o.level<6?1:6===o.level?2:3)<<6,0!==o.strstart&&(_|=nt),_+=31-_%31,o.status=dt,h(o,_),0!==o.strstart&&(h(o,t.adler>>>16),h(o,65535&t.adler)),t.adler=1}if(o.status===st)if(o.gzhead.extra){for(d=o.pending;o.gzindex<(65535&o.gzhead.extra.length)&&(o.pending!==o.pending_buf_size||(o.gzhead.hcrc&&o.pending>d&&(t.adler=E(t.adler,o.pending_buf,o.pending-d,d)),s(t),d=o.pending,o.pending!==o.pending_buf_size));)l(o,255&o.gzhead.extra[o.gzindex]),o.gzindex++;o.gzhead.hcrc&&o.pending>d&&(t.adler=E(t.adler,o.pending_buf,o.pending-d,d)),o.gzindex===o.gzhead.extra.length&&(o.gzindex=0,o.status=ot)}else o.status=ot;if(o.status===ot)if(o.gzhead.name){d=o.pending;do{if(o.pending===o.pending_buf_size&&(o.gzhead.hcrc&&o.pending>d&&(t.adler=E(t.adler,o.pending_buf,o.pending-d,d)),s(t),d=o.pending,o.pending===o.pending_buf_size)){f=1;break}f=o.gzindex<o.gzhead.name.length?255&o.gzhead.name.charCodeAt(o.gzindex++):0,l(o,f)}while(0!==f);o.gzhead.hcrc&&o.pending>d&&(t.adler=E(t.adler,o.pending_buf,o.pending-d,d)),0===f&&(o.gzindex=0,o.status=lt)}else o.status=lt;if(o.status===lt)if(o.gzhead.comment){d=o.pending;do{if(o.pending===o.pending_buf_size&&(o.gzhead.hcrc&&o.pending>d&&(t.adler=E(t.adler,o.pending_buf,o.pending-d,d)),s(t),d=o.pending,o.pending===o.pending_buf_size)){f=1;break}f=o.gzindex<o.gzhead.comment.length?255&o.gzhead.comment.charCodeAt(o.gzindex++):0,l(o,f)}while(0!==f);o.gzhead.hcrc&&o.pending>d&&(t.adler=E(t.adler,o.pending_buf,o.pending-d,d)),0===f&&(o.status=ht)}else o.status=ht;if(o.status===ht&&(o.gzhead.hcrc?(o.pending+2>o.pending_buf_size&&s(t),o.pending+2<=o.pending_buf_size&&(l(o,255&t.adler),l(o,t.adler>>8&255),t.adler=0,o.status=dt)):o.status=dt),0!==o.pending){if(s(t),0===t.avail_out)return o.last_flush=-1,D}else if(0===t.avail_in&&n(e)<=n(a)&&e!==N)return i(t,F);if(o.status===ft&&0!==t.avail_in)return i(t,F);if(0!==t.avail_in||0!==o.lookahead||e!==Z&&o.status!==ft){var u=o.strategy===j?g(o,e):o.strategy===K?b(o,e):x[o.level].func(o,e);if(u!==ct&&u!==bt||(o.status=ft),u===_t||u===ct)return 0===t.avail_out&&(o.last_flush=-1),D;if(u===ut&&(e===R?B._tr_align(o):e!==O&&(B._tr_stored_block(o,0,0,!1),e===C&&(r(o.head),0===o.lookahead&&(o.strstart=0,o.block_start=0,o.insert=0))),s(t),0===t.avail_out))return o.last_flush=-1,D}return e!==N?D:o.wrap<=0?I:(2===o.wrap?(l(o,255&t.adler),l(o,t.adler>>8&255),l(o,t.adler>>16&255),l(o,t.adler>>24&255),l(o,255&t.total_in),l(o,t.total_in>>8&255),l(o,t.total_in>>16&255),l(o,t.total_in>>24&255)):(h(o,t.adler>>>16),h(o,65535&t.adler)),s(t),o.wrap>0&&(o.wrap=-o.wrap),0!==o.pending?D:I)},a.deflateEnd=function(t){var e;return t&&t.state?(e=t.state.status)!==rt&&e!==st&&e!==ot&&e!==lt&&e!==ht&&e!==dt&&e!==ft?i(t,U):(t.state=null,e===dt?i(t,T):D):U},a.deflateSetDictionary=function(t,e){var a,i,n,s,o,l,h,d,f=e.length;if(!t||!t.state)return U;if(a=t.state,2===(s=a.wrap)||1===s&&a.status!==rt||a.lookahead)return U;for(1===s&&(t.adler=S(t.adler,e,f,0)),a.wrap=0,f>=a.w_size&&(0===s&&(r(a.head),a.strstart=0,a.block_start=0,a.insert=0),d=new z.Buf8(a.w_size),z.arraySet(d,e,f-a.w_size,a.w_size,0),e=d,f=a.w_size),o=t.avail_in,l=t.next_in,h=t.input,t.avail_in=f,t.next_in=0,t.input=e,_(a);a.lookahead>=et;){i=a.strstart,n=a.lookahead-(et-1);do{a.ins_h=(a.ins_h<<a.hash_shift^a.window[i+et-1])&a.hash_mask,a.prev[i&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=i,i++}while(--n);a.strstart=i,a.lookahead=et-1,_(a)}return a.strstart+=a.lookahead,a.block_start=a.strstart,a.insert=a.lookahead,a.lookahead=0,a.match_length=a.prev_length=et-1,a.match_available=0,t.next_in=l,t.input=h,t.avail_in=o,a.wrap=s,D},a.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":3,"./adler32":5,"./crc32":7,"./messages":13,"./trees":14}],9:[function(t,e,a){"use strict";e.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}},{}],10:[function(t,e,a){"use strict";e.exports=function(t,e){var a,i,n,r,s,o,l,h,d,f,_,u,c,b,g,m,w,p,v,k,y,x,z,B,S;a=t.state,i=t.next_in,B=t.input,n=i+(t.avail_in-5),r=t.next_out,S=t.output,s=r-(e-t.avail_out),o=r+(t.avail_out-257),l=a.dmax,h=a.wsize,d=a.whave,f=a.wnext,_=a.window,u=a.hold,c=a.bits,b=a.lencode,g=a.distcode,m=(1<<a.lenbits)-1,w=(1<<a.distbits)-1;t:do{c<15&&(u+=B[i++]<<c,c+=8,u+=B[i++]<<c,c+=8),p=b[u&m];e:for(;;){if(v=p>>>24,u>>>=v,c-=v,0===(v=p>>>16&255))S[r++]=65535&p;else{if(!(16&v)){if(0==(64&v)){p=b[(65535&p)+(u&(1<<v)-1)];continue e}if(32&v){a.mode=12;break t}t.msg="invalid literal/length code",a.mode=30;break t}k=65535&p,(v&=15)&&(c<v&&(u+=B[i++]<<c,c+=8),k+=u&(1<<v)-1,u>>>=v,c-=v),c<15&&(u+=B[i++]<<c,c+=8,u+=B[i++]<<c,c+=8),p=g[u&w];a:for(;;){if(v=p>>>24,u>>>=v,c-=v,!(16&(v=p>>>16&255))){if(0==(64&v)){p=g[(65535&p)+(u&(1<<v)-1)];continue a}t.msg="invalid distance code",a.mode=30;break t}if(y=65535&p,v&=15,c<v&&(u+=B[i++]<<c,(c+=8)<v&&(u+=B[i++]<<c,c+=8)),(y+=u&(1<<v)-1)>l){t.msg="invalid distance too far back",a.mode=30;break t}if(u>>>=v,c-=v,v=r-s,y>v){if((v=y-v)>d&&a.sane){t.msg="invalid distance too far back",a.mode=30;break t}if(x=0,z=_,0===f){if(x+=h-v,v<k){k-=v;do{S[r++]=_[x++]}while(--v);x=r-y,z=S}}else if(f<v){if(x+=h+f-v,(v-=f)<k){k-=v;do{S[r++]=_[x++]}while(--v);if(x=0,f<k){k-=v=f;do{S[r++]=_[x++]}while(--v);x=r-y,z=S}}}else if(x+=f-v,v<k){k-=v;do{S[r++]=_[x++]}while(--v);x=r-y,z=S}for(;k>2;)S[r++]=z[x++],S[r++]=z[x++],S[r++]=z[x++],k-=3;k&&(S[r++]=z[x++],k>1&&(S[r++]=z[x++]))}else{x=r-y;do{S[r++]=S[x++],S[r++]=S[x++],S[r++]=S[x++],k-=3}while(k>2);k&&(S[r++]=S[x++],k>1&&(S[r++]=S[x++]))}break}}break}}while(i<n&&r<o);i-=k=c>>3,u&=(1<<(c-=k<<3))-1,t.next_in=i,t.next_out=r,t.avail_in=i<n?n-i+5:5-(i-n),t.avail_out=r<o?o-r+257:257-(r-o),a.hold=u,a.bits=c}},{}],11:[function(t,e,a){"use strict";function i(t){return(t>>>24&255)+(t>>>8&65280)+((65280&t)<<8)+((255&t)<<24)}function n(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new u.Buf16(320),this.work=new u.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function r(t){var e;return t&&t.state?(e=t.state,t.total_in=t.total_out=e.total=0,t.msg="",e.wrap&&(t.adler=1&e.wrap),e.mode=N,e.last=0,e.havedict=0,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new u.Buf32(dt),e.distcode=e.distdyn=new u.Buf32(ft),e.sane=1,e.back=-1,z):E}function s(t){var e;return t&&t.state?(e=t.state,e.wsize=0,e.whave=0,e.wnext=0,r(t)):E}function o(t,e){var a,i;return t&&t.state?(i=t.state,e<0?(a=0,e=-e):(a=1+(e>>4),e<48&&(e&=15)),e&&(e<8||e>15)?E:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=a,i.wbits=e,s(t))):E}function l(t,e){var a,i;return t?(i=new n,t.state=i,i.window=null,(a=o(t,e))!==z&&(t.state=null),a):E}function h(t){if(ut){var e;for(f=new u.Buf32(512),_=new u.Buf32(32),e=0;e<144;)t.lens[e++]=8;for(;e<256;)t.lens[e++]=9;for(;e<280;)t.lens[e++]=7;for(;e<288;)t.lens[e++]=8;for(m(p,t.lens,0,288,f,0,t.work,{bits:9}),e=0;e<32;)t.lens[e++]=5;m(v,t.lens,0,32,_,0,t.work,{bits:5}),ut=!1}t.lencode=f,t.lenbits=9,t.distcode=_,t.distbits=5}function d(t,e,a,i){var n,r=t.state;return null===r.window&&(r.wsize=1<<r.wbits,r.wnext=0,r.whave=0,r.window=new u.Buf8(r.wsize)),i>=r.wsize?(u.arraySet(r.window,e,a-r.wsize,r.wsize,0),r.wnext=0,r.whave=r.wsize):((n=r.wsize-r.wnext)>i&&(n=i),u.arraySet(r.window,e,a-i,n,r.wnext),(i-=n)?(u.arraySet(r.window,e,a-i,i,0),r.wnext=i,r.whave=r.wsize):(r.wnext+=n,r.wnext===r.wsize&&(r.wnext=0),r.whave<r.wsize&&(r.whave+=n))),0}var f,_,u=t("../utils/common"),c=t("./adler32"),b=t("./crc32"),g=t("./inffast"),m=t("./inftrees"),w=0,p=1,v=2,k=4,y=5,x=6,z=0,B=1,S=2,E=-2,A=-3,Z=-4,R=-5,C=8,N=1,O=2,D=3,I=4,U=5,T=6,F=7,L=8,H=9,j=10,K=11,M=12,P=13,Y=14,q=15,G=16,X=17,W=18,J=19,Q=20,V=21,$=22,tt=23,et=24,at=25,it=26,nt=27,rt=28,st=29,ot=30,lt=31,ht=32,dt=852,ft=592,_t=15,ut=!0;a.inflateReset=s,a.inflateReset2=o,a.inflateResetKeep=r,a.inflateInit=function(t){return l(t,_t)},a.inflateInit2=l,a.inflate=function(t,e){var a,n,r,s,o,l,f,_,dt,ft,_t,ut,ct,bt,gt,mt,wt,pt,vt,kt,yt,xt,zt,Bt,St=0,Et=new u.Buf8(4),At=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!t||!t.state||!t.output||!t.input&&0!==t.avail_in)return E;(a=t.state).mode===M&&(a.mode=P),o=t.next_out,r=t.output,f=t.avail_out,s=t.next_in,n=t.input,l=t.avail_in,_=a.hold,dt=a.bits,ft=l,_t=f,xt=z;t:for(;;)switch(a.mode){case N:if(0===a.wrap){a.mode=P;break}for(;dt<16;){if(0===l)break t;l--,_+=n[s++]<<dt,dt+=8}if(2&a.wrap&&35615===_){a.check=0,Et[0]=255&_,Et[1]=_>>>8&255,a.check=b(a.check,Et,2,0),_=0,dt=0,a.mode=O;break}if(a.flags=0,a.head&&(a.head.done=!1),!(1&a.wrap)||(((255&_)<<8)+(_>>8))%31){t.msg="incorrect header check",a.mode=ot;break}if((15&_)!==C){t.msg="unknown compression method",a.mode=ot;break}if(_>>>=4,dt-=4,yt=8+(15&_),0===a.wbits)a.wbits=yt;else if(yt>a.wbits){t.msg="invalid window size",a.mode=ot;break}a.dmax=1<<yt,t.adler=a.check=1,a.mode=512&_?j:M,_=0,dt=0;break;case O:for(;dt<16;){if(0===l)break t;l--,_+=n[s++]<<dt,dt+=8}if(a.flags=_,(255&a.flags)!==C){t.msg="unknown compression method",a.mode=ot;break}if(57344&a.flags){t.msg="unknown header flags set",a.mode=ot;break}a.head&&(a.head.text=_>>8&1),512&a.flags&&(Et[0]=255&_,Et[1]=_>>>8&255,a.check=b(a.check,Et,2,0)),_=0,dt=0,a.mode=D;case D:for(;dt<32;){if(0===l)break t;l--,_+=n[s++]<<dt,dt+=8}a.head&&(a.head.time=_),512&a.flags&&(Et[0]=255&_,Et[1]=_>>>8&255,Et[2]=_>>>16&255,Et[3]=_>>>24&255,a.check=b(a.check,Et,4,0)),_=0,dt=0,a.mode=I;case I:for(;dt<16;){if(0===l)break t;l--,_+=n[s++]<<dt,dt+=8}a.head&&(a.head.xflags=255&_,a.head.os=_>>8),512&a.flags&&(Et[0]=255&_,Et[1]=_>>>8&255,a.check=b(a.check,Et,2,0)),_=0,dt=0,a.mode=U;case U:if(1024&a.flags){for(;dt<16;){if(0===l)break t;l--,_+=n[s++]<<dt,dt+=8}a.length=_,a.head&&(a.head.extra_len=_),512&a.flags&&(Et[0]=255&_,Et[1]=_>>>8&255,a.check=b(a.check,Et,2,0)),_=0,dt=0}else a.head&&(a.head.extra=null);a.mode=T;case T:if(1024&a.flags&&((ut=a.length)>l&&(ut=l),ut&&(a.head&&(yt=a.head.extra_len-a.length,a.head.extra||(a.head.extra=new Array(a.head.extra_len)),u.arraySet(a.head.extra,n,s,ut,yt)),512&a.flags&&(a.check=b(a.check,n,ut,s)),l-=ut,s+=ut,a.length-=ut),a.length))break t;a.length=0,a.mode=F;case F:if(2048&a.flags){if(0===l)break t;ut=0;do{yt=n[s+ut++],a.head&&yt&&a.length<65536&&(a.head.name+=String.fromCharCode(yt))}while(yt&&ut<l);if(512&a.flags&&(a.check=b(a.check,n,ut,s)),l-=ut,s+=ut,yt)break t}else a.head&&(a.head.name=null);a.length=0,a.mode=L;case L:if(4096&a.flags){if(0===l)break t;ut=0;do{yt=n[s+ut++],a.head&&yt&&a.length<65536&&(a.head.comment+=String.fromCharCode(yt))}while(yt&&ut<l);if(512&a.flags&&(a.check=b(a.check,n,ut,s)),l-=ut,s+=ut,yt)break t}else a.head&&(a.head.comment=null);a.mode=H;case H:if(512&a.flags){for(;dt<16;){if(0===l)break t;l--,_+=n[s++]<<dt,dt+=8}if(_!==(65535&a.check)){t.msg="header crc mismatch",a.mode=ot;break}_=0,dt=0}a.head&&(a.head.hcrc=a.flags>>9&1,a.head.done=!0),t.adler=a.check=0,a.mode=M;break;case j:for(;dt<32;){if(0===l)break t;l--,_+=n[s++]<<dt,dt+=8}t.adler=a.check=i(_),_=0,dt=0,a.mode=K;case K:if(0===a.havedict)return t.next_out=o,t.avail_out=f,t.next_in=s,t.avail_in=l,a.hold=_,a.bits=dt,S;t.adler=a.check=1,a.mode=M;case M:if(e===y||e===x)break t;case P:if(a.last){_>>>=7&dt,dt-=7&dt,a.mode=nt;break}for(;dt<3;){if(0===l)break t;l--,_+=n[s++]<<dt,dt+=8}switch(a.last=1&_,_>>>=1,dt-=1,3&_){case 0:a.mode=Y;break;case 1:if(h(a),a.mode=Q,e===x){_>>>=2,dt-=2;break t}break;case 2:a.mode=X;break;case 3:t.msg="invalid block type",a.mode=ot}_>>>=2,dt-=2;break;case Y:for(_>>>=7&dt,dt-=7&dt;dt<32;){if(0===l)break t;l--,_+=n[s++]<<dt,dt+=8}if((65535&_)!=(_>>>16^65535)){t.msg="invalid stored block lengths",a.mode=ot;break}if(a.length=65535&_,_=0,dt=0,a.mode=q,e===x)break t;case q:a.mode=G;case G:if(ut=a.length){if(ut>l&&(ut=l),ut>f&&(ut=f),0===ut)break t;u.arraySet(r,n,s,ut,o),l-=ut,s+=ut,f-=ut,o+=ut,a.length-=ut;break}a.mode=M;break;case X:for(;dt<14;){if(0===l)break t;l--,_+=n[s++]<<dt,dt+=8}if(a.nlen=257+(31&_),_>>>=5,dt-=5,a.ndist=1+(31&_),_>>>=5,dt-=5,a.ncode=4+(15&_),_>>>=4,dt-=4,a.nlen>286||a.ndist>30){t.msg="too many length or distance symbols",a.mode=ot;break}a.have=0,a.mode=W;case W:for(;a.have<a.ncode;){for(;dt<3;){if(0===l)break t;l--,_+=n[s++]<<dt,dt+=8}a.lens[At[a.have++]]=7&_,_>>>=3,dt-=3}for(;a.have<19;)a.lens[At[a.have++]]=0;if(a.lencode=a.lendyn,a.lenbits=7,zt={bits:a.lenbits},xt=m(w,a.lens,0,19,a.lencode,0,a.work,zt),a.lenbits=zt.bits,xt){t.msg="invalid code lengths set",a.mode=ot;break}a.have=0,a.mode=J;case J:for(;a.have<a.nlen+a.ndist;){for(;St=a.lencode[_&(1<<a.lenbits)-1],gt=St>>>24,mt=St>>>16&255,wt=65535&St,!(gt<=dt);){if(0===l)break t;l--,_+=n[s++]<<dt,dt+=8}if(wt<16)_>>>=gt,dt-=gt,a.lens[a.have++]=wt;else{if(16===wt){for(Bt=gt+2;dt<Bt;){if(0===l)break t;l--,_+=n[s++]<<dt,dt+=8}if(_>>>=gt,dt-=gt,0===a.have){t.msg="invalid bit length repeat",a.mode=ot;break}yt=a.lens[a.have-1],ut=3+(3&_),_>>>=2,dt-=2}else if(17===wt){for(Bt=gt+3;dt<Bt;){if(0===l)break t;l--,_+=n[s++]<<dt,dt+=8}dt-=gt,yt=0,ut=3+(7&(_>>>=gt)),_>>>=3,dt-=3}else{for(Bt=gt+7;dt<Bt;){if(0===l)break t;l--,_+=n[s++]<<dt,dt+=8}dt-=gt,yt=0,ut=11+(127&(_>>>=gt)),_>>>=7,dt-=7}if(a.have+ut>a.nlen+a.ndist){t.msg="invalid bit length repeat",a.mode=ot;break}for(;ut--;)a.lens[a.have++]=yt}}if(a.mode===ot)break;if(0===a.lens[256]){t.msg="invalid code -- missing end-of-block",a.mode=ot;break}if(a.lenbits=9,zt={bits:a.lenbits},xt=m(p,a.lens,0,a.nlen,a.lencode,0,a.work,zt),a.lenbits=zt.bits,xt){t.msg="invalid literal/lengths set",a.mode=ot;break}if(a.distbits=6,a.distcode=a.distdyn,zt={bits:a.distbits},xt=m(v,a.lens,a.nlen,a.ndist,a.distcode,0,a.work,zt),a.distbits=zt.bits,xt){t.msg="invalid distances set",a.mode=ot;break}if(a.mode=Q,e===x)break t;case Q:a.mode=V;case V:if(l>=6&&f>=258){t.next_out=o,t.avail_out=f,t.next_in=s,t.avail_in=l,a.hold=_,a.bits=dt,g(t,_t),o=t.next_out,r=t.output,f=t.avail_out,s=t.next_in,n=t.input,l=t.avail_in,_=a.hold,dt=a.bits,a.mode===M&&(a.back=-1);break}for(a.back=0;St=a.lencode[_&(1<<a.lenbits)-1],gt=St>>>24,mt=St>>>16&255,wt=65535&St,!(gt<=dt);){if(0===l)break t;l--,_+=n[s++]<<dt,dt+=8}if(mt&&0==(240&mt)){for(pt=gt,vt=mt,kt=wt;St=a.lencode[kt+((_&(1<<pt+vt)-1)>>pt)],gt=St>>>24,mt=St>>>16&255,wt=65535&St,!(pt+gt<=dt);){if(0===l)break t;l--,_+=n[s++]<<dt,dt+=8}_>>>=pt,dt-=pt,a.back+=pt}if(_>>>=gt,dt-=gt,a.back+=gt,a.length=wt,0===mt){a.mode=it;break}if(32&mt){a.back=-1,a.mode=M;break}if(64&mt){t.msg="invalid literal/length code",a.mode=ot;break}a.extra=15&mt,a.mode=$;case $:if(a.extra){for(Bt=a.extra;dt<Bt;){if(0===l)break t;l--,_+=n[s++]<<dt,dt+=8}a.length+=_&(1<<a.extra)-1,_>>>=a.extra,dt-=a.extra,a.back+=a.extra}a.was=a.length,a.mode=tt;case tt:for(;St=a.distcode[_&(1<<a.distbits)-1],gt=St>>>24,mt=St>>>16&255,wt=65535&St,!(gt<=dt);){if(0===l)break t;l--,_+=n[s++]<<dt,dt+=8}if(0==(240&mt)){for(pt=gt,vt=mt,kt=wt;St=a.distcode[kt+((_&(1<<pt+vt)-1)>>pt)],gt=St>>>24,mt=St>>>16&255,wt=65535&St,!(pt+gt<=dt);){if(0===l)break t;l--,_+=n[s++]<<dt,dt+=8}_>>>=pt,dt-=pt,a.back+=pt}if(_>>>=gt,dt-=gt,a.back+=gt,64&mt){t.msg="invalid distance code",a.mode=ot;break}a.offset=wt,a.extra=15&mt,a.mode=et;case et:if(a.extra){for(Bt=a.extra;dt<Bt;){if(0===l)break t;l--,_+=n[s++]<<dt,dt+=8}a.offset+=_&(1<<a.extra)-1,_>>>=a.extra,dt-=a.extra,a.back+=a.extra}if(a.offset>a.dmax){t.msg="invalid distance too far back",a.mode=ot;break}a.mode=at;case at:if(0===f)break t;if(ut=_t-f,a.offset>ut){if((ut=a.offset-ut)>a.whave&&a.sane){t.msg="invalid distance too far back",a.mode=ot;break}ut>a.wnext?(ut-=a.wnext,ct=a.wsize-ut):ct=a.wnext-ut,ut>a.length&&(ut=a.length),bt=a.window}else bt=r,ct=o-a.offset,ut=a.length;ut>f&&(ut=f),f-=ut,a.length-=ut;do{r[o++]=bt[ct++]}while(--ut);0===a.length&&(a.mode=V);break;case it:if(0===f)break t;r[o++]=a.length,f--,a.mode=V;break;case nt:if(a.wrap){for(;dt<32;){if(0===l)break t;l--,_|=n[s++]<<dt,dt+=8}if(_t-=f,t.total_out+=_t,a.total+=_t,_t&&(t.adler=a.check=a.flags?b(a.check,r,_t,o-_t):c(a.check,r,_t,o-_t)),_t=f,(a.flags?_:i(_))!==a.check){t.msg="incorrect data check",a.mode=ot;break}_=0,dt=0}a.mode=rt;case rt:if(a.wrap&&a.flags){for(;dt<32;){if(0===l)break t;l--,_+=n[s++]<<dt,dt+=8}if(_!==(4294967295&a.total)){t.msg="incorrect length check",a.mode=ot;break}_=0,dt=0}a.mode=st;case st:xt=B;break t;case ot:xt=A;break t;case lt:return Z;case ht:default:return E}return t.next_out=o,t.avail_out=f,t.next_in=s,t.avail_in=l,a.hold=_,a.bits=dt,(a.wsize||_t!==t.avail_out&&a.mode<ot&&(a.mode<nt||e!==k))&&d(t,t.output,t.next_out,_t-t.avail_out)?(a.mode=lt,Z):(ft-=t.avail_in,_t-=t.avail_out,t.total_in+=ft,t.total_out+=_t,a.total+=_t,a.wrap&&_t&&(t.adler=a.check=a.flags?b(a.check,r,_t,t.next_out-_t):c(a.check,r,_t,t.next_out-_t)),t.data_type=a.bits+(a.last?64:0)+(a.mode===M?128:0)+(a.mode===Q||a.mode===q?256:0),(0===ft&&0===_t||e===k)&&xt===z&&(xt=R),xt)},a.inflateEnd=function(t){if(!t||!t.state)return E;var e=t.state;return e.window&&(e.window=null),t.state=null,z},a.inflateGetHeader=function(t,e){var a;return t&&t.state?0==(2&(a=t.state).wrap)?E:(a.head=e,e.done=!1,z):E},a.inflateSetDictionary=function(t,e){var a,i,n=e.length;return t&&t.state?0!==(a=t.state).wrap&&a.mode!==K?E:a.mode===K&&(i=1,(i=c(i,e,n,0))!==a.check)?A:d(t,e,n,n)?(a.mode=lt,Z):(a.havedict=1,z):E},a.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":3,"./adler32":5,"./crc32":7,"./inffast":10,"./inftrees":12}],12:[function(t,e,a){"use strict";var i=t("../utils/common"),n=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],r=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],s=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],o=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];e.exports=function(t,e,a,l,h,d,f,_){var u,c,b,g,m,w,p,v,k,y=_.bits,x=0,z=0,B=0,S=0,E=0,A=0,Z=0,R=0,C=0,N=0,O=null,D=0,I=new i.Buf16(16),U=new i.Buf16(16),T=null,F=0;for(x=0;x<=15;x++)I[x]=0;for(z=0;z<l;z++)I[e[a+z]]++;for(E=y,S=15;S>=1&&0===I[S];S--);if(E>S&&(E=S),0===S)return h[d++]=20971520,h[d++]=20971520,_.bits=1,0;for(B=1;B<S&&0===I[B];B++);for(E<B&&(E=B),R=1,x=1;x<=15;x++)if(R<<=1,(R-=I[x])<0)return-1;if(R>0&&(0===t||1!==S))return-1;for(U[1]=0,x=1;x<15;x++)U[x+1]=U[x]+I[x];for(z=0;z<l;z++)0!==e[a+z]&&(f[U[e[a+z]]++]=z);if(0===t?(O=T=f,w=19):1===t?(O=n,D-=257,T=r,F-=257,w=256):(O=s,T=o,w=-1),N=0,z=0,x=B,m=d,A=E,Z=0,b=-1,C=1<<E,g=C-1,1===t&&C>852||2===t&&C>592)return 1;for(;;){p=x-Z,f[z]<w?(v=0,k=f[z]):f[z]>w?(v=T[F+f[z]],k=O[D+f[z]]):(v=96,k=0),u=1<<x-Z,B=c=1<<A;do{h[m+(N>>Z)+(c-=u)]=p<<24|v<<16|k|0}while(0!==c);for(u=1<<x-1;N&u;)u>>=1;if(0!==u?(N&=u-1,N+=u):N=0,z++,0==--I[x]){if(x===S)break;x=e[a+f[z]]}if(x>E&&(N&g)!==b){for(0===Z&&(Z=E),m+=B,R=1<<(A=x-Z);A+Z<S&&!((R-=I[A+Z])<=0);)A++,R<<=1;if(C+=1<<A,1===t&&C>852||2===t&&C>592)return 1;h[b=N&g]=E<<24|A<<16|m-d|0}}return 0!==N&&(h[m+N]=x-Z<<24|64<<16|0),_.bits=E,0}},{"../utils/common":3}],13:[function(t,e,a){"use strict";e.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],14:[function(t,e,a){"use strict";function i(t){for(var e=t.length;--e>=0;)t[e]=0}function n(t,e,a,i,n){this.static_tree=t,this.extra_bits=e,this.extra_base=a,this.elems=i,this.max_length=n,this.has_stree=t&&t.length}function r(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}function s(t){return t<256?et[t]:et[256+(t>>>7)]}function o(t,e){t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255}function l(t,e,a){t.bi_valid>M-a?(t.bi_buf|=e<<t.bi_valid&65535,o(t,t.bi_buf),t.bi_buf=e>>M-t.bi_valid,t.bi_valid+=a-M):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=a)}function h(t,e,a){l(t,a[2*e],a[2*e+1])}function d(t,e){var a=0;do{a|=1&t,t>>>=1,a<<=1}while(--e>0);return a>>>1}function f(t){16===t.bi_valid?(o(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}function _(t,e){var a,i,n,r,s,o,l=e.dyn_tree,h=e.max_code,d=e.stat_desc.static_tree,f=e.stat_desc.has_stree,_=e.stat_desc.extra_bits,u=e.stat_desc.extra_base,c=e.stat_desc.max_length,b=0;for(r=0;r<=K;r++)t.bl_count[r]=0;for(l[2*t.heap[t.heap_max]+1]=0,a=t.heap_max+1;a<j;a++)(r=l[2*l[2*(i=t.heap[a])+1]+1]+1)>c&&(r=c,b++),l[2*i+1]=r,i>h||(t.bl_count[r]++,s=0,i>=u&&(s=_[i-u]),o=l[2*i],t.opt_len+=o*(r+s),f&&(t.static_len+=o*(d[2*i+1]+s)));if(0!==b){do{for(r=c-1;0===t.bl_count[r];)r--;t.bl_count[r]--,t.bl_count[r+1]+=2,t.bl_count[c]--,b-=2}while(b>0);for(r=c;0!==r;r--)for(i=t.bl_count[r];0!==i;)(n=t.heap[--a])>h||(l[2*n+1]!==r&&(t.opt_len+=(r-l[2*n+1])*l[2*n],l[2*n+1]=r),i--)}}function u(t,e,a){var i,n,r=new Array(K+1),s=0;for(i=1;i<=K;i++)r[i]=s=s+a[i-1]<<1;for(n=0;n<=e;n++){var o=t[2*n+1];0!==o&&(t[2*n]=d(r[o]++,o))}}function c(){var t,e,a,i,r,s=new Array(K+1);for(a=0,i=0;i<U-1;i++)for(it[i]=a,t=0;t<1<<W[i];t++)at[a++]=i;for(at[a-1]=i,r=0,i=0;i<16;i++)for(nt[i]=r,t=0;t<1<<J[i];t++)et[r++]=i;for(r>>=7;i<L;i++)for(nt[i]=r<<7,t=0;t<1<<J[i]-7;t++)et[256+r++]=i;for(e=0;e<=K;e++)s[e]=0;for(t=0;t<=143;)$[2*t+1]=8,t++,s[8]++;for(;t<=255;)$[2*t+1]=9,t++,s[9]++;for(;t<=279;)$[2*t+1]=7,t++,s[7]++;for(;t<=287;)$[2*t+1]=8,t++,s[8]++;for(u($,F+1,s),t=0;t<L;t++)tt[2*t+1]=5,tt[2*t]=d(t,5);rt=new n($,W,T+1,F,K),st=new n(tt,J,0,L,K),ot=new n(new Array(0),Q,0,H,P)}function b(t){var e;for(e=0;e<F;e++)t.dyn_ltree[2*e]=0;for(e=0;e<L;e++)t.dyn_dtree[2*e]=0;for(e=0;e<H;e++)t.bl_tree[2*e]=0;t.dyn_ltree[2*Y]=1,t.opt_len=t.static_len=0,t.last_lit=t.matches=0}function g(t){t.bi_valid>8?o(t,t.bi_buf):t.bi_valid>0&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0}function m(t,e,a,i){g(t),i&&(o(t,a),o(t,~a)),A.arraySet(t.pending_buf,t.window,e,a,t.pending),t.pending+=a}function w(t,e,a,i){var n=2*e,r=2*a;return t[n]<t[r]||t[n]===t[r]&&i[e]<=i[a]}function p(t,e,a){for(var i=t.heap[a],n=a<<1;n<=t.heap_len&&(n<t.heap_len&&w(e,t.heap[n+1],t.heap[n],t.depth)&&n++,!w(e,i,t.heap[n],t.depth));)t.heap[a]=t.heap[n],a=n,n<<=1;t.heap[a]=i}function v(t,e,a){var i,n,r,o,d=0;if(0!==t.last_lit)do{i=t.pending_buf[t.d_buf+2*d]<<8|t.pending_buf[t.d_buf+2*d+1],n=t.pending_buf[t.l_buf+d],d++,0===i?h(t,n,e):(h(t,(r=at[n])+T+1,e),0!==(o=W[r])&&l(t,n-=it[r],o),h(t,r=s(--i),a),0!==(o=J[r])&&l(t,i-=nt[r],o))}while(d<t.last_lit);h(t,Y,e)}function k(t,e){var a,i,n,r=e.dyn_tree,s=e.stat_desc.static_tree,o=e.stat_desc.has_stree,l=e.stat_desc.elems,h=-1;for(t.heap_len=0,t.heap_max=j,a=0;a<l;a++)0!==r[2*a]?(t.heap[++t.heap_len]=h=a,t.depth[a]=0):r[2*a+1]=0;for(;t.heap_len<2;)r[2*(n=t.heap[++t.heap_len]=h<2?++h:0)]=1,t.depth[n]=0,t.opt_len--,o&&(t.static_len-=s[2*n+1]);for(e.max_code=h,a=t.heap_len>>1;a>=1;a--)p(t,r,a);n=l;do{a=t.heap[1],t.heap[1]=t.heap[t.heap_len--],p(t,r,1),i=t.heap[1],t.heap[--t.heap_max]=a,t.heap[--t.heap_max]=i,r[2*n]=r[2*a]+r[2*i],t.depth[n]=(t.depth[a]>=t.depth[i]?t.depth[a]:t.depth[i])+1,r[2*a+1]=r[2*i+1]=n,t.heap[1]=n++,p(t,r,1)}while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],_(t,e),u(r,h,t.bl_count)}function y(t,e,a){var i,n,r=-1,s=e[1],o=0,l=7,h=4;for(0===s&&(l=138,h=3),e[2*(a+1)+1]=65535,i=0;i<=a;i++)n=s,s=e[2*(i+1)+1],++o<l&&n===s||(o<h?t.bl_tree[2*n]+=o:0!==n?(n!==r&&t.bl_tree[2*n]++,t.bl_tree[2*q]++):o<=10?t.bl_tree[2*G]++:t.bl_tree[2*X]++,o=0,r=n,0===s?(l=138,h=3):n===s?(l=6,h=3):(l=7,h=4))}function x(t,e,a){var i,n,r=-1,s=e[1],o=0,d=7,f=4;for(0===s&&(d=138,f=3),i=0;i<=a;i++)if(n=s,s=e[2*(i+1)+1],!(++o<d&&n===s)){if(o<f)do{h(t,n,t.bl_tree)}while(0!=--o);else 0!==n?(n!==r&&(h(t,n,t.bl_tree),o--),h(t,q,t.bl_tree),l(t,o-3,2)):o<=10?(h(t,G,t.bl_tree),l(t,o-3,3)):(h(t,X,t.bl_tree),l(t,o-11,7));o=0,r=n,0===s?(d=138,f=3):n===s?(d=6,f=3):(d=7,f=4)}}function z(t){var e;for(y(t,t.dyn_ltree,t.l_desc.max_code),y(t,t.dyn_dtree,t.d_desc.max_code),k(t,t.bl_desc),e=H-1;e>=3&&0===t.bl_tree[2*V[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}function B(t,e,a,i){var n;for(l(t,e-257,5),l(t,a-1,5),l(t,i-4,4),n=0;n<i;n++)l(t,t.bl_tree[2*V[n]+1],3);x(t,t.dyn_ltree,e-1),x(t,t.dyn_dtree,a-1)}function S(t){var e,a=4093624447;for(e=0;e<=31;e++,a>>>=1)if(1&a&&0!==t.dyn_ltree[2*e])return R;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return C;for(e=32;e<T;e++)if(0!==t.dyn_ltree[2*e])return C;return R}function E(t,e,a,i){l(t,(O<<1)+(i?1:0),3),m(t,e,a,!0)}var A=t("../utils/common"),Z=4,R=0,C=1,N=2,O=0,D=1,I=2,U=29,T=256,F=T+1+U,L=30,H=19,j=2*F+1,K=15,M=16,P=7,Y=256,q=16,G=17,X=18,W=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],J=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],Q=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],V=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],$=new Array(2*(F+2));i($);var tt=new Array(2*L);i(tt);var et=new Array(512);i(et);var at=new Array(256);i(at);var it=new Array(U);i(it);var nt=new Array(L);i(nt);var rt,st,ot,lt=!1;a._tr_init=function(t){lt||(c(),lt=!0),t.l_desc=new r(t.dyn_ltree,rt),t.d_desc=new r(t.dyn_dtree,st),t.bl_desc=new r(t.bl_tree,ot),t.bi_buf=0,t.bi_valid=0,b(t)},a._tr_stored_block=E,a._tr_flush_block=function(t,e,a,i){var n,r,s=0;t.level>0?(t.strm.data_type===N&&(t.strm.data_type=S(t)),k(t,t.l_desc),k(t,t.d_desc),s=z(t),n=t.opt_len+3+7>>>3,(r=t.static_len+3+7>>>3)<=n&&(n=r)):n=r=a+5,a+4<=n&&-1!==e?E(t,e,a,i):t.strategy===Z||r===n?(l(t,(D<<1)+(i?1:0),3),v(t,$,tt)):(l(t,(I<<1)+(i?1:0),3),B(t,t.l_desc.max_code+1,t.d_desc.max_code+1,s+1),v(t,t.dyn_ltree,t.dyn_dtree)),b(t),i&&g(t)},a._tr_tally=function(t,e,a){return t.pending_buf[t.d_buf+2*t.last_lit]=e>>>8&255,t.pending_buf[t.d_buf+2*t.last_lit+1]=255&e,t.pending_buf[t.l_buf+t.last_lit]=255&a,t.last_lit++,0===e?t.dyn_ltree[2*a]++:(t.matches++,e--,t.dyn_ltree[2*(at[a]+T+1)]++,t.dyn_dtree[2*s(e)]++),t.last_lit===t.lit_bufsize-1},a._tr_align=function(t){l(t,D<<1,3),h(t,Y,$),f(t)}},{"../utils/common":3}],15:[function(t,e,a){"use strict";e.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}},{}],"/":[function(t,e,a){"use strict";var i={};(0,t("./lib/utils/common").assign)(i,t("./lib/deflate"),t("./lib/inflate"),t("./lib/zlib/constants")),e.exports=i},{"./lib/deflate":1,"./lib/inflate":2,"./lib/utils/common":3,"./lib/zlib/constants":6}]},{},[])("/")});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdGxhc01ha2VyV2lkZ2V0Ly4vdmlldy9kb3dubG9hZHMvcGFrby5taW4uanM/NzhjYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxxQ0FBYSxHQUFHLElBQW9ELG9CQUFvQixLQUFLLEVBQTZLLENBQUMsWUFBWSx5QkFBeUIsZ0JBQWdCLFVBQVUsVUFBVSwwQ0FBMEMsZ0JBQWdCLE9BQUMsT0FBTyxvQkFBb0IsOENBQThDLGtDQUFrQyxZQUFZLFlBQVksbUNBQW1DLGlCQUFpQixlQUFlLHNCQUFzQixvQkFBb0Isa0RBQWtELFdBQVcsWUFBWSxTQUFTLEVBQUUsbUJBQW1CLGFBQWEsY0FBYyx3Q0FBd0MsdUJBQXVCLDJFQUEyRSxNQUFNLEVBQUUsbUJBQW1CLHVNQUF1TSxvRkFBb0YsK0JBQStCLGtFQUFrRSxNQUFNLHdOQUF3TixtQkFBbUIsZ0JBQWdCLGVBQWUsNENBQTRDLGdCQUFnQixpS0FBaUssK0JBQStCLDZDQUE2Qyx1QkFBdUIsK0tBQStLLEdBQUcsNElBQTRJLDJMQUEyTCw4Q0FBOEMsbUhBQW1ILGdDQUFnQyxvQkFBb0IsK0JBQStCLCtKQUErSixvREFBb0QsY0FBYyxpQkFBaUIsc0JBQXNCLGNBQWMsbUJBQW1CLEVBQUUsbUdBQW1HLHFCQUFxQixhQUFhLGNBQWMsd0NBQXdDLHVCQUF1QixtQ0FBbUMsTUFBTSxFQUFFLG1CQUFtQix5VkFBeVYsNkNBQTZDLG9DQUFvQyw0REFBNEQsZ0JBQWdCLGVBQWUsNENBQTRDLGdCQUFnQiwrTEFBK0wsK0JBQStCLG9GQUFvRix1QkFBdUIsc01BQXNNLEdBQUcsOFdBQThXLCtYQUErWCwyREFBMkQsc0xBQXNMLGdDQUFnQyxvQkFBb0IsK0JBQStCLG9LQUFvSyxvREFBb0QsY0FBYyxpQkFBaUIsWUFBWSxFQUFFLDZJQUE2SSxxQkFBcUIsYUFBYSxnQkFBZ0IsaURBQWlELHNHQUFzRyxxQkFBcUIsa0RBQWtELFNBQVMsRUFBRSxnQkFBZ0IsTUFBTSxrRUFBa0Usb0NBQW9DLFNBQVMsMkJBQTJCLGlFQUFpRSxPQUFPLDZCQUE2QixxREFBcUQsaUJBQWlCLElBQUksa0JBQWtCLDJCQUEyQixnQkFBZ0IsdUJBQXVCLElBQUksbUJBQW1CLDJDQUEyQyxJQUFJLGtDQUFrQyxVQUFVLElBQUksNkJBQTZCLFlBQVksSUFBSSxrQkFBa0IsMkJBQTJCLDhCQUE4Qix1QkFBdUIsb0lBQW9JLGVBQWUsR0FBRyxxQkFBcUIsYUFBYSxnQkFBZ0Isb0dBQW9HLGlCQUFpQixJQUFJLGlDQUFpQyxTQUFTLDhCQUE4QixJQUFJLG9DQUFvQyxTQUFTLEtBQUssSUFBSSxrREFBa0QsU0FBUyxLQUFLLDhCQUE4QixNQUFNLHdEQUF3RCx5Q0FBeUMsNkJBQTZCLFFBQVEsSUFBSSwySkFBMkosNEJBQTRCLElBQUksaVVBQWlVLFNBQVMsNkJBQTZCLHFCQUFxQiw2QkFBNkIsOENBQThDLElBQUkseUJBQXlCLFNBQVMsNEJBQTRCLDJDQUEyQyxZQUFZLElBQUksNEJBQTRCLHVDQUF1QyxLQUFLLDJCQUEyQixTQUFTLHNCQUFzQix5RkFBeUYsY0FBYyw0QkFBNEIsTUFBTSxpREFBaUQsc0JBQXNCLEtBQUssc0NBQXNDLEVBQUUsYUFBYSxxQkFBcUIsYUFBYSw0QkFBNEIseUNBQXlDLE1BQU0sRUFBRSxpQkFBaUIsR0FBRyxxQkFBcUIsV0FBVyxrQkFBa0Isa0JBQWtCLEdBQUcscUJBQXFCLGFBQWEsV0FBVywrWEFBK1gsR0FBRyxxQkFBcUIsYUFBYSxpQkFBaUIsbUJBQW1CLE1BQU0sS0FBSyxJQUFJLFlBQVksSUFBSSxpQ0FBaUMsT0FBTyxTQUFTLEdBQUcsNEJBQTRCLGNBQWMsTUFBTSxZQUFZLElBQUksNEJBQTRCLFlBQVksR0FBRyxxQkFBcUIsYUFBYSxnQkFBZ0Isb0JBQW9CLGNBQWMsdUJBQXVCLGNBQWMsbUJBQW1CLE9BQU8sUUFBUSxjQUFjLDBCQUEwQixpTkFBaU4sZ0JBQWdCLHFIQUFxSCxnQkFBZ0IsNkJBQTZCLGdCQUFnQixzRUFBc0Usb0JBQW9CLGlCQUFpQixrTUFBa00sZ0JBQWdCLGdNQUFnTSxvRUFBb0UsR0FBRywrREFBK0QsU0FBUyxJQUFJLG1KQUFtSiwwQkFBMEIsa0NBQWtDLHNCQUFzQiw0QkFBNEIsb0NBQW9DLGNBQWMseUJBQXlCLEdBQUcsZ0VBQWdFLG9HQUFvRyxHQUFHLG1DQUFtQyxXQUFXLE1BQU0sR0FBRyxtQ0FBbUMsV0FBVyxLQUFLLDZCQUE2QixpTUFBaU0sd0tBQXdLLEdBQUcsMkNBQTJDLGdCQUFnQixhQUFhLEVBQUUsbUJBQW1CLHdDQUF3Qyx5QkFBeUIsb1lBQW9ZLGlCQUFpQixHQUFHLDRKQUE0SiwyQkFBMkIsYUFBYSxpSkFBaUosd0VBQXdFLCtDQUErQyw0SUFBNEksZ0JBQWdCLGVBQWUsRUFBRSxtQkFBbUIsd0NBQXdDLHlCQUF5QixnZkFBZ2Ysc0lBQXNJLEdBQUcsa0tBQWtLLDBCQUEwQixvR0FBb0csMkJBQTJCLGtIQUFrSCxvREFBb0QsK05BQStOLGdCQUFnQiw0QkFBNEIsRUFBRSxvQkFBb0IseUNBQXlDLHlCQUF5QiwrR0FBK0csZ0JBQWdCLElBQUksMkdBQTJHLGlGQUFpRixzUEFBc1AsOEdBQThHLGdCQUFnQixXQUFXLEVBQUUsNENBQTRDLG1CQUFtQixNQUFNLG1JQUFtSSw4R0FBOEcsc0JBQXNCLG1GQUFtRixjQUFjLDhTQUE4UyxhQUFhLCtuQ0FBK25DLGNBQWMsTUFBTSwrTUFBK00sY0FBYyxXQUFXLDJCQUEyQix3QkFBd0IsZUFBZSxRQUFRLDhHQUE4RyxhQUFhLFlBQVksMGVBQTBlLHdUQUF3VCwrQkFBK0IsWUFBWSxzREFBc0QsRUFBRSxtQkFBbUIseUNBQXlDLHlCQUF5QixzQ0FBc0Msc0JBQXNCLG1IQUFtSCxtRkFBbUYsdUhBQXVILDBOQUEwTixzQkFBc0IseUZBQXlGLDREQUE0RCx5QkFBeUIsWUFBWSw0Q0FBNEMsdUdBQXVHLHNyQkFBc3JCLEtBQUssMkJBQTJCLHNMQUFzTCxvQ0FBb0MsZ0JBQWdCLDBNQUEwTSxnREFBZ0QsMElBQTBJLGlCQUFpQixtQ0FBbUMsWUFBWSxHQUFHLG1LQUFtSyxJQUFJLE1BQU0sb0ZBQW9GLGFBQWEsOEdBQThHLGlCQUFpQixzQ0FBc0MsWUFBWSxHQUFHLG1LQUFtSyxJQUFJLE1BQU0sMEZBQTBGLGFBQWEsa0dBQWtHLGlCQUFpQixrTUFBa00saURBQWlELHdEQUF3RCwrQ0FBK0MsMERBQTBELHVFQUF1RSw0RkFBNEYsb01BQW9NLDZTQUE2UywwQkFBMEIsTUFBTSxrSUFBa0ksc0NBQXNDLCtCQUErQix5QkFBeUIsd0VBQXdFLGdSQUFnUixnQkFBZ0IsRUFBRSxrQ0FBa0MsR0FBRyxzSEFBc0gsV0FBVyxtQ0FBbUMsK0xBQStMLG9EQUFvRCxFQUFFLDJFQUEyRSxxQkFBcUIsYUFBYSxxQkFBcUIsd0lBQXdJLEdBQUcsc0JBQXNCLGFBQWEsd0JBQXdCLHNEQUFzRCx5UEFBeVAsS0FBSyxxREFBcUQsUUFBUSxFQUFFLDBEQUEwRCxLQUFLLFlBQVksY0FBYyw0QkFBNEIsV0FBVyxTQUFTLFVBQVUsUUFBUSw4Q0FBOEMsUUFBUSw2SEFBNkgsUUFBUSxFQUFFLDhDQUE4QyxjQUFjLDRCQUE0QixXQUFXLHdDQUF3QyxRQUFRLHdGQUF3RixnREFBZ0QsUUFBUSwwQkFBMEIsc0JBQXNCLGdEQUFnRCxRQUFRLGtCQUFrQixlQUFlLEtBQUssR0FBRyxjQUFjLFdBQVcsV0FBVyxhQUFhLHNCQUFzQixLQUFLLEdBQUcsY0FBYyxXQUFXLFlBQVksT0FBTyxHQUFHLGNBQWMsV0FBVyxZQUFZLG9CQUFvQixLQUFLLEdBQUcsY0FBYyxXQUFXLFVBQVUsS0FBSyxJQUFJLGdEQUFnRCx3Q0FBd0MsS0FBSyxNQUFNLEdBQUcsK0NBQStDLFdBQVcsd0NBQXdDLE9BQU8sT0FBTyxnQkFBZ0IseUlBQXlJLEdBQUcsc0JBQXNCLGFBQWEsY0FBYyw4REFBOEQsYUFBYSwrZkFBK2YsY0FBYyxNQUFNLDRRQUE0USxjQUFjLE1BQU0sbUVBQW1FLGdCQUFnQixRQUFRLG1LQUFtSyxnQkFBZ0IsUUFBUSw4RUFBOEUsY0FBYyxPQUFPLE1BQU0sNkNBQTZDLE1BQU0sZUFBZSxLQUFLLE1BQU0sZUFBZSxLQUFLLE1BQU0sZUFBZSxLQUFLLE1BQU0sZUFBZSxpQ0FBaUMsT0FBTyxNQUFNLEtBQUssZUFBZSw0QkFBNEIsT0FBTyxRQUFRLGtEQUFrRCxvQkFBb0IsZ0JBQWdCLGtZQUFrWSx5VkFBeVYsa0ZBQWtGLGVBQWUsMENBQTBDLDhJQUE4SSw4REFBOEQsNElBQTRJLFFBQVEsZ0JBQWdCLHNCQUFzQixTQUFTLE1BQU0sS0FBSyxNQUFNLEVBQUUsaUJBQWlCLHdCQUF3Qix3QkFBd0Isa0ZBQWtGLE1BQU0sNkVBQTZFLHlDQUF5QyxNQUFNLGVBQWUsNkNBQTZDLE1BQU0sbURBQW1ELG9CQUFvQixzQ0FBc0MsTUFBTSx5REFBeUQsTUFBTSxZQUFZLE1BQU0sRUFBRSxpQkFBaUIsd0JBQXdCLGdDQUFnQyw2Q0FBNkMsTUFBTSxrQkFBa0IsMkNBQTJDLE1BQU0sb0hBQW9ILFlBQVksTUFBTSxFQUFFLGlCQUFpQix3QkFBd0IsaUpBQWlKLFlBQVksTUFBTSxFQUFFLGlCQUFpQix3QkFBd0Isb0lBQW9JLHdCQUF3QixLQUFLLE1BQU0sRUFBRSxpQkFBaUIsd0JBQXdCLHNIQUFzSCxpQ0FBaUMsU0FBUyw4UUFBOFEsb0JBQW9CLHdCQUF3QixpQkFBaUIsS0FBSyxHQUFHLGdGQUFnRixnQkFBZ0IsbUVBQW1FLGdDQUFnQyxvQkFBb0Isd0JBQXdCLGlCQUFpQixLQUFLLEdBQUcsbUZBQW1GLGdCQUFnQixtRUFBbUUsbUNBQW1DLFNBQVMsdUJBQXVCLEtBQUssTUFBTSxFQUFFLGlCQUFpQix3QkFBd0Isd0JBQXdCLHNDQUFzQyxNQUFNLFNBQVMsNkVBQTZFLE1BQU0sWUFBWSxNQUFNLEVBQUUsaUJBQWlCLHdCQUF3Qix1Q0FBdUMseUdBQXlHLDJCQUEyQiwrQkFBK0Isa0JBQWtCLDZCQUE2QixNQUFNLEtBQUssS0FBSyxFQUFFLGlCQUFpQix3QkFBd0Isb0NBQW9DLGdCQUFnQixNQUFNLCtCQUErQixhQUFhLFFBQVEsTUFBTSxnQkFBZ0IsTUFBTSw0Q0FBNEMsYUFBYSxNQUFNLDhCQUE4QixNQUFNLEVBQUUsaUJBQWlCLHdCQUF3Qiw4QkFBOEIsK0NBQStDLE1BQU0sb0RBQW9ELGdCQUFnQix1QkFBdUIsNENBQTRDLDREQUE0RCxNQUFNLFNBQVMsTUFBTSxZQUFZLE1BQU0sRUFBRSxpQkFBaUIsd0JBQXdCLHNIQUFzSCxzREFBc0QsTUFBTSxrQkFBa0IsWUFBWSxlQUFlLEVBQUUsS0FBSyxLQUFLLEVBQUUsaUJBQWlCLHdCQUF3QixzQ0FBc0MsS0FBSyxVQUFVLHdCQUF3QixzQ0FBc0MsZUFBZSxpRUFBaUUsMkNBQTJDLE1BQU0sa0JBQWtCLFlBQVksc0JBQXNCLEVBQUUsS0FBSyxpRkFBaUYsRUFBRSxpQkFBaUIsd0JBQXdCLDRDQUE0QyxLQUFLLFlBQVksWUFBWSxNQUFNLEVBQUUsaUJBQWlCLHdCQUF3Qiw4QkFBOEIsNENBQTRDLE1BQU0sNENBQTRDLGlCQUFpQixZQUFZLE1BQU0sRUFBRSxpQkFBaUIsd0JBQXdCLDRDQUE0QyxLQUFLLFlBQVksTUFBTSxFQUFFLGlCQUFpQix3QkFBd0IsK0NBQStDLDZCQUE2Qiw0Q0FBNEMsTUFBTSxLQUFLLEtBQUssc0JBQXNCLHFCQUFxQixvQkFBb0IsdURBQXVELE1BQU0sbUJBQW1CLGVBQWUscUVBQXFFLDhDQUE4QyxNQUFNLHlDQUF5QyxnQkFBZ0IsNkVBQTZFLHdDQUF3QyxNQUFNLDBCQUEwQixnQkFBZ0Isd0JBQXdCLG1NQUFtTSxNQUFNLGFBQWEsaUZBQWlGLEVBQUUsaUJBQWlCLHdCQUF3QixvQkFBb0Isc0JBQXNCLDJGQUEyRixFQUFFLGlCQUFpQix3QkFBd0IsMEJBQTBCLGlEQUFpRCxVQUFVLE1BQU0sVUFBVSxtQkFBbUIsTUFBTSxVQUFVLDhDQUE4QyxNQUFNLHVCQUF1QixtQkFBbUIsZUFBZSxNQUFNLEVBQUUsaUJBQWlCLHdCQUF3QixvRUFBb0UseUJBQXlCLGFBQWEsbUZBQW1GLEVBQUUsaUJBQWlCLHdCQUF3QixnQkFBZ0Isc0JBQXNCLDRGQUE0RixFQUFFLGlCQUFpQix3QkFBd0IsMEJBQTBCLG9DQUFvQyx3Q0FBd0MsTUFBTSxvQ0FBb0Msb0JBQW9CLGVBQWUsTUFBTSxFQUFFLGlCQUFpQix3QkFBd0Isb0VBQW9FLG9CQUFvQixnREFBZ0QsTUFBTSxVQUFVLHlCQUF5Qix3QkFBd0IscUNBQXFDLGdEQUFnRCxNQUFNLDRGQUE0RixvQ0FBb0MsZ0NBQWdDLEdBQUcsZ0JBQWdCLFlBQVkseUJBQXlCLE1BQU0seUJBQXlCLDZCQUE2QixNQUFNLG1CQUFtQixLQUFLLE1BQU0sRUFBRSxpQkFBaUIsd0JBQXdCLDhJQUE4SSx1Q0FBdUMsTUFBTSxTQUFTLFVBQVUsNEJBQTRCLEtBQUssTUFBTSxFQUFFLGlCQUFpQix3QkFBd0IsNkJBQTZCLHlDQUF5QyxNQUFNLFNBQVMsVUFBVSxhQUFhLFFBQVEsYUFBYSxRQUFRLGlCQUFpQix5QkFBeUIsNGVBQTRlLDBCQUEwQix5QkFBeUIsY0FBYyxnREFBZ0Qsa0NBQWtDLE1BQU0scUVBQXFFLHNDQUFzQyxtQkFBbUIsOElBQThJLG9EQUFvRCxFQUFFLDZFQUE2RSxzQkFBc0IsYUFBYSxzYkFBc2Isb0NBQW9DLGlJQUFpSSxRQUFRLE1BQU0sV0FBVyxRQUFRLElBQUksZ0JBQWdCLGFBQWEsZUFBZSxLQUFLLHNFQUFzRSxRQUFRLGNBQWMsS0FBSyx1QkFBdUIsTUFBTSxrQ0FBa0MsZ0NBQWdDLGVBQWUsS0FBSyxxQkFBcUIsUUFBUSxJQUFJLG1DQUFtQyx1SkFBdUosTUFBTSxFQUFFLHdGQUF3RixHQUFHLG1DQUFtQyxhQUFhLGFBQWEsSUFBSSxPQUFPLDBDQUEwQyxlQUFlLFlBQVksbUJBQW1CLG1DQUFtQyx5QkFBeUIsV0FBVywrQ0FBK0MsNEJBQTRCLG9EQUFvRCxFQUFFLG9CQUFvQixzQkFBc0IsYUFBYSxXQUFXLDRLQUE0SyxHQUFHLHNCQUFzQixhQUFhLGNBQWMsbUJBQW1CLE9BQU8sUUFBUSxzQkFBc0IsaUhBQWlILGdCQUFnQixpREFBaUQsY0FBYyxtQ0FBbUMsZ0JBQWdCLHNFQUFzRSxrQkFBa0Isb0pBQW9KLGtCQUFrQixxQkFBcUIsZ0JBQWdCLFFBQVEsR0FBRyxvQkFBb0IsYUFBYSxhQUFhLGNBQWMsNElBQTRJLGdCQUFnQiwyS0FBMkssUUFBUSxLQUFLLG9CQUFvQiwrQ0FBK0MsSUFBSSx3S0FBd0ssVUFBVSxHQUFHLFVBQVUsa0JBQWtCLEtBQUssd0RBQXdELFdBQVcsUUFBUSxNQUFNLHdCQUF3QixNQUFNLHFGQUFxRixrQkFBa0IsNkJBQTZCLFFBQVEsS0FBSyx1QkFBdUIsUUFBUSxLQUFLLEtBQUssZUFBZSw2QkFBNkIsYUFBYSwrQkFBK0IsWUFBWSxNQUFNLG9CQUFvQixVQUFVLGNBQWMsc0JBQXNCLEtBQUssb0JBQW9CLFVBQVUsY0FBYyxVQUFVLElBQUksdUJBQXVCLFlBQVksa0JBQWtCLFFBQVEsS0FBSyxXQUFXLFFBQVEsT0FBTyx1QkFBdUIsS0FBSyxPQUFPLHVCQUF1QixLQUFLLE9BQU8sdUJBQXVCLEtBQUssT0FBTyx1QkFBdUIsbUJBQW1CLElBQUksK0JBQStCLDBFQUEwRSxjQUFjLE1BQU0sUUFBUSxJQUFJLHVCQUF1QixRQUFRLElBQUksdUJBQXVCLFFBQVEsSUFBSSxxQkFBcUIsbUVBQW1FLGNBQWMsdUdBQXVHLG9CQUFvQix1RkFBdUYsb0JBQW9CLGdCQUFnQiwwQ0FBMEMsa0JBQWtCLDJCQUEyQixpR0FBaUcsK0JBQStCLFlBQVksa0JBQWtCLGdCQUFnQixxQkFBcUIsOE1BQThNLG9CQUFvQixTQUFTLGdCQUFnQixrR0FBa0csa0NBQWtDLElBQUksa0VBQWtFLEtBQUssYUFBYSxnR0FBZ0csaUNBQWlDLEtBQUssYUFBYSxJQUFJLEdBQUcsME9BQTBPLHFCQUFxQix3REFBd0Qsa0JBQWtCLGdDQUFnQyw4Q0FBOEMsS0FBSywwTUFBME0sa0JBQWtCLGdDQUFnQywyQkFBMkIsS0FBSywyQ0FBMkMsVUFBVSxpQkFBaUIsY0FBYywwSUFBMEkscURBQXFELGNBQWMsTUFBTSwrRkFBK0YsOEJBQThCLEtBQUssa0NBQWtDLG9CQUFvQixNQUFNLDJDQUEyQyxJQUFJLCtCQUErQiwwQ0FBMEMsY0FBYyxtQkFBbUIsUUFBUSxNQUFNLGlEQUFpRCwwRUFBMEUsU0FBUyxJQUFJLHFDQUFxQyxTQUFTLG9CQUFvQixrQ0FBa0MsdVhBQXVYLEtBQUssc0JBQXNCLE1BQU0sc0JBQXNCLE1BQU0sc0JBQXNCLE1BQU0sb0JBQW9CLE1BQU0sb0JBQW9CLE1BQU0sbUJBQW1CLHVCQUF1Qix5SUFBeUksMERBQTBELFlBQVksaVdBQWlXLDZCQUE2QixpUkFBaVIseUJBQXlCLDJCQUEyQixFQUFFLG9CQUFvQixzQkFBc0IsYUFBYSxxQkFBcUIsNkxBQTZMLEdBQUcsdUJBQXVCLGFBQWEsU0FBUyxrSEFBa0gsRUFBRSxvRkFBb0YsRUFBRSxHQUFHLFVBQVUiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbih0KXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz10KCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLHQpO2Vsc2V7KFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcykucGFrbz10KCl9fShmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbiB0KGUsYSxpKXtmdW5jdGlvbiBuKHMsbyl7aWYoIWFbc10pe2lmKCFlW3NdKXt2YXIgbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFvJiZsKXJldHVybiBsKHMsITApO2lmKHIpcmV0dXJuIHIocywhMCk7dmFyIGg9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitzK1wiJ1wiKTt0aHJvdyBoLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsaH12YXIgZD1hW3NdPXtleHBvcnRzOnt9fTtlW3NdWzBdLmNhbGwoZC5leHBvcnRzLGZ1bmN0aW9uKHQpe3ZhciBhPWVbc11bMV1bdF07cmV0dXJuIG4oYXx8dCl9LGQsZC5leHBvcnRzLHQsZSxhLGkpfXJldHVybiBhW3NdLmV4cG9ydHN9Zm9yKHZhciByPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUscz0wO3M8aS5sZW5ndGg7cysrKW4oaVtzXSk7cmV0dXJuIG59KHsxOltmdW5jdGlvbih0LGUsYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaSh0KXtpZighKHRoaXMgaW5zdGFuY2VvZiBpKSlyZXR1cm4gbmV3IGkodCk7dGhpcy5vcHRpb25zPXMuYXNzaWduKHtsZXZlbDpfLG1ldGhvZDpjLGNodW5rU2l6ZToxNjM4NCx3aW5kb3dCaXRzOjE1LG1lbUxldmVsOjgsc3RyYXRlZ3k6dSx0bzpcIlwifSx0fHx7fSk7dmFyIGU9dGhpcy5vcHRpb25zO2UucmF3JiZlLndpbmRvd0JpdHM+MD9lLndpbmRvd0JpdHM9LWUud2luZG93Qml0czplLmd6aXAmJmUud2luZG93Qml0cz4wJiZlLndpbmRvd0JpdHM8MTYmJihlLndpbmRvd0JpdHMrPTE2KSx0aGlzLmVycj0wLHRoaXMubXNnPVwiXCIsdGhpcy5lbmRlZD0hMSx0aGlzLmNodW5rcz1bXSx0aGlzLnN0cm09bmV3IGgsdGhpcy5zdHJtLmF2YWlsX291dD0wO3ZhciBhPXIuZGVmbGF0ZUluaXQyKHRoaXMuc3RybSxlLmxldmVsLGUubWV0aG9kLGUud2luZG93Qml0cyxlLm1lbUxldmVsLGUuc3RyYXRlZ3kpO2lmKGEhPT1mKXRocm93IG5ldyBFcnJvcihsW2FdKTtpZihlLmhlYWRlciYmci5kZWZsYXRlU2V0SGVhZGVyKHRoaXMuc3RybSxlLmhlYWRlciksZS5kaWN0aW9uYXJ5KXt2YXIgbjtpZihuPVwic3RyaW5nXCI9PXR5cGVvZiBlLmRpY3Rpb25hcnk/by5zdHJpbmcyYnVmKGUuZGljdGlvbmFyeSk6XCJbb2JqZWN0IEFycmF5QnVmZmVyXVwiPT09ZC5jYWxsKGUuZGljdGlvbmFyeSk/bmV3IFVpbnQ4QXJyYXkoZS5kaWN0aW9uYXJ5KTplLmRpY3Rpb25hcnksKGE9ci5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sbikpIT09Zil0aHJvdyBuZXcgRXJyb3IobFthXSk7dGhpcy5fZGljdF9zZXQ9ITB9fWZ1bmN0aW9uIG4odCxlKXt2YXIgYT1uZXcgaShlKTtpZihhLnB1c2godCwhMCksYS5lcnIpdGhyb3cgYS5tc2d8fGxbYS5lcnJdO3JldHVybiBhLnJlc3VsdH12YXIgcj10KFwiLi96bGliL2RlZmxhdGVcIikscz10KFwiLi91dGlscy9jb21tb25cIiksbz10KFwiLi91dGlscy9zdHJpbmdzXCIpLGw9dChcIi4vemxpYi9tZXNzYWdlc1wiKSxoPXQoXCIuL3psaWIvenN0cmVhbVwiKSxkPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsZj0wLF89LTEsdT0wLGM9ODtpLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHQsZSl7dmFyIGEsaSxuPXRoaXMuc3RybSxsPXRoaXMub3B0aW9ucy5jaHVua1NpemU7aWYodGhpcy5lbmRlZClyZXR1cm4hMTtpPWU9PT1+fmU/ZTohMD09PWU/NDowLFwic3RyaW5nXCI9PXR5cGVvZiB0P24uaW5wdXQ9by5zdHJpbmcyYnVmKHQpOlwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIj09PWQuY2FsbCh0KT9uLmlucHV0PW5ldyBVaW50OEFycmF5KHQpOm4uaW5wdXQ9dCxuLm5leHRfaW49MCxuLmF2YWlsX2luPW4uaW5wdXQubGVuZ3RoO2Rve2lmKDA9PT1uLmF2YWlsX291dCYmKG4ub3V0cHV0PW5ldyBzLkJ1ZjgobCksbi5uZXh0X291dD0wLG4uYXZhaWxfb3V0PWwpLDEhPT0oYT1yLmRlZmxhdGUobixpKSkmJmEhPT1mKXJldHVybiB0aGlzLm9uRW5kKGEpLHRoaXMuZW5kZWQ9ITAsITE7MCE9PW4uYXZhaWxfb3V0JiYoMCE9PW4uYXZhaWxfaW58fDQhPT1pJiYyIT09aSl8fChcInN0cmluZ1wiPT09dGhpcy5vcHRpb25zLnRvP3RoaXMub25EYXRhKG8uYnVmMmJpbnN0cmluZyhzLnNocmlua0J1ZihuLm91dHB1dCxuLm5leHRfb3V0KSkpOnRoaXMub25EYXRhKHMuc2hyaW5rQnVmKG4ub3V0cHV0LG4ubmV4dF9vdXQpKSl9d2hpbGUoKG4uYXZhaWxfaW4+MHx8MD09PW4uYXZhaWxfb3V0KSYmMSE9PWEpO3JldHVybiA0PT09aT8oYT1yLmRlZmxhdGVFbmQodGhpcy5zdHJtKSx0aGlzLm9uRW5kKGEpLHRoaXMuZW5kZWQ9ITAsYT09PWYpOjIhPT1pfHwodGhpcy5vbkVuZChmKSxuLmF2YWlsX291dD0wLCEwKX0saS5wcm90b3R5cGUub25EYXRhPWZ1bmN0aW9uKHQpe3RoaXMuY2h1bmtzLnB1c2godCl9LGkucHJvdG90eXBlLm9uRW5kPWZ1bmN0aW9uKHQpe3Q9PT1mJiYoXCJzdHJpbmdcIj09PXRoaXMub3B0aW9ucy50bz90aGlzLnJlc3VsdD10aGlzLmNodW5rcy5qb2luKFwiXCIpOnRoaXMucmVzdWx0PXMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcykpLHRoaXMuY2h1bmtzPVtdLHRoaXMuZXJyPXQsdGhpcy5tc2c9dGhpcy5zdHJtLm1zZ30sYS5EZWZsYXRlPWksYS5kZWZsYXRlPW4sYS5kZWZsYXRlUmF3PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGU9ZXx8e30sZS5yYXc9ITAsbih0LGUpfSxhLmd6aXA9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZT1lfHx7fSxlLmd6aXA9ITAsbih0LGUpfX0se1wiLi91dGlscy9jb21tb25cIjozLFwiLi91dGlscy9zdHJpbmdzXCI6NCxcIi4vemxpYi9kZWZsYXRlXCI6OCxcIi4vemxpYi9tZXNzYWdlc1wiOjEzLFwiLi96bGliL3pzdHJlYW1cIjoxNX1dLDI6W2Z1bmN0aW9uKHQsZSxhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKHQpe2lmKCEodGhpcyBpbnN0YW5jZW9mIGkpKXJldHVybiBuZXcgaSh0KTt0aGlzLm9wdGlvbnM9cy5hc3NpZ24oe2NodW5rU2l6ZToxNjM4NCx3aW5kb3dCaXRzOjAsdG86XCJcIn0sdHx8e30pO3ZhciBlPXRoaXMub3B0aW9ucztlLnJhdyYmZS53aW5kb3dCaXRzPj0wJiZlLndpbmRvd0JpdHM8MTYmJihlLndpbmRvd0JpdHM9LWUud2luZG93Qml0cywwPT09ZS53aW5kb3dCaXRzJiYoZS53aW5kb3dCaXRzPS0xNSkpLCEoZS53aW5kb3dCaXRzPj0wJiZlLndpbmRvd0JpdHM8MTYpfHx0JiZ0LndpbmRvd0JpdHN8fChlLndpbmRvd0JpdHMrPTMyKSxlLndpbmRvd0JpdHM+MTUmJmUud2luZG93Qml0czw0OCYmMD09KDE1JmUud2luZG93Qml0cykmJihlLndpbmRvd0JpdHN8PTE1KSx0aGlzLmVycj0wLHRoaXMubXNnPVwiXCIsdGhpcy5lbmRlZD0hMSx0aGlzLmNodW5rcz1bXSx0aGlzLnN0cm09bmV3IGQsdGhpcy5zdHJtLmF2YWlsX291dD0wO3ZhciBhPXIuaW5mbGF0ZUluaXQyKHRoaXMuc3RybSxlLndpbmRvd0JpdHMpO2lmKGEhPT1sLlpfT0spdGhyb3cgbmV3IEVycm9yKGhbYV0pO3RoaXMuaGVhZGVyPW5ldyBmLHIuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sdGhpcy5oZWFkZXIpfWZ1bmN0aW9uIG4odCxlKXt2YXIgYT1uZXcgaShlKTtpZihhLnB1c2godCwhMCksYS5lcnIpdGhyb3cgYS5tc2d8fGhbYS5lcnJdO3JldHVybiBhLnJlc3VsdH12YXIgcj10KFwiLi96bGliL2luZmxhdGVcIikscz10KFwiLi91dGlscy9jb21tb25cIiksbz10KFwiLi91dGlscy9zdHJpbmdzXCIpLGw9dChcIi4vemxpYi9jb25zdGFudHNcIiksaD10KFwiLi96bGliL21lc3NhZ2VzXCIpLGQ9dChcIi4vemxpYi96c3RyZWFtXCIpLGY9dChcIi4vemxpYi9nemhlYWRlclwiKSxfPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7aS5wcm90b3R5cGUucHVzaD1mdW5jdGlvbih0LGUpe3ZhciBhLGksbixoLGQsZix1PXRoaXMuc3RybSxjPXRoaXMub3B0aW9ucy5jaHVua1NpemUsYj10aGlzLm9wdGlvbnMuZGljdGlvbmFyeSxnPSExO2lmKHRoaXMuZW5kZWQpcmV0dXJuITE7aT1lPT09fn5lP2U6ITA9PT1lP2wuWl9GSU5JU0g6bC5aX05PX0ZMVVNILFwic3RyaW5nXCI9PXR5cGVvZiB0P3UuaW5wdXQ9by5iaW5zdHJpbmcyYnVmKHQpOlwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIj09PV8uY2FsbCh0KT91LmlucHV0PW5ldyBVaW50OEFycmF5KHQpOnUuaW5wdXQ9dCx1Lm5leHRfaW49MCx1LmF2YWlsX2luPXUuaW5wdXQubGVuZ3RoO2Rve2lmKDA9PT11LmF2YWlsX291dCYmKHUub3V0cHV0PW5ldyBzLkJ1ZjgoYyksdS5uZXh0X291dD0wLHUuYXZhaWxfb3V0PWMpLChhPXIuaW5mbGF0ZSh1LGwuWl9OT19GTFVTSCkpPT09bC5aX05FRURfRElDVCYmYiYmKGY9XCJzdHJpbmdcIj09dHlwZW9mIGI/by5zdHJpbmcyYnVmKGIpOlwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIj09PV8uY2FsbChiKT9uZXcgVWludDhBcnJheShiKTpiLGE9ci5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sZikpLGE9PT1sLlpfQlVGX0VSUk9SJiYhMD09PWcmJihhPWwuWl9PSyxnPSExKSxhIT09bC5aX1NUUkVBTV9FTkQmJmEhPT1sLlpfT0spcmV0dXJuIHRoaXMub25FbmQoYSksdGhpcy5lbmRlZD0hMCwhMTt1Lm5leHRfb3V0JiYoMCE9PXUuYXZhaWxfb3V0JiZhIT09bC5aX1NUUkVBTV9FTkQmJigwIT09dS5hdmFpbF9pbnx8aSE9PWwuWl9GSU5JU0gmJmkhPT1sLlpfU1lOQ19GTFVTSCl8fChcInN0cmluZ1wiPT09dGhpcy5vcHRpb25zLnRvPyhuPW8udXRmOGJvcmRlcih1Lm91dHB1dCx1Lm5leHRfb3V0KSxoPXUubmV4dF9vdXQtbixkPW8uYnVmMnN0cmluZyh1Lm91dHB1dCxuKSx1Lm5leHRfb3V0PWgsdS5hdmFpbF9vdXQ9Yy1oLGgmJnMuYXJyYXlTZXQodS5vdXRwdXQsdS5vdXRwdXQsbixoLDApLHRoaXMub25EYXRhKGQpKTp0aGlzLm9uRGF0YShzLnNocmlua0J1Zih1Lm91dHB1dCx1Lm5leHRfb3V0KSkpKSwwPT09dS5hdmFpbF9pbiYmMD09PXUuYXZhaWxfb3V0JiYoZz0hMCl9d2hpbGUoKHUuYXZhaWxfaW4+MHx8MD09PXUuYXZhaWxfb3V0KSYmYSE9PWwuWl9TVFJFQU1fRU5EKTtyZXR1cm4gYT09PWwuWl9TVFJFQU1fRU5EJiYoaT1sLlpfRklOSVNIKSxpPT09bC5aX0ZJTklTSD8oYT1yLmluZmxhdGVFbmQodGhpcy5zdHJtKSx0aGlzLm9uRW5kKGEpLHRoaXMuZW5kZWQ9ITAsYT09PWwuWl9PSyk6aSE9PWwuWl9TWU5DX0ZMVVNIfHwodGhpcy5vbkVuZChsLlpfT0spLHUuYXZhaWxfb3V0PTAsITApfSxpLnByb3RvdHlwZS5vbkRhdGE9ZnVuY3Rpb24odCl7dGhpcy5jaHVua3MucHVzaCh0KX0saS5wcm90b3R5cGUub25FbmQ9ZnVuY3Rpb24odCl7dD09PWwuWl9PSyYmKFwic3RyaW5nXCI9PT10aGlzLm9wdGlvbnMudG8/dGhpcy5yZXN1bHQ9dGhpcy5jaHVua3Muam9pbihcIlwiKTp0aGlzLnJlc3VsdD1zLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpKSx0aGlzLmNodW5rcz1bXSx0aGlzLmVycj10LHRoaXMubXNnPXRoaXMuc3RybS5tc2d9LGEuSW5mbGF0ZT1pLGEuaW5mbGF0ZT1uLGEuaW5mbGF0ZVJhdz1mdW5jdGlvbih0LGUpe3JldHVybiBlPWV8fHt9LGUucmF3PSEwLG4odCxlKX0sYS51bmd6aXA9bn0se1wiLi91dGlscy9jb21tb25cIjozLFwiLi91dGlscy9zdHJpbmdzXCI6NCxcIi4vemxpYi9jb25zdGFudHNcIjo2LFwiLi96bGliL2d6aGVhZGVyXCI6OSxcIi4vemxpYi9pbmZsYXRlXCI6MTEsXCIuL3psaWIvbWVzc2FnZXNcIjoxMyxcIi4vemxpYi96c3RyZWFtXCI6MTV9XSwzOltmdW5jdGlvbih0LGUsYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaSh0LGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKX12YXIgbj1cInVuZGVmaW5lZFwiIT10eXBlb2YgVWludDhBcnJheSYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFVpbnQxNkFycmF5JiZcInVuZGVmaW5lZFwiIT10eXBlb2YgSW50MzJBcnJheTthLmFzc2lnbj1mdW5jdGlvbih0KXtmb3IodmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO2UubGVuZ3RoOyl7dmFyIGE9ZS5zaGlmdCgpO2lmKGEpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBhKXRocm93IG5ldyBUeXBlRXJyb3IoYStcIm11c3QgYmUgbm9uLW9iamVjdFwiKTtmb3IodmFyIG4gaW4gYSlpKGEsbikmJih0W25dPWFbbl0pfX1yZXR1cm4gdH0sYS5zaHJpbmtCdWY9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5sZW5ndGg9PT1lP3Q6dC5zdWJhcnJheT90LnN1YmFycmF5KDAsZSk6KHQubGVuZ3RoPWUsdCl9O3ZhciByPXthcnJheVNldDpmdW5jdGlvbih0LGUsYSxpLG4pe2lmKGUuc3ViYXJyYXkmJnQuc3ViYXJyYXkpdC5zZXQoZS5zdWJhcnJheShhLGEraSksbik7ZWxzZSBmb3IodmFyIHI9MDtyPGk7cisrKXRbbityXT1lW2Ercl19LGZsYXR0ZW5DaHVua3M6ZnVuY3Rpb24odCl7dmFyIGUsYSxpLG4scixzO2ZvcihpPTAsZT0wLGE9dC5sZW5ndGg7ZTxhO2UrKylpKz10W2VdLmxlbmd0aDtmb3Iocz1uZXcgVWludDhBcnJheShpKSxuPTAsZT0wLGE9dC5sZW5ndGg7ZTxhO2UrKylyPXRbZV0scy5zZXQocixuKSxuKz1yLmxlbmd0aDtyZXR1cm4gc319LHM9e2FycmF5U2V0OmZ1bmN0aW9uKHQsZSxhLGksbil7Zm9yKHZhciByPTA7cjxpO3IrKyl0W24rcl09ZVthK3JdfSxmbGF0dGVuQ2h1bmtzOmZ1bmN0aW9uKHQpe3JldHVybltdLmNvbmNhdC5hcHBseShbXSx0KX19O2Euc2V0VHlwZWQ9ZnVuY3Rpb24odCl7dD8oYS5CdWY4PVVpbnQ4QXJyYXksYS5CdWYxNj1VaW50MTZBcnJheSxhLkJ1ZjMyPUludDMyQXJyYXksYS5hc3NpZ24oYSxyKSk6KGEuQnVmOD1BcnJheSxhLkJ1ZjE2PUFycmF5LGEuQnVmMzI9QXJyYXksYS5hc3NpZ24oYSxzKSl9LGEuc2V0VHlwZWQobil9LHt9XSw0OltmdW5jdGlvbih0LGUsYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaSh0LGUpe2lmKGU8NjU1MzcmJih0LnN1YmFycmF5JiZzfHwhdC5zdWJhcnJheSYmcikpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxuLnNocmlua0J1Zih0LGUpKTtmb3IodmFyIGE9XCJcIixpPTA7aTxlO2krKylhKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHRbaV0pO3JldHVybiBhfXZhciBuPXQoXCIuL2NvbW1vblwiKSxyPSEwLHM9ITA7dHJ5e1N0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxbMF0pfWNhdGNoKHQpe3I9ITF9dHJ5e1N0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxuZXcgVWludDhBcnJheSgxKSl9Y2F0Y2godCl7cz0hMX1mb3IodmFyIG89bmV3IG4uQnVmOCgyNTYpLGw9MDtsPDI1NjtsKyspb1tsXT1sPj0yNTI/NjpsPj0yNDg/NTpsPj0yNDA/NDpsPj0yMjQ/MzpsPj0xOTI/MjoxO29bMjU0XT1vWzI1NF09MSxhLnN0cmluZzJidWY9ZnVuY3Rpb24odCl7dmFyIGUsYSxpLHIscyxvPXQubGVuZ3RoLGw9MDtmb3Iocj0wO3I8bztyKyspNTUyOTY9PSg2NDUxMiYoYT10LmNoYXJDb2RlQXQocikpKSYmcisxPG8mJjU2MzIwPT0oNjQ1MTImKGk9dC5jaGFyQ29kZUF0KHIrMSkpKSYmKGE9NjU1MzYrKGEtNTUyOTY8PDEwKSsoaS01NjMyMCkscisrKSxsKz1hPDEyOD8xOmE8MjA0OD8yOmE8NjU1MzY/Mzo0O2ZvcihlPW5ldyBuLkJ1ZjgobCkscz0wLHI9MDtzPGw7cisrKTU1Mjk2PT0oNjQ1MTImKGE9dC5jaGFyQ29kZUF0KHIpKSkmJnIrMTxvJiY1NjMyMD09KDY0NTEyJihpPXQuY2hhckNvZGVBdChyKzEpKSkmJihhPTY1NTM2KyhhLTU1Mjk2PDwxMCkrKGktNTYzMjApLHIrKyksYTwxMjg/ZVtzKytdPWE6YTwyMDQ4PyhlW3MrK109MTkyfGE+Pj42LGVbcysrXT0xMjh8NjMmYSk6YTw2NTUzNj8oZVtzKytdPTIyNHxhPj4+MTIsZVtzKytdPTEyOHxhPj4+NiY2MyxlW3MrK109MTI4fDYzJmEpOihlW3MrK109MjQwfGE+Pj4xOCxlW3MrK109MTI4fGE+Pj4xMiY2MyxlW3MrK109MTI4fGE+Pj42JjYzLGVbcysrXT0xMjh8NjMmYSk7cmV0dXJuIGV9LGEuYnVmMmJpbnN0cmluZz1mdW5jdGlvbih0KXtyZXR1cm4gaSh0LHQubGVuZ3RoKX0sYS5iaW5zdHJpbmcyYnVmPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgbi5CdWY4KHQubGVuZ3RoKSxhPTAsaT1lLmxlbmd0aDthPGk7YSsrKWVbYV09dC5jaGFyQ29kZUF0KGEpO3JldHVybiBlfSxhLmJ1ZjJzdHJpbmc9ZnVuY3Rpb24odCxlKXt2YXIgYSxuLHIscyxsPWV8fHQubGVuZ3RoLGg9bmV3IEFycmF5KDIqbCk7Zm9yKG49MCxhPTA7YTxsOylpZigocj10W2ErK10pPDEyOCloW24rK109cjtlbHNlIGlmKChzPW9bcl0pPjQpaFtuKytdPTY1NTMzLGErPXMtMTtlbHNle2ZvcihyJj0yPT09cz8zMTozPT09cz8xNTo3O3M+MSYmYTxsOylyPXI8PDZ8NjMmdFthKytdLHMtLTtzPjE/aFtuKytdPTY1NTMzOnI8NjU1MzY/aFtuKytdPXI6KHItPTY1NTM2LGhbbisrXT01NTI5NnxyPj4xMCYxMDIzLGhbbisrXT01NjMyMHwxMDIzJnIpfXJldHVybiBpKGgsbil9LGEudXRmOGJvcmRlcj1mdW5jdGlvbih0LGUpe3ZhciBhO2ZvcigoZT1lfHx0Lmxlbmd0aCk+dC5sZW5ndGgmJihlPXQubGVuZ3RoKSxhPWUtMTthPj0wJiYxMjg9PSgxOTImdFthXSk7KWEtLTtyZXR1cm4gYTwwP2U6MD09PWE/ZTphK29bdFthXV0+ZT9hOmV9fSx7XCIuL2NvbW1vblwiOjN9XSw1OltmdW5jdGlvbih0LGUsYSl7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKHQsZSxhLGkpe2Zvcih2YXIgbj02NTUzNSZ0fDAscj10Pj4+MTYmNjU1MzV8MCxzPTA7MCE9PWE7KXthLT1zPWE+MmUzPzJlMzphO2Rve3I9cisobj1uK2VbaSsrXXwwKXwwfXdoaWxlKC0tcyk7biU9NjU1MjEsciU9NjU1MjF9cmV0dXJuIG58cjw8MTZ8MH19LHt9XSw2OltmdW5jdGlvbih0LGUsYSl7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXtaX05PX0ZMVVNIOjAsWl9QQVJUSUFMX0ZMVVNIOjEsWl9TWU5DX0ZMVVNIOjIsWl9GVUxMX0ZMVVNIOjMsWl9GSU5JU0g6NCxaX0JMT0NLOjUsWl9UUkVFUzo2LFpfT0s6MCxaX1NUUkVBTV9FTkQ6MSxaX05FRURfRElDVDoyLFpfRVJSTk86LTEsWl9TVFJFQU1fRVJST1I6LTIsWl9EQVRBX0VSUk9SOi0zLFpfQlVGX0VSUk9SOi01LFpfTk9fQ09NUFJFU1NJT046MCxaX0JFU1RfU1BFRUQ6MSxaX0JFU1RfQ09NUFJFU1NJT046OSxaX0RFRkFVTFRfQ09NUFJFU1NJT046LTEsWl9GSUxURVJFRDoxLFpfSFVGRk1BTl9PTkxZOjIsWl9STEU6MyxaX0ZJWEVEOjQsWl9ERUZBVUxUX1NUUkFURUdZOjAsWl9CSU5BUlk6MCxaX1RFWFQ6MSxaX1VOS05PV046MixaX0RFRkxBVEVEOjh9fSx7fV0sNzpbZnVuY3Rpb24odCxlLGEpe1widXNlIHN0cmljdFwiO3ZhciBpPWZ1bmN0aW9uKCl7Zm9yKHZhciB0LGU9W10sYT0wO2E8MjU2O2ErKyl7dD1hO2Zvcih2YXIgaT0wO2k8ODtpKyspdD0xJnQ/Mzk4ODI5MjM4NF50Pj4+MTp0Pj4+MTtlW2FdPXR9cmV0dXJuIGV9KCk7ZS5leHBvcnRzPWZ1bmN0aW9uKHQsZSxhLG4pe3ZhciByPWkscz1uK2E7dF49LTE7Zm9yKHZhciBvPW47bzxzO28rKyl0PXQ+Pj44XnJbMjU1Jih0XmVbb10pXTtyZXR1cm4tMV50fX0se31dLDg6W2Z1bmN0aW9uKHQsZSxhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKHQsZSl7cmV0dXJuIHQubXNnPUFbZV0sZX1mdW5jdGlvbiBuKHQpe3JldHVybih0PDwxKS0odD40Pzk6MCl9ZnVuY3Rpb24gcih0KXtmb3IodmFyIGU9dC5sZW5ndGg7LS1lPj0wOyl0W2VdPTB9ZnVuY3Rpb24gcyh0KXt2YXIgZT10LnN0YXRlLGE9ZS5wZW5kaW5nO2E+dC5hdmFpbF9vdXQmJihhPXQuYXZhaWxfb3V0KSwwIT09YSYmKHouYXJyYXlTZXQodC5vdXRwdXQsZS5wZW5kaW5nX2J1ZixlLnBlbmRpbmdfb3V0LGEsdC5uZXh0X291dCksdC5uZXh0X291dCs9YSxlLnBlbmRpbmdfb3V0Kz1hLHQudG90YWxfb3V0Kz1hLHQuYXZhaWxfb3V0LT1hLGUucGVuZGluZy09YSwwPT09ZS5wZW5kaW5nJiYoZS5wZW5kaW5nX291dD0wKSl9ZnVuY3Rpb24gbyh0LGUpe0IuX3RyX2ZsdXNoX2Jsb2NrKHQsdC5ibG9ja19zdGFydD49MD90LmJsb2NrX3N0YXJ0Oi0xLHQuc3Ryc3RhcnQtdC5ibG9ja19zdGFydCxlKSx0LmJsb2NrX3N0YXJ0PXQuc3Ryc3RhcnQscyh0LnN0cm0pfWZ1bmN0aW9uIGwodCxlKXt0LnBlbmRpbmdfYnVmW3QucGVuZGluZysrXT1lfWZ1bmN0aW9uIGgodCxlKXt0LnBlbmRpbmdfYnVmW3QucGVuZGluZysrXT1lPj4+OCYyNTUsdC5wZW5kaW5nX2J1Zlt0LnBlbmRpbmcrK109MjU1JmV9ZnVuY3Rpb24gZCh0LGUsYSxpKXt2YXIgbj10LmF2YWlsX2luO3JldHVybiBuPmkmJihuPWkpLDA9PT1uPzA6KHQuYXZhaWxfaW4tPW4sei5hcnJheVNldChlLHQuaW5wdXQsdC5uZXh0X2luLG4sYSksMT09PXQuc3RhdGUud3JhcD90LmFkbGVyPVModC5hZGxlcixlLG4sYSk6Mj09PXQuc3RhdGUud3JhcCYmKHQuYWRsZXI9RSh0LmFkbGVyLGUsbixhKSksdC5uZXh0X2luKz1uLHQudG90YWxfaW4rPW4sbil9ZnVuY3Rpb24gZih0LGUpe3ZhciBhLGksbj10Lm1heF9jaGFpbl9sZW5ndGgscj10LnN0cnN0YXJ0LHM9dC5wcmV2X2xlbmd0aCxvPXQubmljZV9tYXRjaCxsPXQuc3Ryc3RhcnQ+dC53X3NpemUtaXQ/dC5zdHJzdGFydC0odC53X3NpemUtaXQpOjAsaD10LndpbmRvdyxkPXQud19tYXNrLGY9dC5wcmV2LF89dC5zdHJzdGFydCthdCx1PWhbcitzLTFdLGM9aFtyK3NdO3QucHJldl9sZW5ndGg+PXQuZ29vZF9tYXRjaCYmKG4+Pj0yKSxvPnQubG9va2FoZWFkJiYobz10Lmxvb2thaGVhZCk7ZG97aWYoYT1lLGhbYStzXT09PWMmJmhbYStzLTFdPT09dSYmaFthXT09PWhbcl0mJmhbKythXT09PWhbcisxXSl7cis9MixhKys7ZG97fXdoaWxlKGhbKytyXT09PWhbKythXSYmaFsrK3JdPT09aFsrK2FdJiZoWysrcl09PT1oWysrYV0mJmhbKytyXT09PWhbKythXSYmaFsrK3JdPT09aFsrK2FdJiZoWysrcl09PT1oWysrYV0mJmhbKytyXT09PWhbKythXSYmaFsrK3JdPT09aFsrK2FdJiZyPF8pO2lmKGk9YXQtKF8tcikscj1fLWF0LGk+cyl7aWYodC5tYXRjaF9zdGFydD1lLHM9aSxpPj1vKWJyZWFrO3U9aFtyK3MtMV0sYz1oW3Irc119fX13aGlsZSgoZT1mW2UmZF0pPmwmJjAhPS0tbik7cmV0dXJuIHM8PXQubG9va2FoZWFkP3M6dC5sb29rYWhlYWR9ZnVuY3Rpb24gXyh0KXt2YXIgZSxhLGksbixyLHM9dC53X3NpemU7ZG97aWYobj10LndpbmRvd19zaXplLXQubG9va2FoZWFkLXQuc3Ryc3RhcnQsdC5zdHJzdGFydD49cysocy1pdCkpe3ouYXJyYXlTZXQodC53aW5kb3csdC53aW5kb3cscyxzLDApLHQubWF0Y2hfc3RhcnQtPXMsdC5zdHJzdGFydC09cyx0LmJsb2NrX3N0YXJ0LT1zLGU9YT10Lmhhc2hfc2l6ZTtkb3tpPXQuaGVhZFstLWVdLHQuaGVhZFtlXT1pPj1zP2ktczowfXdoaWxlKC0tYSk7ZT1hPXM7ZG97aT10LnByZXZbLS1lXSx0LnByZXZbZV09aT49cz9pLXM6MH13aGlsZSgtLWEpO24rPXN9aWYoMD09PXQuc3RybS5hdmFpbF9pbilicmVhaztpZihhPWQodC5zdHJtLHQud2luZG93LHQuc3Ryc3RhcnQrdC5sb29rYWhlYWQsbiksdC5sb29rYWhlYWQrPWEsdC5sb29rYWhlYWQrdC5pbnNlcnQ+PWV0KWZvcihyPXQuc3Ryc3RhcnQtdC5pbnNlcnQsdC5pbnNfaD10LndpbmRvd1tyXSx0Lmluc19oPSh0Lmluc19oPDx0Lmhhc2hfc2hpZnRedC53aW5kb3dbcisxXSkmdC5oYXNoX21hc2s7dC5pbnNlcnQmJih0Lmluc19oPSh0Lmluc19oPDx0Lmhhc2hfc2hpZnRedC53aW5kb3dbcitldC0xXSkmdC5oYXNoX21hc2ssdC5wcmV2W3ImdC53X21hc2tdPXQuaGVhZFt0Lmluc19oXSx0LmhlYWRbdC5pbnNfaF09cixyKyssdC5pbnNlcnQtLSwhKHQubG9va2FoZWFkK3QuaW5zZXJ0PGV0KSk7KTt9d2hpbGUodC5sb29rYWhlYWQ8aXQmJjAhPT10LnN0cm0uYXZhaWxfaW4pfWZ1bmN0aW9uIHUodCxlKXtmb3IodmFyIGEsaTs7KXtpZih0Lmxvb2thaGVhZDxpdCl7aWYoXyh0KSx0Lmxvb2thaGVhZDxpdCYmZT09PVopcmV0dXJuIF90O2lmKDA9PT10Lmxvb2thaGVhZClicmVha31pZihhPTAsdC5sb29rYWhlYWQ+PWV0JiYodC5pbnNfaD0odC5pbnNfaDw8dC5oYXNoX3NoaWZ0XnQud2luZG93W3Quc3Ryc3RhcnQrZXQtMV0pJnQuaGFzaF9tYXNrLGE9dC5wcmV2W3Quc3Ryc3RhcnQmdC53X21hc2tdPXQuaGVhZFt0Lmluc19oXSx0LmhlYWRbdC5pbnNfaF09dC5zdHJzdGFydCksMCE9PWEmJnQuc3Ryc3RhcnQtYTw9dC53X3NpemUtaXQmJih0Lm1hdGNoX2xlbmd0aD1mKHQsYSkpLHQubWF0Y2hfbGVuZ3RoPj1ldClpZihpPUIuX3RyX3RhbGx5KHQsdC5zdHJzdGFydC10Lm1hdGNoX3N0YXJ0LHQubWF0Y2hfbGVuZ3RoLWV0KSx0Lmxvb2thaGVhZC09dC5tYXRjaF9sZW5ndGgsdC5tYXRjaF9sZW5ndGg8PXQubWF4X2xhenlfbWF0Y2gmJnQubG9va2FoZWFkPj1ldCl7dC5tYXRjaF9sZW5ndGgtLTtkb3t0LnN0cnN0YXJ0KyssdC5pbnNfaD0odC5pbnNfaDw8dC5oYXNoX3NoaWZ0XnQud2luZG93W3Quc3Ryc3RhcnQrZXQtMV0pJnQuaGFzaF9tYXNrLGE9dC5wcmV2W3Quc3Ryc3RhcnQmdC53X21hc2tdPXQuaGVhZFt0Lmluc19oXSx0LmhlYWRbdC5pbnNfaF09dC5zdHJzdGFydH13aGlsZSgwIT0tLXQubWF0Y2hfbGVuZ3RoKTt0LnN0cnN0YXJ0Kyt9ZWxzZSB0LnN0cnN0YXJ0Kz10Lm1hdGNoX2xlbmd0aCx0Lm1hdGNoX2xlbmd0aD0wLHQuaW5zX2g9dC53aW5kb3dbdC5zdHJzdGFydF0sdC5pbnNfaD0odC5pbnNfaDw8dC5oYXNoX3NoaWZ0XnQud2luZG93W3Quc3Ryc3RhcnQrMV0pJnQuaGFzaF9tYXNrO2Vsc2UgaT1CLl90cl90YWxseSh0LDAsdC53aW5kb3dbdC5zdHJzdGFydF0pLHQubG9va2FoZWFkLS0sdC5zdHJzdGFydCsrO2lmKGkmJihvKHQsITEpLDA9PT10LnN0cm0uYXZhaWxfb3V0KSlyZXR1cm4gX3R9cmV0dXJuIHQuaW5zZXJ0PXQuc3Ryc3RhcnQ8ZXQtMT90LnN0cnN0YXJ0OmV0LTEsZT09PU4/KG8odCwhMCksMD09PXQuc3RybS5hdmFpbF9vdXQ/Y3Q6YnQpOnQubGFzdF9saXQmJihvKHQsITEpLDA9PT10LnN0cm0uYXZhaWxfb3V0KT9fdDp1dH1mdW5jdGlvbiBjKHQsZSl7Zm9yKHZhciBhLGksbjs7KXtpZih0Lmxvb2thaGVhZDxpdCl7aWYoXyh0KSx0Lmxvb2thaGVhZDxpdCYmZT09PVopcmV0dXJuIF90O2lmKDA9PT10Lmxvb2thaGVhZClicmVha31pZihhPTAsdC5sb29rYWhlYWQ+PWV0JiYodC5pbnNfaD0odC5pbnNfaDw8dC5oYXNoX3NoaWZ0XnQud2luZG93W3Quc3Ryc3RhcnQrZXQtMV0pJnQuaGFzaF9tYXNrLGE9dC5wcmV2W3Quc3Ryc3RhcnQmdC53X21hc2tdPXQuaGVhZFt0Lmluc19oXSx0LmhlYWRbdC5pbnNfaF09dC5zdHJzdGFydCksdC5wcmV2X2xlbmd0aD10Lm1hdGNoX2xlbmd0aCx0LnByZXZfbWF0Y2g9dC5tYXRjaF9zdGFydCx0Lm1hdGNoX2xlbmd0aD1ldC0xLDAhPT1hJiZ0LnByZXZfbGVuZ3RoPHQubWF4X2xhenlfbWF0Y2gmJnQuc3Ryc3RhcnQtYTw9dC53X3NpemUtaXQmJih0Lm1hdGNoX2xlbmd0aD1mKHQsYSksdC5tYXRjaF9sZW5ndGg8PTUmJih0LnN0cmF0ZWd5PT09SHx8dC5tYXRjaF9sZW5ndGg9PT1ldCYmdC5zdHJzdGFydC10Lm1hdGNoX3N0YXJ0PjQwOTYpJiYodC5tYXRjaF9sZW5ndGg9ZXQtMSkpLHQucHJldl9sZW5ndGg+PWV0JiZ0Lm1hdGNoX2xlbmd0aDw9dC5wcmV2X2xlbmd0aCl7bj10LnN0cnN0YXJ0K3QubG9va2FoZWFkLWV0LGk9Qi5fdHJfdGFsbHkodCx0LnN0cnN0YXJ0LTEtdC5wcmV2X21hdGNoLHQucHJldl9sZW5ndGgtZXQpLHQubG9va2FoZWFkLT10LnByZXZfbGVuZ3RoLTEsdC5wcmV2X2xlbmd0aC09Mjtkb3srK3Quc3Ryc3RhcnQ8PW4mJih0Lmluc19oPSh0Lmluc19oPDx0Lmhhc2hfc2hpZnRedC53aW5kb3dbdC5zdHJzdGFydCtldC0xXSkmdC5oYXNoX21hc2ssYT10LnByZXZbdC5zdHJzdGFydCZ0LndfbWFza109dC5oZWFkW3QuaW5zX2hdLHQuaGVhZFt0Lmluc19oXT10LnN0cnN0YXJ0KX13aGlsZSgwIT0tLXQucHJldl9sZW5ndGgpO2lmKHQubWF0Y2hfYXZhaWxhYmxlPTAsdC5tYXRjaF9sZW5ndGg9ZXQtMSx0LnN0cnN0YXJ0KyssaSYmKG8odCwhMSksMD09PXQuc3RybS5hdmFpbF9vdXQpKXJldHVybiBfdH1lbHNlIGlmKHQubWF0Y2hfYXZhaWxhYmxlKXtpZigoaT1CLl90cl90YWxseSh0LDAsdC53aW5kb3dbdC5zdHJzdGFydC0xXSkpJiZvKHQsITEpLHQuc3Ryc3RhcnQrKyx0Lmxvb2thaGVhZC0tLDA9PT10LnN0cm0uYXZhaWxfb3V0KXJldHVybiBfdH1lbHNlIHQubWF0Y2hfYXZhaWxhYmxlPTEsdC5zdHJzdGFydCsrLHQubG9va2FoZWFkLS19cmV0dXJuIHQubWF0Y2hfYXZhaWxhYmxlJiYoaT1CLl90cl90YWxseSh0LDAsdC53aW5kb3dbdC5zdHJzdGFydC0xXSksdC5tYXRjaF9hdmFpbGFibGU9MCksdC5pbnNlcnQ9dC5zdHJzdGFydDxldC0xP3Quc3Ryc3RhcnQ6ZXQtMSxlPT09Tj8obyh0LCEwKSwwPT09dC5zdHJtLmF2YWlsX291dD9jdDpidCk6dC5sYXN0X2xpdCYmKG8odCwhMSksMD09PXQuc3RybS5hdmFpbF9vdXQpP190OnV0fWZ1bmN0aW9uIGIodCxlKXtmb3IodmFyIGEsaSxuLHIscz10LndpbmRvdzs7KXtpZih0Lmxvb2thaGVhZDw9YXQpe2lmKF8odCksdC5sb29rYWhlYWQ8PWF0JiZlPT09WilyZXR1cm4gX3Q7aWYoMD09PXQubG9va2FoZWFkKWJyZWFrfWlmKHQubWF0Y2hfbGVuZ3RoPTAsdC5sb29rYWhlYWQ+PWV0JiZ0LnN0cnN0YXJ0PjAmJihuPXQuc3Ryc3RhcnQtMSwoaT1zW25dKT09PXNbKytuXSYmaT09PXNbKytuXSYmaT09PXNbKytuXSkpe3I9dC5zdHJzdGFydCthdDtkb3t9d2hpbGUoaT09PXNbKytuXSYmaT09PXNbKytuXSYmaT09PXNbKytuXSYmaT09PXNbKytuXSYmaT09PXNbKytuXSYmaT09PXNbKytuXSYmaT09PXNbKytuXSYmaT09PXNbKytuXSYmbjxyKTt0Lm1hdGNoX2xlbmd0aD1hdC0oci1uKSx0Lm1hdGNoX2xlbmd0aD50Lmxvb2thaGVhZCYmKHQubWF0Y2hfbGVuZ3RoPXQubG9va2FoZWFkKX1pZih0Lm1hdGNoX2xlbmd0aD49ZXQ/KGE9Qi5fdHJfdGFsbHkodCwxLHQubWF0Y2hfbGVuZ3RoLWV0KSx0Lmxvb2thaGVhZC09dC5tYXRjaF9sZW5ndGgsdC5zdHJzdGFydCs9dC5tYXRjaF9sZW5ndGgsdC5tYXRjaF9sZW5ndGg9MCk6KGE9Qi5fdHJfdGFsbHkodCwwLHQud2luZG93W3Quc3Ryc3RhcnRdKSx0Lmxvb2thaGVhZC0tLHQuc3Ryc3RhcnQrKyksYSYmKG8odCwhMSksMD09PXQuc3RybS5hdmFpbF9vdXQpKXJldHVybiBfdH1yZXR1cm4gdC5pbnNlcnQ9MCxlPT09Tj8obyh0LCEwKSwwPT09dC5zdHJtLmF2YWlsX291dD9jdDpidCk6dC5sYXN0X2xpdCYmKG8odCwhMSksMD09PXQuc3RybS5hdmFpbF9vdXQpP190OnV0fWZ1bmN0aW9uIGcodCxlKXtmb3IodmFyIGE7Oyl7aWYoMD09PXQubG9va2FoZWFkJiYoXyh0KSwwPT09dC5sb29rYWhlYWQpKXtpZihlPT09WilyZXR1cm4gX3Q7YnJlYWt9aWYodC5tYXRjaF9sZW5ndGg9MCxhPUIuX3RyX3RhbGx5KHQsMCx0LndpbmRvd1t0LnN0cnN0YXJ0XSksdC5sb29rYWhlYWQtLSx0LnN0cnN0YXJ0KyssYSYmKG8odCwhMSksMD09PXQuc3RybS5hdmFpbF9vdXQpKXJldHVybiBfdH1yZXR1cm4gdC5pbnNlcnQ9MCxlPT09Tj8obyh0LCEwKSwwPT09dC5zdHJtLmF2YWlsX291dD9jdDpidCk6dC5sYXN0X2xpdCYmKG8odCwhMSksMD09PXQuc3RybS5hdmFpbF9vdXQpP190OnV0fWZ1bmN0aW9uIG0odCxlLGEsaSxuKXt0aGlzLmdvb2RfbGVuZ3RoPXQsdGhpcy5tYXhfbGF6eT1lLHRoaXMubmljZV9sZW5ndGg9YSx0aGlzLm1heF9jaGFpbj1pLHRoaXMuZnVuYz1ufWZ1bmN0aW9uIHcodCl7dC53aW5kb3dfc2l6ZT0yKnQud19zaXplLHIodC5oZWFkKSx0Lm1heF9sYXp5X21hdGNoPXhbdC5sZXZlbF0ubWF4X2xhenksdC5nb29kX21hdGNoPXhbdC5sZXZlbF0uZ29vZF9sZW5ndGgsdC5uaWNlX21hdGNoPXhbdC5sZXZlbF0ubmljZV9sZW5ndGgsdC5tYXhfY2hhaW5fbGVuZ3RoPXhbdC5sZXZlbF0ubWF4X2NoYWluLHQuc3Ryc3RhcnQ9MCx0LmJsb2NrX3N0YXJ0PTAsdC5sb29rYWhlYWQ9MCx0Lmluc2VydD0wLHQubWF0Y2hfbGVuZ3RoPXQucHJldl9sZW5ndGg9ZXQtMSx0Lm1hdGNoX2F2YWlsYWJsZT0wLHQuaW5zX2g9MH1mdW5jdGlvbiBwKCl7dGhpcy5zdHJtPW51bGwsdGhpcy5zdGF0dXM9MCx0aGlzLnBlbmRpbmdfYnVmPW51bGwsdGhpcy5wZW5kaW5nX2J1Zl9zaXplPTAsdGhpcy5wZW5kaW5nX291dD0wLHRoaXMucGVuZGluZz0wLHRoaXMud3JhcD0wLHRoaXMuZ3poZWFkPW51bGwsdGhpcy5nemluZGV4PTAsdGhpcy5tZXRob2Q9cSx0aGlzLmxhc3RfZmx1c2g9LTEsdGhpcy53X3NpemU9MCx0aGlzLndfYml0cz0wLHRoaXMud19tYXNrPTAsdGhpcy53aW5kb3c9bnVsbCx0aGlzLndpbmRvd19zaXplPTAsdGhpcy5wcmV2PW51bGwsdGhpcy5oZWFkPW51bGwsdGhpcy5pbnNfaD0wLHRoaXMuaGFzaF9zaXplPTAsdGhpcy5oYXNoX2JpdHM9MCx0aGlzLmhhc2hfbWFzaz0wLHRoaXMuaGFzaF9zaGlmdD0wLHRoaXMuYmxvY2tfc3RhcnQ9MCx0aGlzLm1hdGNoX2xlbmd0aD0wLHRoaXMucHJldl9tYXRjaD0wLHRoaXMubWF0Y2hfYXZhaWxhYmxlPTAsdGhpcy5zdHJzdGFydD0wLHRoaXMubWF0Y2hfc3RhcnQ9MCx0aGlzLmxvb2thaGVhZD0wLHRoaXMucHJldl9sZW5ndGg9MCx0aGlzLm1heF9jaGFpbl9sZW5ndGg9MCx0aGlzLm1heF9sYXp5X21hdGNoPTAsdGhpcy5sZXZlbD0wLHRoaXMuc3RyYXRlZ3k9MCx0aGlzLmdvb2RfbWF0Y2g9MCx0aGlzLm5pY2VfbWF0Y2g9MCx0aGlzLmR5bl9sdHJlZT1uZXcgei5CdWYxNigyKiQpLHRoaXMuZHluX2R0cmVlPW5ldyB6LkJ1ZjE2KDIqKDIqUSsxKSksdGhpcy5ibF90cmVlPW5ldyB6LkJ1ZjE2KDIqKDIqVisxKSkscih0aGlzLmR5bl9sdHJlZSkscih0aGlzLmR5bl9kdHJlZSkscih0aGlzLmJsX3RyZWUpLHRoaXMubF9kZXNjPW51bGwsdGhpcy5kX2Rlc2M9bnVsbCx0aGlzLmJsX2Rlc2M9bnVsbCx0aGlzLmJsX2NvdW50PW5ldyB6LkJ1ZjE2KHR0KzEpLHRoaXMuaGVhcD1uZXcgei5CdWYxNigyKkorMSkscih0aGlzLmhlYXApLHRoaXMuaGVhcF9sZW49MCx0aGlzLmhlYXBfbWF4PTAsdGhpcy5kZXB0aD1uZXcgei5CdWYxNigyKkorMSkscih0aGlzLmRlcHRoKSx0aGlzLmxfYnVmPTAsdGhpcy5saXRfYnVmc2l6ZT0wLHRoaXMubGFzdF9saXQ9MCx0aGlzLmRfYnVmPTAsdGhpcy5vcHRfbGVuPTAsdGhpcy5zdGF0aWNfbGVuPTAsdGhpcy5tYXRjaGVzPTAsdGhpcy5pbnNlcnQ9MCx0aGlzLmJpX2J1Zj0wLHRoaXMuYmlfdmFsaWQ9MH1mdW5jdGlvbiB2KHQpe3ZhciBlO3JldHVybiB0JiZ0LnN0YXRlPyh0LnRvdGFsX2luPXQudG90YWxfb3V0PTAsdC5kYXRhX3R5cGU9WSxlPXQuc3RhdGUsZS5wZW5kaW5nPTAsZS5wZW5kaW5nX291dD0wLGUud3JhcDwwJiYoZS53cmFwPS1lLndyYXApLGUuc3RhdHVzPWUud3JhcD9ydDpkdCx0LmFkbGVyPTI9PT1lLndyYXA/MDoxLGUubGFzdF9mbHVzaD1aLEIuX3RyX2luaXQoZSksRCk6aSh0LFUpfWZ1bmN0aW9uIGsodCl7dmFyIGU9dih0KTtyZXR1cm4gZT09PUQmJncodC5zdGF0ZSksZX1mdW5jdGlvbiB5KHQsZSxhLG4scixzKXtpZighdClyZXR1cm4gVTt2YXIgbz0xO2lmKGU9PT1MJiYoZT02KSxuPDA/KG89MCxuPS1uKTpuPjE1JiYobz0yLG4tPTE2KSxyPDF8fHI+R3x8YSE9PXF8fG48OHx8bj4xNXx8ZTwwfHxlPjl8fHM8MHx8cz5NKXJldHVybiBpKHQsVSk7OD09PW4mJihuPTkpO3ZhciBsPW5ldyBwO3JldHVybiB0LnN0YXRlPWwsbC5zdHJtPXQsbC53cmFwPW8sbC5nemhlYWQ9bnVsbCxsLndfYml0cz1uLGwud19zaXplPTE8PGwud19iaXRzLGwud19tYXNrPWwud19zaXplLTEsbC5oYXNoX2JpdHM9cis3LGwuaGFzaF9zaXplPTE8PGwuaGFzaF9iaXRzLGwuaGFzaF9tYXNrPWwuaGFzaF9zaXplLTEsbC5oYXNoX3NoaWZ0PX5+KChsLmhhc2hfYml0cytldC0xKS9ldCksbC53aW5kb3c9bmV3IHouQnVmOCgyKmwud19zaXplKSxsLmhlYWQ9bmV3IHouQnVmMTYobC5oYXNoX3NpemUpLGwucHJldj1uZXcgei5CdWYxNihsLndfc2l6ZSksbC5saXRfYnVmc2l6ZT0xPDxyKzYsbC5wZW5kaW5nX2J1Zl9zaXplPTQqbC5saXRfYnVmc2l6ZSxsLnBlbmRpbmdfYnVmPW5ldyB6LkJ1ZjgobC5wZW5kaW5nX2J1Zl9zaXplKSxsLmRfYnVmPTEqbC5saXRfYnVmc2l6ZSxsLmxfYnVmPTMqbC5saXRfYnVmc2l6ZSxsLmxldmVsPWUsbC5zdHJhdGVneT1zLGwubWV0aG9kPWEsayh0KX12YXIgeCx6PXQoXCIuLi91dGlscy9jb21tb25cIiksQj10KFwiLi90cmVlc1wiKSxTPXQoXCIuL2FkbGVyMzJcIiksRT10KFwiLi9jcmMzMlwiKSxBPXQoXCIuL21lc3NhZ2VzXCIpLFo9MCxSPTEsQz0zLE49NCxPPTUsRD0wLEk9MSxVPS0yLFQ9LTMsRj0tNSxMPS0xLEg9MSxqPTIsSz0zLE09NCxQPTAsWT0yLHE9OCxHPTksWD0xNSxXPTgsSj0yODYsUT0zMCxWPTE5LCQ9MipKKzEsdHQ9MTUsZXQ9MyxhdD0yNTgsaXQ9YXQrZXQrMSxudD0zMixydD00MixzdD02OSxvdD03MyxsdD05MSxodD0xMDMsZHQ9MTEzLGZ0PTY2NixfdD0xLHV0PTIsY3Q9MyxidD00LGd0PTM7eD1bbmV3IG0oMCwwLDAsMCxmdW5jdGlvbih0LGUpe3ZhciBhPTY1NTM1O2ZvcihhPnQucGVuZGluZ19idWZfc2l6ZS01JiYoYT10LnBlbmRpbmdfYnVmX3NpemUtNSk7Oyl7aWYodC5sb29rYWhlYWQ8PTEpe2lmKF8odCksMD09PXQubG9va2FoZWFkJiZlPT09WilyZXR1cm4gX3Q7aWYoMD09PXQubG9va2FoZWFkKWJyZWFrfXQuc3Ryc3RhcnQrPXQubG9va2FoZWFkLHQubG9va2FoZWFkPTA7dmFyIGk9dC5ibG9ja19zdGFydCthO2lmKCgwPT09dC5zdHJzdGFydHx8dC5zdHJzdGFydD49aSkmJih0Lmxvb2thaGVhZD10LnN0cnN0YXJ0LWksdC5zdHJzdGFydD1pLG8odCwhMSksMD09PXQuc3RybS5hdmFpbF9vdXQpKXJldHVybiBfdDtpZih0LnN0cnN0YXJ0LXQuYmxvY2tfc3RhcnQ+PXQud19zaXplLWl0JiYobyh0LCExKSwwPT09dC5zdHJtLmF2YWlsX291dCkpcmV0dXJuIF90fXJldHVybiB0Lmluc2VydD0wLGU9PT1OPyhvKHQsITApLDA9PT10LnN0cm0uYXZhaWxfb3V0P2N0OmJ0KToodC5zdHJzdGFydD50LmJsb2NrX3N0YXJ0JiYobyh0LCExKSx0LnN0cm0uYXZhaWxfb3V0KSxfdCl9KSxuZXcgbSg0LDQsOCw0LHUpLG5ldyBtKDQsNSwxNiw4LHUpLG5ldyBtKDQsNiwzMiwzMix1KSxuZXcgbSg0LDQsMTYsMTYsYyksbmV3IG0oOCwxNiwzMiwzMixjKSxuZXcgbSg4LDE2LDEyOCwxMjgsYyksbmV3IG0oOCwzMiwxMjgsMjU2LGMpLG5ldyBtKDMyLDEyOCwyNTgsMTAyNCxjKSxuZXcgbSgzMiwyNTgsMjU4LDQwOTYsYyldLGEuZGVmbGF0ZUluaXQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4geSh0LGUscSxYLFcsUCl9LGEuZGVmbGF0ZUluaXQyPXksYS5kZWZsYXRlUmVzZXQ9ayxhLmRlZmxhdGVSZXNldEtlZXA9dixhLmRlZmxhdGVTZXRIZWFkZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdCYmdC5zdGF0ZT8yIT09dC5zdGF0ZS53cmFwP1U6KHQuc3RhdGUuZ3poZWFkPWUsRCk6VX0sYS5kZWZsYXRlPWZ1bmN0aW9uKHQsZSl7dmFyIGEsbyxkLGY7aWYoIXR8fCF0LnN0YXRlfHxlPk98fGU8MClyZXR1cm4gdD9pKHQsVSk6VTtpZihvPXQuc3RhdGUsIXQub3V0cHV0fHwhdC5pbnB1dCYmMCE9PXQuYXZhaWxfaW58fG8uc3RhdHVzPT09ZnQmJmUhPT1OKXJldHVybiBpKHQsMD09PXQuYXZhaWxfb3V0P0Y6VSk7aWYoby5zdHJtPXQsYT1vLmxhc3RfZmx1c2gsby5sYXN0X2ZsdXNoPWUsby5zdGF0dXM9PT1ydClpZigyPT09by53cmFwKXQuYWRsZXI9MCxsKG8sMzEpLGwobywxMzkpLGwobyw4KSxvLmd6aGVhZD8obChvLChvLmd6aGVhZC50ZXh0PzE6MCkrKG8uZ3poZWFkLmhjcmM/MjowKSsoby5nemhlYWQuZXh0cmE/NDowKSsoby5nemhlYWQubmFtZT84OjApKyhvLmd6aGVhZC5jb21tZW50PzE2OjApKSxsKG8sMjU1Jm8uZ3poZWFkLnRpbWUpLGwobyxvLmd6aGVhZC50aW1lPj44JjI1NSksbChvLG8uZ3poZWFkLnRpbWU+PjE2JjI1NSksbChvLG8uZ3poZWFkLnRpbWU+PjI0JjI1NSksbChvLDk9PT1vLmxldmVsPzI6by5zdHJhdGVneT49anx8by5sZXZlbDwyPzQ6MCksbChvLDI1NSZvLmd6aGVhZC5vcyksby5nemhlYWQuZXh0cmEmJm8uZ3poZWFkLmV4dHJhLmxlbmd0aCYmKGwobywyNTUmby5nemhlYWQuZXh0cmEubGVuZ3RoKSxsKG8sby5nemhlYWQuZXh0cmEubGVuZ3RoPj44JjI1NSkpLG8uZ3poZWFkLmhjcmMmJih0LmFkbGVyPUUodC5hZGxlcixvLnBlbmRpbmdfYnVmLG8ucGVuZGluZywwKSksby5nemluZGV4PTAsby5zdGF0dXM9c3QpOihsKG8sMCksbChvLDApLGwobywwKSxsKG8sMCksbChvLDApLGwobyw5PT09by5sZXZlbD8yOm8uc3RyYXRlZ3k+PWp8fG8ubGV2ZWw8Mj80OjApLGwobyxndCksby5zdGF0dXM9ZHQpO2Vsc2V7dmFyIF89cSsoby53X2JpdHMtODw8NCk8PDg7X3w9KG8uc3RyYXRlZ3k+PWp8fG8ubGV2ZWw8Mj8wOm8ubGV2ZWw8Nj8xOjY9PT1vLmxldmVsPzI6Myk8PDYsMCE9PW8uc3Ryc3RhcnQmJihffD1udCksXys9MzEtXyUzMSxvLnN0YXR1cz1kdCxoKG8sXyksMCE9PW8uc3Ryc3RhcnQmJihoKG8sdC5hZGxlcj4+PjE2KSxoKG8sNjU1MzUmdC5hZGxlcikpLHQuYWRsZXI9MX1pZihvLnN0YXR1cz09PXN0KWlmKG8uZ3poZWFkLmV4dHJhKXtmb3IoZD1vLnBlbmRpbmc7by5nemluZGV4PCg2NTUzNSZvLmd6aGVhZC5leHRyYS5sZW5ndGgpJiYoby5wZW5kaW5nIT09by5wZW5kaW5nX2J1Zl9zaXplfHwoby5nemhlYWQuaGNyYyYmby5wZW5kaW5nPmQmJih0LmFkbGVyPUUodC5hZGxlcixvLnBlbmRpbmdfYnVmLG8ucGVuZGluZy1kLGQpKSxzKHQpLGQ9by5wZW5kaW5nLG8ucGVuZGluZyE9PW8ucGVuZGluZ19idWZfc2l6ZSkpOylsKG8sMjU1Jm8uZ3poZWFkLmV4dHJhW28uZ3ppbmRleF0pLG8uZ3ppbmRleCsrO28uZ3poZWFkLmhjcmMmJm8ucGVuZGluZz5kJiYodC5hZGxlcj1FKHQuYWRsZXIsby5wZW5kaW5nX2J1ZixvLnBlbmRpbmctZCxkKSksby5nemluZGV4PT09by5nemhlYWQuZXh0cmEubGVuZ3RoJiYoby5nemluZGV4PTAsby5zdGF0dXM9b3QpfWVsc2Ugby5zdGF0dXM9b3Q7aWYoby5zdGF0dXM9PT1vdClpZihvLmd6aGVhZC5uYW1lKXtkPW8ucGVuZGluZztkb3tpZihvLnBlbmRpbmc9PT1vLnBlbmRpbmdfYnVmX3NpemUmJihvLmd6aGVhZC5oY3JjJiZvLnBlbmRpbmc+ZCYmKHQuYWRsZXI9RSh0LmFkbGVyLG8ucGVuZGluZ19idWYsby5wZW5kaW5nLWQsZCkpLHModCksZD1vLnBlbmRpbmcsby5wZW5kaW5nPT09by5wZW5kaW5nX2J1Zl9zaXplKSl7Zj0xO2JyZWFrfWY9by5nemluZGV4PG8uZ3poZWFkLm5hbWUubGVuZ3RoPzI1NSZvLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQoby5nemluZGV4KyspOjAsbChvLGYpfXdoaWxlKDAhPT1mKTtvLmd6aGVhZC5oY3JjJiZvLnBlbmRpbmc+ZCYmKHQuYWRsZXI9RSh0LmFkbGVyLG8ucGVuZGluZ19idWYsby5wZW5kaW5nLWQsZCkpLDA9PT1mJiYoby5nemluZGV4PTAsby5zdGF0dXM9bHQpfWVsc2Ugby5zdGF0dXM9bHQ7aWYoby5zdGF0dXM9PT1sdClpZihvLmd6aGVhZC5jb21tZW50KXtkPW8ucGVuZGluZztkb3tpZihvLnBlbmRpbmc9PT1vLnBlbmRpbmdfYnVmX3NpemUmJihvLmd6aGVhZC5oY3JjJiZvLnBlbmRpbmc+ZCYmKHQuYWRsZXI9RSh0LmFkbGVyLG8ucGVuZGluZ19idWYsby5wZW5kaW5nLWQsZCkpLHModCksZD1vLnBlbmRpbmcsby5wZW5kaW5nPT09by5wZW5kaW5nX2J1Zl9zaXplKSl7Zj0xO2JyZWFrfWY9by5nemluZGV4PG8uZ3poZWFkLmNvbW1lbnQubGVuZ3RoPzI1NSZvLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQoby5nemluZGV4KyspOjAsbChvLGYpfXdoaWxlKDAhPT1mKTtvLmd6aGVhZC5oY3JjJiZvLnBlbmRpbmc+ZCYmKHQuYWRsZXI9RSh0LmFkbGVyLG8ucGVuZGluZ19idWYsby5wZW5kaW5nLWQsZCkpLDA9PT1mJiYoby5zdGF0dXM9aHQpfWVsc2Ugby5zdGF0dXM9aHQ7aWYoby5zdGF0dXM9PT1odCYmKG8uZ3poZWFkLmhjcmM/KG8ucGVuZGluZysyPm8ucGVuZGluZ19idWZfc2l6ZSYmcyh0KSxvLnBlbmRpbmcrMjw9by5wZW5kaW5nX2J1Zl9zaXplJiYobChvLDI1NSZ0LmFkbGVyKSxsKG8sdC5hZGxlcj4+OCYyNTUpLHQuYWRsZXI9MCxvLnN0YXR1cz1kdCkpOm8uc3RhdHVzPWR0KSwwIT09by5wZW5kaW5nKXtpZihzKHQpLDA9PT10LmF2YWlsX291dClyZXR1cm4gby5sYXN0X2ZsdXNoPS0xLER9ZWxzZSBpZigwPT09dC5hdmFpbF9pbiYmbihlKTw9bihhKSYmZSE9PU4pcmV0dXJuIGkodCxGKTtpZihvLnN0YXR1cz09PWZ0JiYwIT09dC5hdmFpbF9pbilyZXR1cm4gaSh0LEYpO2lmKDAhPT10LmF2YWlsX2lufHwwIT09by5sb29rYWhlYWR8fGUhPT1aJiZvLnN0YXR1cyE9PWZ0KXt2YXIgdT1vLnN0cmF0ZWd5PT09aj9nKG8sZSk6by5zdHJhdGVneT09PUs/YihvLGUpOnhbby5sZXZlbF0uZnVuYyhvLGUpO2lmKHUhPT1jdCYmdSE9PWJ0fHwoby5zdGF0dXM9ZnQpLHU9PT1fdHx8dT09PWN0KXJldHVybiAwPT09dC5hdmFpbF9vdXQmJihvLmxhc3RfZmx1c2g9LTEpLEQ7aWYodT09PXV0JiYoZT09PVI/Qi5fdHJfYWxpZ24obyk6ZSE9PU8mJihCLl90cl9zdG9yZWRfYmxvY2sobywwLDAsITEpLGU9PT1DJiYocihvLmhlYWQpLDA9PT1vLmxvb2thaGVhZCYmKG8uc3Ryc3RhcnQ9MCxvLmJsb2NrX3N0YXJ0PTAsby5pbnNlcnQ9MCkpKSxzKHQpLDA9PT10LmF2YWlsX291dCkpcmV0dXJuIG8ubGFzdF9mbHVzaD0tMSxEfXJldHVybiBlIT09Tj9EOm8ud3JhcDw9MD9JOigyPT09by53cmFwPyhsKG8sMjU1JnQuYWRsZXIpLGwobyx0LmFkbGVyPj44JjI1NSksbChvLHQuYWRsZXI+PjE2JjI1NSksbChvLHQuYWRsZXI+PjI0JjI1NSksbChvLDI1NSZ0LnRvdGFsX2luKSxsKG8sdC50b3RhbF9pbj4+OCYyNTUpLGwobyx0LnRvdGFsX2luPj4xNiYyNTUpLGwobyx0LnRvdGFsX2luPj4yNCYyNTUpKTooaChvLHQuYWRsZXI+Pj4xNiksaChvLDY1NTM1JnQuYWRsZXIpKSxzKHQpLG8ud3JhcD4wJiYoby53cmFwPS1vLndyYXApLDAhPT1vLnBlbmRpbmc/RDpJKX0sYS5kZWZsYXRlRW5kPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiB0JiZ0LnN0YXRlPyhlPXQuc3RhdGUuc3RhdHVzKSE9PXJ0JiZlIT09c3QmJmUhPT1vdCYmZSE9PWx0JiZlIT09aHQmJmUhPT1kdCYmZSE9PWZ0P2kodCxVKToodC5zdGF0ZT1udWxsLGU9PT1kdD9pKHQsVCk6RCk6VX0sYS5kZWZsYXRlU2V0RGljdGlvbmFyeT1mdW5jdGlvbih0LGUpe3ZhciBhLGksbixzLG8sbCxoLGQsZj1lLmxlbmd0aDtpZighdHx8IXQuc3RhdGUpcmV0dXJuIFU7aWYoYT10LnN0YXRlLDI9PT0ocz1hLndyYXApfHwxPT09cyYmYS5zdGF0dXMhPT1ydHx8YS5sb29rYWhlYWQpcmV0dXJuIFU7Zm9yKDE9PT1zJiYodC5hZGxlcj1TKHQuYWRsZXIsZSxmLDApKSxhLndyYXA9MCxmPj1hLndfc2l6ZSYmKDA9PT1zJiYocihhLmhlYWQpLGEuc3Ryc3RhcnQ9MCxhLmJsb2NrX3N0YXJ0PTAsYS5pbnNlcnQ9MCksZD1uZXcgei5CdWY4KGEud19zaXplKSx6LmFycmF5U2V0KGQsZSxmLWEud19zaXplLGEud19zaXplLDApLGU9ZCxmPWEud19zaXplKSxvPXQuYXZhaWxfaW4sbD10Lm5leHRfaW4saD10LmlucHV0LHQuYXZhaWxfaW49Zix0Lm5leHRfaW49MCx0LmlucHV0PWUsXyhhKTthLmxvb2thaGVhZD49ZXQ7KXtpPWEuc3Ryc3RhcnQsbj1hLmxvb2thaGVhZC0oZXQtMSk7ZG97YS5pbnNfaD0oYS5pbnNfaDw8YS5oYXNoX3NoaWZ0XmEud2luZG93W2krZXQtMV0pJmEuaGFzaF9tYXNrLGEucHJldltpJmEud19tYXNrXT1hLmhlYWRbYS5pbnNfaF0sYS5oZWFkW2EuaW5zX2hdPWksaSsrfXdoaWxlKC0tbik7YS5zdHJzdGFydD1pLGEubG9va2FoZWFkPWV0LTEsXyhhKX1yZXR1cm4gYS5zdHJzdGFydCs9YS5sb29rYWhlYWQsYS5ibG9ja19zdGFydD1hLnN0cnN0YXJ0LGEuaW5zZXJ0PWEubG9va2FoZWFkLGEubG9va2FoZWFkPTAsYS5tYXRjaF9sZW5ndGg9YS5wcmV2X2xlbmd0aD1ldC0xLGEubWF0Y2hfYXZhaWxhYmxlPTAsdC5uZXh0X2luPWwsdC5pbnB1dD1oLHQuYXZhaWxfaW49byxhLndyYXA9cyxEfSxhLmRlZmxhdGVJbmZvPVwicGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KVwifSx7XCIuLi91dGlscy9jb21tb25cIjozLFwiLi9hZGxlcjMyXCI6NSxcIi4vY3JjMzJcIjo3LFwiLi9tZXNzYWdlc1wiOjEzLFwiLi90cmVlc1wiOjE0fV0sOTpbZnVuY3Rpb24odCxlLGEpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbigpe3RoaXMudGV4dD0wLHRoaXMudGltZT0wLHRoaXMueGZsYWdzPTAsdGhpcy5vcz0wLHRoaXMuZXh0cmE9bnVsbCx0aGlzLmV4dHJhX2xlbj0wLHRoaXMubmFtZT1cIlwiLHRoaXMuY29tbWVudD1cIlwiLHRoaXMuaGNyYz0wLHRoaXMuZG9uZT0hMX19LHt9XSwxMDpbZnVuY3Rpb24odCxlLGEpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciBhLGksbixyLHMsbyxsLGgsZCxmLF8sdSxjLGIsZyxtLHcscCx2LGsseSx4LHosQixTO2E9dC5zdGF0ZSxpPXQubmV4dF9pbixCPXQuaW5wdXQsbj1pKyh0LmF2YWlsX2luLTUpLHI9dC5uZXh0X291dCxTPXQub3V0cHV0LHM9ci0oZS10LmF2YWlsX291dCksbz1yKyh0LmF2YWlsX291dC0yNTcpLGw9YS5kbWF4LGg9YS53c2l6ZSxkPWEud2hhdmUsZj1hLnduZXh0LF89YS53aW5kb3csdT1hLmhvbGQsYz1hLmJpdHMsYj1hLmxlbmNvZGUsZz1hLmRpc3Rjb2RlLG09KDE8PGEubGVuYml0cyktMSx3PSgxPDxhLmRpc3RiaXRzKS0xO3Q6ZG97YzwxNSYmKHUrPUJbaSsrXTw8YyxjKz04LHUrPUJbaSsrXTw8YyxjKz04KSxwPWJbdSZtXTtlOmZvcig7Oyl7aWYodj1wPj4+MjQsdT4+Pj12LGMtPXYsMD09PSh2PXA+Pj4xNiYyNTUpKVNbcisrXT02NTUzNSZwO2Vsc2V7aWYoISgxNiZ2KSl7aWYoMD09KDY0JnYpKXtwPWJbKDY1NTM1JnApKyh1JigxPDx2KS0xKV07Y29udGludWUgZX1pZigzMiZ2KXthLm1vZGU9MTI7YnJlYWsgdH10Lm1zZz1cImludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZVwiLGEubW9kZT0zMDticmVhayB0fWs9NjU1MzUmcCwodiY9MTUpJiYoYzx2JiYodSs9QltpKytdPDxjLGMrPTgpLGsrPXUmKDE8PHYpLTEsdT4+Pj12LGMtPXYpLGM8MTUmJih1Kz1CW2krK108PGMsYys9OCx1Kz1CW2krK108PGMsYys9OCkscD1nW3Umd107YTpmb3IoOzspe2lmKHY9cD4+PjI0LHU+Pj49dixjLT12LCEoMTYmKHY9cD4+PjE2JjI1NSkpKXtpZigwPT0oNjQmdikpe3A9Z1soNjU1MzUmcCkrKHUmKDE8PHYpLTEpXTtjb250aW51ZSBhfXQubXNnPVwiaW52YWxpZCBkaXN0YW5jZSBjb2RlXCIsYS5tb2RlPTMwO2JyZWFrIHR9aWYoeT02NTUzNSZwLHYmPTE1LGM8diYmKHUrPUJbaSsrXTw8YywoYys9OCk8diYmKHUrPUJbaSsrXTw8YyxjKz04KSksKHkrPXUmKDE8PHYpLTEpPmwpe3QubXNnPVwiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2tcIixhLm1vZGU9MzA7YnJlYWsgdH1pZih1Pj4+PXYsYy09dix2PXItcyx5PnYpe2lmKCh2PXktdik+ZCYmYS5zYW5lKXt0Lm1zZz1cImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrXCIsYS5tb2RlPTMwO2JyZWFrIHR9aWYoeD0wLHo9XywwPT09Zil7aWYoeCs9aC12LHY8ayl7ay09djtkb3tTW3IrK109X1t4KytdfXdoaWxlKC0tdik7eD1yLXksej1TfX1lbHNlIGlmKGY8dil7aWYoeCs9aCtmLXYsKHYtPWYpPGspe2stPXY7ZG97U1tyKytdPV9beCsrXX13aGlsZSgtLXYpO2lmKHg9MCxmPGspe2stPXY9Zjtkb3tTW3IrK109X1t4KytdfXdoaWxlKC0tdik7eD1yLXksej1TfX19ZWxzZSBpZih4Kz1mLXYsdjxrKXtrLT12O2Rve1NbcisrXT1fW3grK119d2hpbGUoLS12KTt4PXIteSx6PVN9Zm9yKDtrPjI7KVNbcisrXT16W3grK10sU1tyKytdPXpbeCsrXSxTW3IrK109elt4KytdLGstPTM7ayYmKFNbcisrXT16W3grK10saz4xJiYoU1tyKytdPXpbeCsrXSkpfWVsc2V7eD1yLXk7ZG97U1tyKytdPVNbeCsrXSxTW3IrK109U1t4KytdLFNbcisrXT1TW3grK10say09M313aGlsZShrPjIpO2smJihTW3IrK109U1t4KytdLGs+MSYmKFNbcisrXT1TW3grK10pKX1icmVha319YnJlYWt9fXdoaWxlKGk8biYmcjxvKTtpLT1rPWM+PjMsdSY9KDE8PChjLT1rPDwzKSktMSx0Lm5leHRfaW49aSx0Lm5leHRfb3V0PXIsdC5hdmFpbF9pbj1pPG4/bi1pKzU6NS0oaS1uKSx0LmF2YWlsX291dD1yPG8/by1yKzI1NzoyNTctKHItbyksYS5ob2xkPXUsYS5iaXRzPWN9fSx7fV0sMTE6W2Z1bmN0aW9uKHQsZSxhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKHQpe3JldHVybih0Pj4+MjQmMjU1KSsodD4+PjgmNjUyODApKygoNjUyODAmdCk8PDgpKygoMjU1JnQpPDwyNCl9ZnVuY3Rpb24gbigpe3RoaXMubW9kZT0wLHRoaXMubGFzdD0hMSx0aGlzLndyYXA9MCx0aGlzLmhhdmVkaWN0PSExLHRoaXMuZmxhZ3M9MCx0aGlzLmRtYXg9MCx0aGlzLmNoZWNrPTAsdGhpcy50b3RhbD0wLHRoaXMuaGVhZD1udWxsLHRoaXMud2JpdHM9MCx0aGlzLndzaXplPTAsdGhpcy53aGF2ZT0wLHRoaXMud25leHQ9MCx0aGlzLndpbmRvdz1udWxsLHRoaXMuaG9sZD0wLHRoaXMuYml0cz0wLHRoaXMubGVuZ3RoPTAsdGhpcy5vZmZzZXQ9MCx0aGlzLmV4dHJhPTAsdGhpcy5sZW5jb2RlPW51bGwsdGhpcy5kaXN0Y29kZT1udWxsLHRoaXMubGVuYml0cz0wLHRoaXMuZGlzdGJpdHM9MCx0aGlzLm5jb2RlPTAsdGhpcy5ubGVuPTAsdGhpcy5uZGlzdD0wLHRoaXMuaGF2ZT0wLHRoaXMubmV4dD1udWxsLHRoaXMubGVucz1uZXcgdS5CdWYxNigzMjApLHRoaXMud29yaz1uZXcgdS5CdWYxNigyODgpLHRoaXMubGVuZHluPW51bGwsdGhpcy5kaXN0ZHluPW51bGwsdGhpcy5zYW5lPTAsdGhpcy5iYWNrPTAsdGhpcy53YXM9MH1mdW5jdGlvbiByKHQpe3ZhciBlO3JldHVybiB0JiZ0LnN0YXRlPyhlPXQuc3RhdGUsdC50b3RhbF9pbj10LnRvdGFsX291dD1lLnRvdGFsPTAsdC5tc2c9XCJcIixlLndyYXAmJih0LmFkbGVyPTEmZS53cmFwKSxlLm1vZGU9TixlLmxhc3Q9MCxlLmhhdmVkaWN0PTAsZS5kbWF4PTMyNzY4LGUuaGVhZD1udWxsLGUuaG9sZD0wLGUuYml0cz0wLGUubGVuY29kZT1lLmxlbmR5bj1uZXcgdS5CdWYzMihkdCksZS5kaXN0Y29kZT1lLmRpc3RkeW49bmV3IHUuQnVmMzIoZnQpLGUuc2FuZT0xLGUuYmFjaz0tMSx6KTpFfWZ1bmN0aW9uIHModCl7dmFyIGU7cmV0dXJuIHQmJnQuc3RhdGU/KGU9dC5zdGF0ZSxlLndzaXplPTAsZS53aGF2ZT0wLGUud25leHQ9MCxyKHQpKTpFfWZ1bmN0aW9uIG8odCxlKXt2YXIgYSxpO3JldHVybiB0JiZ0LnN0YXRlPyhpPXQuc3RhdGUsZTwwPyhhPTAsZT0tZSk6KGE9MSsoZT4+NCksZTw0OCYmKGUmPTE1KSksZSYmKGU8OHx8ZT4xNSk/RToobnVsbCE9PWkud2luZG93JiZpLndiaXRzIT09ZSYmKGkud2luZG93PW51bGwpLGkud3JhcD1hLGkud2JpdHM9ZSxzKHQpKSk6RX1mdW5jdGlvbiBsKHQsZSl7dmFyIGEsaTtyZXR1cm4gdD8oaT1uZXcgbix0LnN0YXRlPWksaS53aW5kb3c9bnVsbCwoYT1vKHQsZSkpIT09eiYmKHQuc3RhdGU9bnVsbCksYSk6RX1mdW5jdGlvbiBoKHQpe2lmKHV0KXt2YXIgZTtmb3IoZj1uZXcgdS5CdWYzMig1MTIpLF89bmV3IHUuQnVmMzIoMzIpLGU9MDtlPDE0NDspdC5sZW5zW2UrK109ODtmb3IoO2U8MjU2Oyl0LmxlbnNbZSsrXT05O2Zvcig7ZTwyODA7KXQubGVuc1tlKytdPTc7Zm9yKDtlPDI4ODspdC5sZW5zW2UrK109ODtmb3IobShwLHQubGVucywwLDI4OCxmLDAsdC53b3JrLHtiaXRzOjl9KSxlPTA7ZTwzMjspdC5sZW5zW2UrK109NTttKHYsdC5sZW5zLDAsMzIsXywwLHQud29yayx7Yml0czo1fSksdXQ9ITF9dC5sZW5jb2RlPWYsdC5sZW5iaXRzPTksdC5kaXN0Y29kZT1fLHQuZGlzdGJpdHM9NX1mdW5jdGlvbiBkKHQsZSxhLGkpe3ZhciBuLHI9dC5zdGF0ZTtyZXR1cm4gbnVsbD09PXIud2luZG93JiYoci53c2l6ZT0xPDxyLndiaXRzLHIud25leHQ9MCxyLndoYXZlPTAsci53aW5kb3c9bmV3IHUuQnVmOChyLndzaXplKSksaT49ci53c2l6ZT8odS5hcnJheVNldChyLndpbmRvdyxlLGEtci53c2l6ZSxyLndzaXplLDApLHIud25leHQ9MCxyLndoYXZlPXIud3NpemUpOigobj1yLndzaXplLXIud25leHQpPmkmJihuPWkpLHUuYXJyYXlTZXQoci53aW5kb3csZSxhLWksbixyLnduZXh0KSwoaS09bik/KHUuYXJyYXlTZXQoci53aW5kb3csZSxhLWksaSwwKSxyLnduZXh0PWksci53aGF2ZT1yLndzaXplKTooci53bmV4dCs9bixyLnduZXh0PT09ci53c2l6ZSYmKHIud25leHQ9MCksci53aGF2ZTxyLndzaXplJiYoci53aGF2ZSs9bikpKSwwfXZhciBmLF8sdT10KFwiLi4vdXRpbHMvY29tbW9uXCIpLGM9dChcIi4vYWRsZXIzMlwiKSxiPXQoXCIuL2NyYzMyXCIpLGc9dChcIi4vaW5mZmFzdFwiKSxtPXQoXCIuL2luZnRyZWVzXCIpLHc9MCxwPTEsdj0yLGs9NCx5PTUseD02LHo9MCxCPTEsUz0yLEU9LTIsQT0tMyxaPS00LFI9LTUsQz04LE49MSxPPTIsRD0zLEk9NCxVPTUsVD02LEY9NyxMPTgsSD05LGo9MTAsSz0xMSxNPTEyLFA9MTMsWT0xNCxxPTE1LEc9MTYsWD0xNyxXPTE4LEo9MTksUT0yMCxWPTIxLCQ9MjIsdHQ9MjMsZXQ9MjQsYXQ9MjUsaXQ9MjYsbnQ9MjcscnQ9Mjgsc3Q9Mjksb3Q9MzAsbHQ9MzEsaHQ9MzIsZHQ9ODUyLGZ0PTU5MixfdD0xNSx1dD0hMDthLmluZmxhdGVSZXNldD1zLGEuaW5mbGF0ZVJlc2V0Mj1vLGEuaW5mbGF0ZVJlc2V0S2VlcD1yLGEuaW5mbGF0ZUluaXQ9ZnVuY3Rpb24odCl7cmV0dXJuIGwodCxfdCl9LGEuaW5mbGF0ZUluaXQyPWwsYS5pbmZsYXRlPWZ1bmN0aW9uKHQsZSl7dmFyIGEsbixyLHMsbyxsLGYsXyxkdCxmdCxfdCx1dCxjdCxidCxndCxtdCx3dCxwdCx2dCxrdCx5dCx4dCx6dCxCdCxTdD0wLEV0PW5ldyB1LkJ1ZjgoNCksQXQ9WzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdO2lmKCF0fHwhdC5zdGF0ZXx8IXQub3V0cHV0fHwhdC5pbnB1dCYmMCE9PXQuYXZhaWxfaW4pcmV0dXJuIEU7KGE9dC5zdGF0ZSkubW9kZT09PU0mJihhLm1vZGU9UCksbz10Lm5leHRfb3V0LHI9dC5vdXRwdXQsZj10LmF2YWlsX291dCxzPXQubmV4dF9pbixuPXQuaW5wdXQsbD10LmF2YWlsX2luLF89YS5ob2xkLGR0PWEuYml0cyxmdD1sLF90PWYseHQ9ejt0OmZvcig7Oylzd2l0Y2goYS5tb2RlKXtjYXNlIE46aWYoMD09PWEud3JhcCl7YS5tb2RlPVA7YnJlYWt9Zm9yKDtkdDwxNjspe2lmKDA9PT1sKWJyZWFrIHQ7bC0tLF8rPW5bcysrXTw8ZHQsZHQrPTh9aWYoMiZhLndyYXAmJjM1NjE1PT09Xyl7YS5jaGVjaz0wLEV0WzBdPTI1NSZfLEV0WzFdPV8+Pj44JjI1NSxhLmNoZWNrPWIoYS5jaGVjayxFdCwyLDApLF89MCxkdD0wLGEubW9kZT1PO2JyZWFrfWlmKGEuZmxhZ3M9MCxhLmhlYWQmJihhLmhlYWQuZG9uZT0hMSksISgxJmEud3JhcCl8fCgoKDI1NSZfKTw8OCkrKF8+PjgpKSUzMSl7dC5tc2c9XCJpbmNvcnJlY3QgaGVhZGVyIGNoZWNrXCIsYS5tb2RlPW90O2JyZWFrfWlmKCgxNSZfKSE9PUMpe3QubXNnPVwidW5rbm93biBjb21wcmVzc2lvbiBtZXRob2RcIixhLm1vZGU9b3Q7YnJlYWt9aWYoXz4+Pj00LGR0LT00LHl0PTgrKDE1Jl8pLDA9PT1hLndiaXRzKWEud2JpdHM9eXQ7ZWxzZSBpZih5dD5hLndiaXRzKXt0Lm1zZz1cImludmFsaWQgd2luZG93IHNpemVcIixhLm1vZGU9b3Q7YnJlYWt9YS5kbWF4PTE8PHl0LHQuYWRsZXI9YS5jaGVjaz0xLGEubW9kZT01MTImXz9qOk0sXz0wLGR0PTA7YnJlYWs7Y2FzZSBPOmZvcig7ZHQ8MTY7KXtpZigwPT09bClicmVhayB0O2wtLSxfKz1uW3MrK108PGR0LGR0Kz04fWlmKGEuZmxhZ3M9XywoMjU1JmEuZmxhZ3MpIT09Qyl7dC5tc2c9XCJ1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZFwiLGEubW9kZT1vdDticmVha31pZig1NzM0NCZhLmZsYWdzKXt0Lm1zZz1cInVua25vd24gaGVhZGVyIGZsYWdzIHNldFwiLGEubW9kZT1vdDticmVha31hLmhlYWQmJihhLmhlYWQudGV4dD1fPj44JjEpLDUxMiZhLmZsYWdzJiYoRXRbMF09MjU1Jl8sRXRbMV09Xz4+PjgmMjU1LGEuY2hlY2s9YihhLmNoZWNrLEV0LDIsMCkpLF89MCxkdD0wLGEubW9kZT1EO2Nhc2UgRDpmb3IoO2R0PDMyOyl7aWYoMD09PWwpYnJlYWsgdDtsLS0sXys9bltzKytdPDxkdCxkdCs9OH1hLmhlYWQmJihhLmhlYWQudGltZT1fKSw1MTImYS5mbGFncyYmKEV0WzBdPTI1NSZfLEV0WzFdPV8+Pj44JjI1NSxFdFsyXT1fPj4+MTYmMjU1LEV0WzNdPV8+Pj4yNCYyNTUsYS5jaGVjaz1iKGEuY2hlY2ssRXQsNCwwKSksXz0wLGR0PTAsYS5tb2RlPUk7Y2FzZSBJOmZvcig7ZHQ8MTY7KXtpZigwPT09bClicmVhayB0O2wtLSxfKz1uW3MrK108PGR0LGR0Kz04fWEuaGVhZCYmKGEuaGVhZC54ZmxhZ3M9MjU1Jl8sYS5oZWFkLm9zPV8+PjgpLDUxMiZhLmZsYWdzJiYoRXRbMF09MjU1Jl8sRXRbMV09Xz4+PjgmMjU1LGEuY2hlY2s9YihhLmNoZWNrLEV0LDIsMCkpLF89MCxkdD0wLGEubW9kZT1VO2Nhc2UgVTppZigxMDI0JmEuZmxhZ3Mpe2Zvcig7ZHQ8MTY7KXtpZigwPT09bClicmVhayB0O2wtLSxfKz1uW3MrK108PGR0LGR0Kz04fWEubGVuZ3RoPV8sYS5oZWFkJiYoYS5oZWFkLmV4dHJhX2xlbj1fKSw1MTImYS5mbGFncyYmKEV0WzBdPTI1NSZfLEV0WzFdPV8+Pj44JjI1NSxhLmNoZWNrPWIoYS5jaGVjayxFdCwyLDApKSxfPTAsZHQ9MH1lbHNlIGEuaGVhZCYmKGEuaGVhZC5leHRyYT1udWxsKTthLm1vZGU9VDtjYXNlIFQ6aWYoMTAyNCZhLmZsYWdzJiYoKHV0PWEubGVuZ3RoKT5sJiYodXQ9bCksdXQmJihhLmhlYWQmJih5dD1hLmhlYWQuZXh0cmFfbGVuLWEubGVuZ3RoLGEuaGVhZC5leHRyYXx8KGEuaGVhZC5leHRyYT1uZXcgQXJyYXkoYS5oZWFkLmV4dHJhX2xlbikpLHUuYXJyYXlTZXQoYS5oZWFkLmV4dHJhLG4scyx1dCx5dCkpLDUxMiZhLmZsYWdzJiYoYS5jaGVjaz1iKGEuY2hlY2ssbix1dCxzKSksbC09dXQscys9dXQsYS5sZW5ndGgtPXV0KSxhLmxlbmd0aCkpYnJlYWsgdDthLmxlbmd0aD0wLGEubW9kZT1GO2Nhc2UgRjppZigyMDQ4JmEuZmxhZ3Mpe2lmKDA9PT1sKWJyZWFrIHQ7dXQ9MDtkb3t5dD1uW3MrdXQrK10sYS5oZWFkJiZ5dCYmYS5sZW5ndGg8NjU1MzYmJihhLmhlYWQubmFtZSs9U3RyaW5nLmZyb21DaGFyQ29kZSh5dCkpfXdoaWxlKHl0JiZ1dDxsKTtpZig1MTImYS5mbGFncyYmKGEuY2hlY2s9YihhLmNoZWNrLG4sdXQscykpLGwtPXV0LHMrPXV0LHl0KWJyZWFrIHR9ZWxzZSBhLmhlYWQmJihhLmhlYWQubmFtZT1udWxsKTthLmxlbmd0aD0wLGEubW9kZT1MO2Nhc2UgTDppZig0MDk2JmEuZmxhZ3Mpe2lmKDA9PT1sKWJyZWFrIHQ7dXQ9MDtkb3t5dD1uW3MrdXQrK10sYS5oZWFkJiZ5dCYmYS5sZW5ndGg8NjU1MzYmJihhLmhlYWQuY29tbWVudCs9U3RyaW5nLmZyb21DaGFyQ29kZSh5dCkpfXdoaWxlKHl0JiZ1dDxsKTtpZig1MTImYS5mbGFncyYmKGEuY2hlY2s9YihhLmNoZWNrLG4sdXQscykpLGwtPXV0LHMrPXV0LHl0KWJyZWFrIHR9ZWxzZSBhLmhlYWQmJihhLmhlYWQuY29tbWVudD1udWxsKTthLm1vZGU9SDtjYXNlIEg6aWYoNTEyJmEuZmxhZ3Mpe2Zvcig7ZHQ8MTY7KXtpZigwPT09bClicmVhayB0O2wtLSxfKz1uW3MrK108PGR0LGR0Kz04fWlmKF8hPT0oNjU1MzUmYS5jaGVjaykpe3QubXNnPVwiaGVhZGVyIGNyYyBtaXNtYXRjaFwiLGEubW9kZT1vdDticmVha31fPTAsZHQ9MH1hLmhlYWQmJihhLmhlYWQuaGNyYz1hLmZsYWdzPj45JjEsYS5oZWFkLmRvbmU9ITApLHQuYWRsZXI9YS5jaGVjaz0wLGEubW9kZT1NO2JyZWFrO2Nhc2Ugajpmb3IoO2R0PDMyOyl7aWYoMD09PWwpYnJlYWsgdDtsLS0sXys9bltzKytdPDxkdCxkdCs9OH10LmFkbGVyPWEuY2hlY2s9aShfKSxfPTAsZHQ9MCxhLm1vZGU9SztjYXNlIEs6aWYoMD09PWEuaGF2ZWRpY3QpcmV0dXJuIHQubmV4dF9vdXQ9byx0LmF2YWlsX291dD1mLHQubmV4dF9pbj1zLHQuYXZhaWxfaW49bCxhLmhvbGQ9XyxhLmJpdHM9ZHQsUzt0LmFkbGVyPWEuY2hlY2s9MSxhLm1vZGU9TTtjYXNlIE06aWYoZT09PXl8fGU9PT14KWJyZWFrIHQ7Y2FzZSBQOmlmKGEubGFzdCl7Xz4+Pj03JmR0LGR0LT03JmR0LGEubW9kZT1udDticmVha31mb3IoO2R0PDM7KXtpZigwPT09bClicmVhayB0O2wtLSxfKz1uW3MrK108PGR0LGR0Kz04fXN3aXRjaChhLmxhc3Q9MSZfLF8+Pj49MSxkdC09MSwzJl8pe2Nhc2UgMDphLm1vZGU9WTticmVhaztjYXNlIDE6aWYoaChhKSxhLm1vZGU9USxlPT09eCl7Xz4+Pj0yLGR0LT0yO2JyZWFrIHR9YnJlYWs7Y2FzZSAyOmEubW9kZT1YO2JyZWFrO2Nhc2UgMzp0Lm1zZz1cImludmFsaWQgYmxvY2sgdHlwZVwiLGEubW9kZT1vdH1fPj4+PTIsZHQtPTI7YnJlYWs7Y2FzZSBZOmZvcihfPj4+PTcmZHQsZHQtPTcmZHQ7ZHQ8MzI7KXtpZigwPT09bClicmVhayB0O2wtLSxfKz1uW3MrK108PGR0LGR0Kz04fWlmKCg2NTUzNSZfKSE9KF8+Pj4xNl42NTUzNSkpe3QubXNnPVwiaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Roc1wiLGEubW9kZT1vdDticmVha31pZihhLmxlbmd0aD02NTUzNSZfLF89MCxkdD0wLGEubW9kZT1xLGU9PT14KWJyZWFrIHQ7Y2FzZSBxOmEubW9kZT1HO2Nhc2UgRzppZih1dD1hLmxlbmd0aCl7aWYodXQ+bCYmKHV0PWwpLHV0PmYmJih1dD1mKSwwPT09dXQpYnJlYWsgdDt1LmFycmF5U2V0KHIsbixzLHV0LG8pLGwtPXV0LHMrPXV0LGYtPXV0LG8rPXV0LGEubGVuZ3RoLT11dDticmVha31hLm1vZGU9TTticmVhaztjYXNlIFg6Zm9yKDtkdDwxNDspe2lmKDA9PT1sKWJyZWFrIHQ7bC0tLF8rPW5bcysrXTw8ZHQsZHQrPTh9aWYoYS5ubGVuPTI1NysoMzEmXyksXz4+Pj01LGR0LT01LGEubmRpc3Q9MSsoMzEmXyksXz4+Pj01LGR0LT01LGEubmNvZGU9NCsoMTUmXyksXz4+Pj00LGR0LT00LGEubmxlbj4yODZ8fGEubmRpc3Q+MzApe3QubXNnPVwidG9vIG1hbnkgbGVuZ3RoIG9yIGRpc3RhbmNlIHN5bWJvbHNcIixhLm1vZGU9b3Q7YnJlYWt9YS5oYXZlPTAsYS5tb2RlPVc7Y2FzZSBXOmZvcig7YS5oYXZlPGEubmNvZGU7KXtmb3IoO2R0PDM7KXtpZigwPT09bClicmVhayB0O2wtLSxfKz1uW3MrK108PGR0LGR0Kz04fWEubGVuc1tBdFthLmhhdmUrK11dPTcmXyxfPj4+PTMsZHQtPTN9Zm9yKDthLmhhdmU8MTk7KWEubGVuc1tBdFthLmhhdmUrK11dPTA7aWYoYS5sZW5jb2RlPWEubGVuZHluLGEubGVuYml0cz03LHp0PXtiaXRzOmEubGVuYml0c30seHQ9bSh3LGEubGVucywwLDE5LGEubGVuY29kZSwwLGEud29yayx6dCksYS5sZW5iaXRzPXp0LmJpdHMseHQpe3QubXNnPVwiaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0XCIsYS5tb2RlPW90O2JyZWFrfWEuaGF2ZT0wLGEubW9kZT1KO2Nhc2UgSjpmb3IoO2EuaGF2ZTxhLm5sZW4rYS5uZGlzdDspe2Zvcig7U3Q9YS5sZW5jb2RlW18mKDE8PGEubGVuYml0cyktMV0sZ3Q9U3Q+Pj4yNCxtdD1TdD4+PjE2JjI1NSx3dD02NTUzNSZTdCwhKGd0PD1kdCk7KXtpZigwPT09bClicmVhayB0O2wtLSxfKz1uW3MrK108PGR0LGR0Kz04fWlmKHd0PDE2KV8+Pj49Z3QsZHQtPWd0LGEubGVuc1thLmhhdmUrK109d3Q7ZWxzZXtpZigxNj09PXd0KXtmb3IoQnQ9Z3QrMjtkdDxCdDspe2lmKDA9PT1sKWJyZWFrIHQ7bC0tLF8rPW5bcysrXTw8ZHQsZHQrPTh9aWYoXz4+Pj1ndCxkdC09Z3QsMD09PWEuaGF2ZSl7dC5tc2c9XCJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0XCIsYS5tb2RlPW90O2JyZWFrfXl0PWEubGVuc1thLmhhdmUtMV0sdXQ9MysoMyZfKSxfPj4+PTIsZHQtPTJ9ZWxzZSBpZigxNz09PXd0KXtmb3IoQnQ9Z3QrMztkdDxCdDspe2lmKDA9PT1sKWJyZWFrIHQ7bC0tLF8rPW5bcysrXTw8ZHQsZHQrPTh9ZHQtPWd0LHl0PTAsdXQ9MysoNyYoXz4+Pj1ndCkpLF8+Pj49MyxkdC09M31lbHNle2ZvcihCdD1ndCs3O2R0PEJ0Oyl7aWYoMD09PWwpYnJlYWsgdDtsLS0sXys9bltzKytdPDxkdCxkdCs9OH1kdC09Z3QseXQ9MCx1dD0xMSsoMTI3JihfPj4+PWd0KSksXz4+Pj03LGR0LT03fWlmKGEuaGF2ZSt1dD5hLm5sZW4rYS5uZGlzdCl7dC5tc2c9XCJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0XCIsYS5tb2RlPW90O2JyZWFrfWZvcig7dXQtLTspYS5sZW5zW2EuaGF2ZSsrXT15dH19aWYoYS5tb2RlPT09b3QpYnJlYWs7aWYoMD09PWEubGVuc1syNTZdKXt0Lm1zZz1cImludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9ja1wiLGEubW9kZT1vdDticmVha31pZihhLmxlbmJpdHM9OSx6dD17Yml0czphLmxlbmJpdHN9LHh0PW0ocCxhLmxlbnMsMCxhLm5sZW4sYS5sZW5jb2RlLDAsYS53b3JrLHp0KSxhLmxlbmJpdHM9enQuYml0cyx4dCl7dC5tc2c9XCJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXRcIixhLm1vZGU9b3Q7YnJlYWt9aWYoYS5kaXN0Yml0cz02LGEuZGlzdGNvZGU9YS5kaXN0ZHluLHp0PXtiaXRzOmEuZGlzdGJpdHN9LHh0PW0odixhLmxlbnMsYS5ubGVuLGEubmRpc3QsYS5kaXN0Y29kZSwwLGEud29yayx6dCksYS5kaXN0Yml0cz16dC5iaXRzLHh0KXt0Lm1zZz1cImludmFsaWQgZGlzdGFuY2VzIHNldFwiLGEubW9kZT1vdDticmVha31pZihhLm1vZGU9USxlPT09eClicmVhayB0O2Nhc2UgUTphLm1vZGU9VjtjYXNlIFY6aWYobD49NiYmZj49MjU4KXt0Lm5leHRfb3V0PW8sdC5hdmFpbF9vdXQ9Zix0Lm5leHRfaW49cyx0LmF2YWlsX2luPWwsYS5ob2xkPV8sYS5iaXRzPWR0LGcodCxfdCksbz10Lm5leHRfb3V0LHI9dC5vdXRwdXQsZj10LmF2YWlsX291dCxzPXQubmV4dF9pbixuPXQuaW5wdXQsbD10LmF2YWlsX2luLF89YS5ob2xkLGR0PWEuYml0cyxhLm1vZGU9PT1NJiYoYS5iYWNrPS0xKTticmVha31mb3IoYS5iYWNrPTA7U3Q9YS5sZW5jb2RlW18mKDE8PGEubGVuYml0cyktMV0sZ3Q9U3Q+Pj4yNCxtdD1TdD4+PjE2JjI1NSx3dD02NTUzNSZTdCwhKGd0PD1kdCk7KXtpZigwPT09bClicmVhayB0O2wtLSxfKz1uW3MrK108PGR0LGR0Kz04fWlmKG10JiYwPT0oMjQwJm10KSl7Zm9yKHB0PWd0LHZ0PW10LGt0PXd0O1N0PWEubGVuY29kZVtrdCsoKF8mKDE8PHB0K3Z0KS0xKT4+cHQpXSxndD1TdD4+PjI0LG10PVN0Pj4+MTYmMjU1LHd0PTY1NTM1JlN0LCEocHQrZ3Q8PWR0KTspe2lmKDA9PT1sKWJyZWFrIHQ7bC0tLF8rPW5bcysrXTw8ZHQsZHQrPTh9Xz4+Pj1wdCxkdC09cHQsYS5iYWNrKz1wdH1pZihfPj4+PWd0LGR0LT1ndCxhLmJhY2srPWd0LGEubGVuZ3RoPXd0LDA9PT1tdCl7YS5tb2RlPWl0O2JyZWFrfWlmKDMyJm10KXthLmJhY2s9LTEsYS5tb2RlPU07YnJlYWt9aWYoNjQmbXQpe3QubXNnPVwiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlXCIsYS5tb2RlPW90O2JyZWFrfWEuZXh0cmE9MTUmbXQsYS5tb2RlPSQ7Y2FzZSAkOmlmKGEuZXh0cmEpe2ZvcihCdD1hLmV4dHJhO2R0PEJ0Oyl7aWYoMD09PWwpYnJlYWsgdDtsLS0sXys9bltzKytdPDxkdCxkdCs9OH1hLmxlbmd0aCs9XyYoMTw8YS5leHRyYSktMSxfPj4+PWEuZXh0cmEsZHQtPWEuZXh0cmEsYS5iYWNrKz1hLmV4dHJhfWEud2FzPWEubGVuZ3RoLGEubW9kZT10dDtjYXNlIHR0OmZvcig7U3Q9YS5kaXN0Y29kZVtfJigxPDxhLmRpc3RiaXRzKS0xXSxndD1TdD4+PjI0LG10PVN0Pj4+MTYmMjU1LHd0PTY1NTM1JlN0LCEoZ3Q8PWR0KTspe2lmKDA9PT1sKWJyZWFrIHQ7bC0tLF8rPW5bcysrXTw8ZHQsZHQrPTh9aWYoMD09KDI0MCZtdCkpe2ZvcihwdD1ndCx2dD1tdCxrdD13dDtTdD1hLmRpc3Rjb2RlW2t0KygoXyYoMTw8cHQrdnQpLTEpPj5wdCldLGd0PVN0Pj4+MjQsbXQ9U3Q+Pj4xNiYyNTUsd3Q9NjU1MzUmU3QsIShwdCtndDw9ZHQpOyl7aWYoMD09PWwpYnJlYWsgdDtsLS0sXys9bltzKytdPDxkdCxkdCs9OH1fPj4+PXB0LGR0LT1wdCxhLmJhY2srPXB0fWlmKF8+Pj49Z3QsZHQtPWd0LGEuYmFjays9Z3QsNjQmbXQpe3QubXNnPVwiaW52YWxpZCBkaXN0YW5jZSBjb2RlXCIsYS5tb2RlPW90O2JyZWFrfWEub2Zmc2V0PXd0LGEuZXh0cmE9MTUmbXQsYS5tb2RlPWV0O2Nhc2UgZXQ6aWYoYS5leHRyYSl7Zm9yKEJ0PWEuZXh0cmE7ZHQ8QnQ7KXtpZigwPT09bClicmVhayB0O2wtLSxfKz1uW3MrK108PGR0LGR0Kz04fWEub2Zmc2V0Kz1fJigxPDxhLmV4dHJhKS0xLF8+Pj49YS5leHRyYSxkdC09YS5leHRyYSxhLmJhY2srPWEuZXh0cmF9aWYoYS5vZmZzZXQ+YS5kbWF4KXt0Lm1zZz1cImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrXCIsYS5tb2RlPW90O2JyZWFrfWEubW9kZT1hdDtjYXNlIGF0OmlmKDA9PT1mKWJyZWFrIHQ7aWYodXQ9X3QtZixhLm9mZnNldD51dCl7aWYoKHV0PWEub2Zmc2V0LXV0KT5hLndoYXZlJiZhLnNhbmUpe3QubXNnPVwiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2tcIixhLm1vZGU9b3Q7YnJlYWt9dXQ+YS53bmV4dD8odXQtPWEud25leHQsY3Q9YS53c2l6ZS11dCk6Y3Q9YS53bmV4dC11dCx1dD5hLmxlbmd0aCYmKHV0PWEubGVuZ3RoKSxidD1hLndpbmRvd31lbHNlIGJ0PXIsY3Q9by1hLm9mZnNldCx1dD1hLmxlbmd0aDt1dD5mJiYodXQ9ZiksZi09dXQsYS5sZW5ndGgtPXV0O2Rve3JbbysrXT1idFtjdCsrXX13aGlsZSgtLXV0KTswPT09YS5sZW5ndGgmJihhLm1vZGU9Vik7YnJlYWs7Y2FzZSBpdDppZigwPT09ZilicmVhayB0O3JbbysrXT1hLmxlbmd0aCxmLS0sYS5tb2RlPVY7YnJlYWs7Y2FzZSBudDppZihhLndyYXApe2Zvcig7ZHQ8MzI7KXtpZigwPT09bClicmVhayB0O2wtLSxffD1uW3MrK108PGR0LGR0Kz04fWlmKF90LT1mLHQudG90YWxfb3V0Kz1fdCxhLnRvdGFsKz1fdCxfdCYmKHQuYWRsZXI9YS5jaGVjaz1hLmZsYWdzP2IoYS5jaGVjayxyLF90LG8tX3QpOmMoYS5jaGVjayxyLF90LG8tX3QpKSxfdD1mLChhLmZsYWdzP186aShfKSkhPT1hLmNoZWNrKXt0Lm1zZz1cImluY29ycmVjdCBkYXRhIGNoZWNrXCIsYS5tb2RlPW90O2JyZWFrfV89MCxkdD0wfWEubW9kZT1ydDtjYXNlIHJ0OmlmKGEud3JhcCYmYS5mbGFncyl7Zm9yKDtkdDwzMjspe2lmKDA9PT1sKWJyZWFrIHQ7bC0tLF8rPW5bcysrXTw8ZHQsZHQrPTh9aWYoXyE9PSg0Mjk0OTY3Mjk1JmEudG90YWwpKXt0Lm1zZz1cImluY29ycmVjdCBsZW5ndGggY2hlY2tcIixhLm1vZGU9b3Q7YnJlYWt9Xz0wLGR0PTB9YS5tb2RlPXN0O2Nhc2Ugc3Q6eHQ9QjticmVhayB0O2Nhc2Ugb3Q6eHQ9QTticmVhayB0O2Nhc2UgbHQ6cmV0dXJuIFo7Y2FzZSBodDpkZWZhdWx0OnJldHVybiBFfXJldHVybiB0Lm5leHRfb3V0PW8sdC5hdmFpbF9vdXQ9Zix0Lm5leHRfaW49cyx0LmF2YWlsX2luPWwsYS5ob2xkPV8sYS5iaXRzPWR0LChhLndzaXplfHxfdCE9PXQuYXZhaWxfb3V0JiZhLm1vZGU8b3QmJihhLm1vZGU8bnR8fGUhPT1rKSkmJmQodCx0Lm91dHB1dCx0Lm5leHRfb3V0LF90LXQuYXZhaWxfb3V0KT8oYS5tb2RlPWx0LFopOihmdC09dC5hdmFpbF9pbixfdC09dC5hdmFpbF9vdXQsdC50b3RhbF9pbis9ZnQsdC50b3RhbF9vdXQrPV90LGEudG90YWwrPV90LGEud3JhcCYmX3QmJih0LmFkbGVyPWEuY2hlY2s9YS5mbGFncz9iKGEuY2hlY2sscixfdCx0Lm5leHRfb3V0LV90KTpjKGEuY2hlY2sscixfdCx0Lm5leHRfb3V0LV90KSksdC5kYXRhX3R5cGU9YS5iaXRzKyhhLmxhc3Q/NjQ6MCkrKGEubW9kZT09PU0/MTI4OjApKyhhLm1vZGU9PT1RfHxhLm1vZGU9PT1xPzI1NjowKSwoMD09PWZ0JiYwPT09X3R8fGU9PT1rKSYmeHQ9PT16JiYoeHQ9UikseHQpfSxhLmluZmxhdGVFbmQ9ZnVuY3Rpb24odCl7aWYoIXR8fCF0LnN0YXRlKXJldHVybiBFO3ZhciBlPXQuc3RhdGU7cmV0dXJuIGUud2luZG93JiYoZS53aW5kb3c9bnVsbCksdC5zdGF0ZT1udWxsLHp9LGEuaW5mbGF0ZUdldEhlYWRlcj1mdW5jdGlvbih0LGUpe3ZhciBhO3JldHVybiB0JiZ0LnN0YXRlPzA9PSgyJihhPXQuc3RhdGUpLndyYXApP0U6KGEuaGVhZD1lLGUuZG9uZT0hMSx6KTpFfSxhLmluZmxhdGVTZXREaWN0aW9uYXJ5PWZ1bmN0aW9uKHQsZSl7dmFyIGEsaSxuPWUubGVuZ3RoO3JldHVybiB0JiZ0LnN0YXRlPzAhPT0oYT10LnN0YXRlKS53cmFwJiZhLm1vZGUhPT1LP0U6YS5tb2RlPT09SyYmKGk9MSwoaT1jKGksZSxuLDApKSE9PWEuY2hlY2spP0E6ZCh0LGUsbixuKT8oYS5tb2RlPWx0LFopOihhLmhhdmVkaWN0PTEseik6RX0sYS5pbmZsYXRlSW5mbz1cInBha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdClcIn0se1wiLi4vdXRpbHMvY29tbW9uXCI6MyxcIi4vYWRsZXIzMlwiOjUsXCIuL2NyYzMyXCI6NyxcIi4vaW5mZmFzdFwiOjEwLFwiLi9pbmZ0cmVlc1wiOjEyfV0sMTI6W2Z1bmN0aW9uKHQsZSxhKXtcInVzZSBzdHJpY3RcIjt2YXIgaT10KFwiLi4vdXRpbHMvY29tbW9uXCIpLG49WzMsNCw1LDYsNyw4LDksMTAsMTEsMTMsMTUsMTcsMTksMjMsMjcsMzEsMzUsNDMsNTEsNTksNjcsODMsOTksMTE1LDEzMSwxNjMsMTk1LDIyNywyNTgsMCwwXSxyPVsxNiwxNiwxNiwxNiwxNiwxNiwxNiwxNiwxNywxNywxNywxNywxOCwxOCwxOCwxOCwxOSwxOSwxOSwxOSwyMCwyMCwyMCwyMCwyMSwyMSwyMSwyMSwxNiw3Miw3OF0scz1bMSwyLDMsNCw1LDcsOSwxMywxNywyNSwzMyw0OSw2NSw5NywxMjksMTkzLDI1NywzODUsNTEzLDc2OSwxMDI1LDE1MzcsMjA0OSwzMDczLDQwOTcsNjE0NSw4MTkzLDEyMjg5LDE2Mzg1LDI0NTc3LDAsMF0sbz1bMTYsMTYsMTYsMTYsMTcsMTcsMTgsMTgsMTksMTksMjAsMjAsMjEsMjEsMjIsMjIsMjMsMjMsMjQsMjQsMjUsMjUsMjYsMjYsMjcsMjcsMjgsMjgsMjksMjksNjQsNjRdO2UuZXhwb3J0cz1mdW5jdGlvbih0LGUsYSxsLGgsZCxmLF8pe3ZhciB1LGMsYixnLG0sdyxwLHYsayx5PV8uYml0cyx4PTAsej0wLEI9MCxTPTAsRT0wLEE9MCxaPTAsUj0wLEM9MCxOPTAsTz1udWxsLEQ9MCxJPW5ldyBpLkJ1ZjE2KDE2KSxVPW5ldyBpLkJ1ZjE2KDE2KSxUPW51bGwsRj0wO2Zvcih4PTA7eDw9MTU7eCsrKUlbeF09MDtmb3Ioej0wO3o8bDt6KyspSVtlW2Erel1dKys7Zm9yKEU9eSxTPTE1O1M+PTEmJjA9PT1JW1NdO1MtLSk7aWYoRT5TJiYoRT1TKSwwPT09UylyZXR1cm4gaFtkKytdPTIwOTcxNTIwLGhbZCsrXT0yMDk3MTUyMCxfLmJpdHM9MSwwO2ZvcihCPTE7QjxTJiYwPT09SVtCXTtCKyspO2ZvcihFPEImJihFPUIpLFI9MSx4PTE7eDw9MTU7eCsrKWlmKFI8PD0xLChSLT1JW3hdKTwwKXJldHVybi0xO2lmKFI+MCYmKDA9PT10fHwxIT09UykpcmV0dXJuLTE7Zm9yKFVbMV09MCx4PTE7eDwxNTt4KyspVVt4KzFdPVVbeF0rSVt4XTtmb3Ioej0wO3o8bDt6KyspMCE9PWVbYSt6XSYmKGZbVVtlW2Erel1dKytdPXopO2lmKDA9PT10PyhPPVQ9Zix3PTE5KToxPT09dD8oTz1uLEQtPTI1NyxUPXIsRi09MjU3LHc9MjU2KTooTz1zLFQ9byx3PS0xKSxOPTAsej0wLHg9QixtPWQsQT1FLFo9MCxiPS0xLEM9MTw8RSxnPUMtMSwxPT09dCYmQz44NTJ8fDI9PT10JiZDPjU5MilyZXR1cm4gMTtmb3IoOzspe3A9eC1aLGZbel08dz8odj0wLGs9Zlt6XSk6Zlt6XT53Pyh2PVRbRitmW3pdXSxrPU9bRCtmW3pdXSk6KHY9OTYsaz0wKSx1PTE8PHgtWixCPWM9MTw8QTtkb3toW20rKE4+PlopKyhjLT11KV09cDw8MjR8djw8MTZ8a3wwfXdoaWxlKDAhPT1jKTtmb3IodT0xPDx4LTE7TiZ1Oyl1Pj49MTtpZigwIT09dT8oTiY9dS0xLE4rPXUpOk49MCx6KyssMD09LS1JW3hdKXtpZih4PT09UylicmVhazt4PWVbYStmW3pdXX1pZih4PkUmJihOJmcpIT09Yil7Zm9yKDA9PT1aJiYoWj1FKSxtKz1CLFI9MTw8KEE9eC1aKTtBK1o8UyYmISgoUi09SVtBK1pdKTw9MCk7KUErKyxSPDw9MTtpZihDKz0xPDxBLDE9PT10JiZDPjg1Mnx8Mj09PXQmJkM+NTkyKXJldHVybiAxO2hbYj1OJmddPUU8PDI0fEE8PDE2fG0tZHwwfX1yZXR1cm4gMCE9PU4mJihoW20rTl09eC1aPDwyNHw2NDw8MTZ8MCksXy5iaXRzPUUsMH19LHtcIi4uL3V0aWxzL2NvbW1vblwiOjN9XSwxMzpbZnVuY3Rpb24odCxlLGEpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz17MjpcIm5lZWQgZGljdGlvbmFyeVwiLDE6XCJzdHJlYW0gZW5kXCIsMDpcIlwiLFwiLTFcIjpcImZpbGUgZXJyb3JcIixcIi0yXCI6XCJzdHJlYW0gZXJyb3JcIixcIi0zXCI6XCJkYXRhIGVycm9yXCIsXCItNFwiOlwiaW5zdWZmaWNpZW50IG1lbW9yeVwiLFwiLTVcIjpcImJ1ZmZlciBlcnJvclwiLFwiLTZcIjpcImluY29tcGF0aWJsZSB2ZXJzaW9uXCJ9fSx7fV0sMTQ6W2Z1bmN0aW9uKHQsZSxhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKHQpe2Zvcih2YXIgZT10Lmxlbmd0aDstLWU+PTA7KXRbZV09MH1mdW5jdGlvbiBuKHQsZSxhLGksbil7dGhpcy5zdGF0aWNfdHJlZT10LHRoaXMuZXh0cmFfYml0cz1lLHRoaXMuZXh0cmFfYmFzZT1hLHRoaXMuZWxlbXM9aSx0aGlzLm1heF9sZW5ndGg9bix0aGlzLmhhc19zdHJlZT10JiZ0Lmxlbmd0aH1mdW5jdGlvbiByKHQsZSl7dGhpcy5keW5fdHJlZT10LHRoaXMubWF4X2NvZGU9MCx0aGlzLnN0YXRfZGVzYz1lfWZ1bmN0aW9uIHModCl7cmV0dXJuIHQ8MjU2P2V0W3RdOmV0WzI1NisodD4+PjcpXX1mdW5jdGlvbiBvKHQsZSl7dC5wZW5kaW5nX2J1Zlt0LnBlbmRpbmcrK109MjU1JmUsdC5wZW5kaW5nX2J1Zlt0LnBlbmRpbmcrK109ZT4+PjgmMjU1fWZ1bmN0aW9uIGwodCxlLGEpe3QuYmlfdmFsaWQ+TS1hPyh0LmJpX2J1Znw9ZTw8dC5iaV92YWxpZCY2NTUzNSxvKHQsdC5iaV9idWYpLHQuYmlfYnVmPWU+Pk0tdC5iaV92YWxpZCx0LmJpX3ZhbGlkKz1hLU0pOih0LmJpX2J1Znw9ZTw8dC5iaV92YWxpZCY2NTUzNSx0LmJpX3ZhbGlkKz1hKX1mdW5jdGlvbiBoKHQsZSxhKXtsKHQsYVsyKmVdLGFbMiplKzFdKX1mdW5jdGlvbiBkKHQsZSl7dmFyIGE9MDtkb3thfD0xJnQsdD4+Pj0xLGE8PD0xfXdoaWxlKC0tZT4wKTtyZXR1cm4gYT4+PjF9ZnVuY3Rpb24gZih0KXsxNj09PXQuYmlfdmFsaWQ/KG8odCx0LmJpX2J1ZiksdC5iaV9idWY9MCx0LmJpX3ZhbGlkPTApOnQuYmlfdmFsaWQ+PTgmJih0LnBlbmRpbmdfYnVmW3QucGVuZGluZysrXT0yNTUmdC5iaV9idWYsdC5iaV9idWY+Pj04LHQuYmlfdmFsaWQtPTgpfWZ1bmN0aW9uIF8odCxlKXt2YXIgYSxpLG4scixzLG8sbD1lLmR5bl90cmVlLGg9ZS5tYXhfY29kZSxkPWUuc3RhdF9kZXNjLnN0YXRpY190cmVlLGY9ZS5zdGF0X2Rlc2MuaGFzX3N0cmVlLF89ZS5zdGF0X2Rlc2MuZXh0cmFfYml0cyx1PWUuc3RhdF9kZXNjLmV4dHJhX2Jhc2UsYz1lLnN0YXRfZGVzYy5tYXhfbGVuZ3RoLGI9MDtmb3Iocj0wO3I8PUs7cisrKXQuYmxfY291bnRbcl09MDtmb3IobFsyKnQuaGVhcFt0LmhlYXBfbWF4XSsxXT0wLGE9dC5oZWFwX21heCsxO2E8ajthKyspKHI9bFsyKmxbMiooaT10LmhlYXBbYV0pKzFdKzFdKzEpPmMmJihyPWMsYisrKSxsWzIqaSsxXT1yLGk+aHx8KHQuYmxfY291bnRbcl0rKyxzPTAsaT49dSYmKHM9X1tpLXVdKSxvPWxbMippXSx0Lm9wdF9sZW4rPW8qKHIrcyksZiYmKHQuc3RhdGljX2xlbis9byooZFsyKmkrMV0rcykpKTtpZigwIT09Yil7ZG97Zm9yKHI9Yy0xOzA9PT10LmJsX2NvdW50W3JdOylyLS07dC5ibF9jb3VudFtyXS0tLHQuYmxfY291bnRbcisxXSs9Mix0LmJsX2NvdW50W2NdLS0sYi09Mn13aGlsZShiPjApO2ZvcihyPWM7MCE9PXI7ci0tKWZvcihpPXQuYmxfY291bnRbcl07MCE9PWk7KShuPXQuaGVhcFstLWFdKT5ofHwobFsyKm4rMV0hPT1yJiYodC5vcHRfbGVuKz0oci1sWzIqbisxXSkqbFsyKm5dLGxbMipuKzFdPXIpLGktLSl9fWZ1bmN0aW9uIHUodCxlLGEpe3ZhciBpLG4scj1uZXcgQXJyYXkoSysxKSxzPTA7Zm9yKGk9MTtpPD1LO2krKylyW2ldPXM9cythW2ktMV08PDE7Zm9yKG49MDtuPD1lO24rKyl7dmFyIG89dFsyKm4rMV07MCE9PW8mJih0WzIqbl09ZChyW29dKyssbykpfX1mdW5jdGlvbiBjKCl7dmFyIHQsZSxhLGkscixzPW5ldyBBcnJheShLKzEpO2ZvcihhPTAsaT0wO2k8VS0xO2krKylmb3IoaXRbaV09YSx0PTA7dDwxPDxXW2ldO3QrKylhdFthKytdPWk7Zm9yKGF0W2EtMV09aSxyPTAsaT0wO2k8MTY7aSsrKWZvcihudFtpXT1yLHQ9MDt0PDE8PEpbaV07dCsrKWV0W3IrK109aTtmb3Iocj4+PTc7aTxMO2krKylmb3IobnRbaV09cjw8Nyx0PTA7dDwxPDxKW2ldLTc7dCsrKWV0WzI1NityKytdPWk7Zm9yKGU9MDtlPD1LO2UrKylzW2VdPTA7Zm9yKHQ9MDt0PD0xNDM7KSRbMip0KzFdPTgsdCsrLHNbOF0rKztmb3IoO3Q8PTI1NTspJFsyKnQrMV09OSx0Kyssc1s5XSsrO2Zvcig7dDw9Mjc5OykkWzIqdCsxXT03LHQrKyxzWzddKys7Zm9yKDt0PD0yODc7KSRbMip0KzFdPTgsdCsrLHNbOF0rKztmb3IodSgkLEYrMSxzKSx0PTA7dDxMO3QrKyl0dFsyKnQrMV09NSx0dFsyKnRdPWQodCw1KTtydD1uZXcgbigkLFcsVCsxLEYsSyksc3Q9bmV3IG4odHQsSiwwLEwsSyksb3Q9bmV3IG4obmV3IEFycmF5KDApLFEsMCxILFApfWZ1bmN0aW9uIGIodCl7dmFyIGU7Zm9yKGU9MDtlPEY7ZSsrKXQuZHluX2x0cmVlWzIqZV09MDtmb3IoZT0wO2U8TDtlKyspdC5keW5fZHRyZWVbMiplXT0wO2ZvcihlPTA7ZTxIO2UrKyl0LmJsX3RyZWVbMiplXT0wO3QuZHluX2x0cmVlWzIqWV09MSx0Lm9wdF9sZW49dC5zdGF0aWNfbGVuPTAsdC5sYXN0X2xpdD10Lm1hdGNoZXM9MH1mdW5jdGlvbiBnKHQpe3QuYmlfdmFsaWQ+OD9vKHQsdC5iaV9idWYpOnQuYmlfdmFsaWQ+MCYmKHQucGVuZGluZ19idWZbdC5wZW5kaW5nKytdPXQuYmlfYnVmKSx0LmJpX2J1Zj0wLHQuYmlfdmFsaWQ9MH1mdW5jdGlvbiBtKHQsZSxhLGkpe2codCksaSYmKG8odCxhKSxvKHQsfmEpKSxBLmFycmF5U2V0KHQucGVuZGluZ19idWYsdC53aW5kb3csZSxhLHQucGVuZGluZyksdC5wZW5kaW5nKz1hfWZ1bmN0aW9uIHcodCxlLGEsaSl7dmFyIG49MiplLHI9MiphO3JldHVybiB0W25dPHRbcl18fHRbbl09PT10W3JdJiZpW2VdPD1pW2FdfWZ1bmN0aW9uIHAodCxlLGEpe2Zvcih2YXIgaT10LmhlYXBbYV0sbj1hPDwxO248PXQuaGVhcF9sZW4mJihuPHQuaGVhcF9sZW4mJncoZSx0LmhlYXBbbisxXSx0LmhlYXBbbl0sdC5kZXB0aCkmJm4rKywhdyhlLGksdC5oZWFwW25dLHQuZGVwdGgpKTspdC5oZWFwW2FdPXQuaGVhcFtuXSxhPW4sbjw8PTE7dC5oZWFwW2FdPWl9ZnVuY3Rpb24gdih0LGUsYSl7dmFyIGksbixyLG8sZD0wO2lmKDAhPT10Lmxhc3RfbGl0KWRve2k9dC5wZW5kaW5nX2J1Zlt0LmRfYnVmKzIqZF08PDh8dC5wZW5kaW5nX2J1Zlt0LmRfYnVmKzIqZCsxXSxuPXQucGVuZGluZ19idWZbdC5sX2J1ZitkXSxkKyssMD09PWk/aCh0LG4sZSk6KGgodCwocj1hdFtuXSkrVCsxLGUpLDAhPT0obz1XW3JdKSYmbCh0LG4tPWl0W3JdLG8pLGgodCxyPXMoLS1pKSxhKSwwIT09KG89SltyXSkmJmwodCxpLT1udFtyXSxvKSl9d2hpbGUoZDx0Lmxhc3RfbGl0KTtoKHQsWSxlKX1mdW5jdGlvbiBrKHQsZSl7dmFyIGEsaSxuLHI9ZS5keW5fdHJlZSxzPWUuc3RhdF9kZXNjLnN0YXRpY190cmVlLG89ZS5zdGF0X2Rlc2MuaGFzX3N0cmVlLGw9ZS5zdGF0X2Rlc2MuZWxlbXMsaD0tMTtmb3IodC5oZWFwX2xlbj0wLHQuaGVhcF9tYXg9aixhPTA7YTxsO2ErKykwIT09clsyKmFdPyh0LmhlYXBbKyt0LmhlYXBfbGVuXT1oPWEsdC5kZXB0aFthXT0wKTpyWzIqYSsxXT0wO2Zvcig7dC5oZWFwX2xlbjwyOylyWzIqKG49dC5oZWFwWysrdC5oZWFwX2xlbl09aDwyPysraDowKV09MSx0LmRlcHRoW25dPTAsdC5vcHRfbGVuLS0sbyYmKHQuc3RhdGljX2xlbi09c1syKm4rMV0pO2ZvcihlLm1heF9jb2RlPWgsYT10LmhlYXBfbGVuPj4xO2E+PTE7YS0tKXAodCxyLGEpO249bDtkb3thPXQuaGVhcFsxXSx0LmhlYXBbMV09dC5oZWFwW3QuaGVhcF9sZW4tLV0scCh0LHIsMSksaT10LmhlYXBbMV0sdC5oZWFwWy0tdC5oZWFwX21heF09YSx0LmhlYXBbLS10LmhlYXBfbWF4XT1pLHJbMipuXT1yWzIqYV0rclsyKmldLHQuZGVwdGhbbl09KHQuZGVwdGhbYV0+PXQuZGVwdGhbaV0/dC5kZXB0aFthXTp0LmRlcHRoW2ldKSsxLHJbMiphKzFdPXJbMippKzFdPW4sdC5oZWFwWzFdPW4rKyxwKHQsciwxKX13aGlsZSh0LmhlYXBfbGVuPj0yKTt0LmhlYXBbLS10LmhlYXBfbWF4XT10LmhlYXBbMV0sXyh0LGUpLHUocixoLHQuYmxfY291bnQpfWZ1bmN0aW9uIHkodCxlLGEpe3ZhciBpLG4scj0tMSxzPWVbMV0sbz0wLGw9NyxoPTQ7Zm9yKDA9PT1zJiYobD0xMzgsaD0zKSxlWzIqKGErMSkrMV09NjU1MzUsaT0wO2k8PWE7aSsrKW49cyxzPWVbMiooaSsxKSsxXSwrK288bCYmbj09PXN8fChvPGg/dC5ibF90cmVlWzIqbl0rPW86MCE9PW4/KG4hPT1yJiZ0LmJsX3RyZWVbMipuXSsrLHQuYmxfdHJlZVsyKnFdKyspOm88PTEwP3QuYmxfdHJlZVsyKkddKys6dC5ibF90cmVlWzIqWF0rKyxvPTAscj1uLDA9PT1zPyhsPTEzOCxoPTMpOm49PT1zPyhsPTYsaD0zKToobD03LGg9NCkpfWZ1bmN0aW9uIHgodCxlLGEpe3ZhciBpLG4scj0tMSxzPWVbMV0sbz0wLGQ9NyxmPTQ7Zm9yKDA9PT1zJiYoZD0xMzgsZj0zKSxpPTA7aTw9YTtpKyspaWYobj1zLHM9ZVsyKihpKzEpKzFdLCEoKytvPGQmJm49PT1zKSl7aWYobzxmKWRve2godCxuLHQuYmxfdHJlZSl9d2hpbGUoMCE9LS1vKTtlbHNlIDAhPT1uPyhuIT09ciYmKGgodCxuLHQuYmxfdHJlZSksby0tKSxoKHQscSx0LmJsX3RyZWUpLGwodCxvLTMsMikpOm88PTEwPyhoKHQsRyx0LmJsX3RyZWUpLGwodCxvLTMsMykpOihoKHQsWCx0LmJsX3RyZWUpLGwodCxvLTExLDcpKTtvPTAscj1uLDA9PT1zPyhkPTEzOCxmPTMpOm49PT1zPyhkPTYsZj0zKTooZD03LGY9NCl9fWZ1bmN0aW9uIHoodCl7dmFyIGU7Zm9yKHkodCx0LmR5bl9sdHJlZSx0LmxfZGVzYy5tYXhfY29kZSkseSh0LHQuZHluX2R0cmVlLHQuZF9kZXNjLm1heF9jb2RlKSxrKHQsdC5ibF9kZXNjKSxlPUgtMTtlPj0zJiYwPT09dC5ibF90cmVlWzIqVltlXSsxXTtlLS0pO3JldHVybiB0Lm9wdF9sZW4rPTMqKGUrMSkrNSs1KzQsZX1mdW5jdGlvbiBCKHQsZSxhLGkpe3ZhciBuO2ZvcihsKHQsZS0yNTcsNSksbCh0LGEtMSw1KSxsKHQsaS00LDQpLG49MDtuPGk7bisrKWwodCx0LmJsX3RyZWVbMipWW25dKzFdLDMpO3godCx0LmR5bl9sdHJlZSxlLTEpLHgodCx0LmR5bl9kdHJlZSxhLTEpfWZ1bmN0aW9uIFModCl7dmFyIGUsYT00MDkzNjI0NDQ3O2ZvcihlPTA7ZTw9MzE7ZSsrLGE+Pj49MSlpZigxJmEmJjAhPT10LmR5bl9sdHJlZVsyKmVdKXJldHVybiBSO2lmKDAhPT10LmR5bl9sdHJlZVsxOF18fDAhPT10LmR5bl9sdHJlZVsyMF18fDAhPT10LmR5bl9sdHJlZVsyNl0pcmV0dXJuIEM7Zm9yKGU9MzI7ZTxUO2UrKylpZigwIT09dC5keW5fbHRyZWVbMiplXSlyZXR1cm4gQztyZXR1cm4gUn1mdW5jdGlvbiBFKHQsZSxhLGkpe2wodCwoTzw8MSkrKGk/MTowKSwzKSxtKHQsZSxhLCEwKX12YXIgQT10KFwiLi4vdXRpbHMvY29tbW9uXCIpLFo9NCxSPTAsQz0xLE49MixPPTAsRD0xLEk9MixVPTI5LFQ9MjU2LEY9VCsxK1UsTD0zMCxIPTE5LGo9MipGKzEsSz0xNSxNPTE2LFA9NyxZPTI1NixxPTE2LEc9MTcsWD0xOCxXPVswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDBdLEo9WzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTNdLFE9WzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddLFY9WzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdLCQ9bmV3IEFycmF5KDIqKEYrMikpO2koJCk7dmFyIHR0PW5ldyBBcnJheSgyKkwpO2kodHQpO3ZhciBldD1uZXcgQXJyYXkoNTEyKTtpKGV0KTt2YXIgYXQ9bmV3IEFycmF5KDI1Nik7aShhdCk7dmFyIGl0PW5ldyBBcnJheShVKTtpKGl0KTt2YXIgbnQ9bmV3IEFycmF5KEwpO2kobnQpO3ZhciBydCxzdCxvdCxsdD0hMTthLl90cl9pbml0PWZ1bmN0aW9uKHQpe2x0fHwoYygpLGx0PSEwKSx0LmxfZGVzYz1uZXcgcih0LmR5bl9sdHJlZSxydCksdC5kX2Rlc2M9bmV3IHIodC5keW5fZHRyZWUsc3QpLHQuYmxfZGVzYz1uZXcgcih0LmJsX3RyZWUsb3QpLHQuYmlfYnVmPTAsdC5iaV92YWxpZD0wLGIodCl9LGEuX3RyX3N0b3JlZF9ibG9jaz1FLGEuX3RyX2ZsdXNoX2Jsb2NrPWZ1bmN0aW9uKHQsZSxhLGkpe3ZhciBuLHIscz0wO3QubGV2ZWw+MD8odC5zdHJtLmRhdGFfdHlwZT09PU4mJih0LnN0cm0uZGF0YV90eXBlPVModCkpLGsodCx0LmxfZGVzYyksayh0LHQuZF9kZXNjKSxzPXoodCksbj10Lm9wdF9sZW4rMys3Pj4+Mywocj10LnN0YXRpY19sZW4rMys3Pj4+Myk8PW4mJihuPXIpKTpuPXI9YSs1LGErNDw9biYmLTEhPT1lP0UodCxlLGEsaSk6dC5zdHJhdGVneT09PVp8fHI9PT1uPyhsKHQsKEQ8PDEpKyhpPzE6MCksMyksdih0LCQsdHQpKToobCh0LChJPDwxKSsoaT8xOjApLDMpLEIodCx0LmxfZGVzYy5tYXhfY29kZSsxLHQuZF9kZXNjLm1heF9jb2RlKzEscysxKSx2KHQsdC5keW5fbHRyZWUsdC5keW5fZHRyZWUpKSxiKHQpLGkmJmcodCl9LGEuX3RyX3RhbGx5PWZ1bmN0aW9uKHQsZSxhKXtyZXR1cm4gdC5wZW5kaW5nX2J1Zlt0LmRfYnVmKzIqdC5sYXN0X2xpdF09ZT4+PjgmMjU1LHQucGVuZGluZ19idWZbdC5kX2J1ZisyKnQubGFzdF9saXQrMV09MjU1JmUsdC5wZW5kaW5nX2J1Zlt0LmxfYnVmK3QubGFzdF9saXRdPTI1NSZhLHQubGFzdF9saXQrKywwPT09ZT90LmR5bl9sdHJlZVsyKmFdKys6KHQubWF0Y2hlcysrLGUtLSx0LmR5bl9sdHJlZVsyKihhdFthXStUKzEpXSsrLHQuZHluX2R0cmVlWzIqcyhlKV0rKyksdC5sYXN0X2xpdD09PXQubGl0X2J1ZnNpemUtMX0sYS5fdHJfYWxpZ249ZnVuY3Rpb24odCl7bCh0LEQ8PDEsMyksaCh0LFksJCksZih0KX19LHtcIi4uL3V0aWxzL2NvbW1vblwiOjN9XSwxNTpbZnVuY3Rpb24odCxlLGEpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbigpe3RoaXMuaW5wdXQ9bnVsbCx0aGlzLm5leHRfaW49MCx0aGlzLmF2YWlsX2luPTAsdGhpcy50b3RhbF9pbj0wLHRoaXMub3V0cHV0PW51bGwsdGhpcy5uZXh0X291dD0wLHRoaXMuYXZhaWxfb3V0PTAsdGhpcy50b3RhbF9vdXQ9MCx0aGlzLm1zZz1cIlwiLHRoaXMuc3RhdGU9bnVsbCx0aGlzLmRhdGFfdHlwZT0yLHRoaXMuYWRsZXI9MH19LHt9XSxcIi9cIjpbZnVuY3Rpb24odCxlLGEpe1widXNlIHN0cmljdFwiO3ZhciBpPXt9OygwLHQoXCIuL2xpYi91dGlscy9jb21tb25cIikuYXNzaWduKShpLHQoXCIuL2xpYi9kZWZsYXRlXCIpLHQoXCIuL2xpYi9pbmZsYXRlXCIpLHQoXCIuL2xpYi96bGliL2NvbnN0YW50c1wiKSksZS5leHBvcnRzPWl9LHtcIi4vbGliL2RlZmxhdGVcIjoxLFwiLi9saWIvaW5mbGF0ZVwiOjIsXCIuL2xpYi91dGlscy9jb21tb25cIjozLFwiLi9saWIvemxpYi9jb25zdGFudHNcIjo2fV19LHt9LFtdKShcIi9cIil9KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n')},function(module,exports){eval("var __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\n/*!\r\n * https://github.com/Starcounter-Jack/JSON-Patch\r\n * (c) 2017 Joachim Wester\r\n * MIT license\r\n */\r\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\r\nfunction hasOwnProperty(obj, key) {\r\n    return _hasOwnProperty.call(obj, key);\r\n}\r\nexports.hasOwnProperty = hasOwnProperty;\r\nfunction _objectKeys(obj) {\r\n    if (Array.isArray(obj)) {\r\n        var keys = new Array(obj.length);\r\n        for (var k = 0; k < keys.length; k++) {\r\n            keys[k] = \"\" + k;\r\n        }\r\n        return keys;\r\n    }\r\n    if (Object.keys) {\r\n        return Object.keys(obj);\r\n    }\r\n    var keys = [];\r\n    for (var i in obj) {\r\n        if (hasOwnProperty(obj, i)) {\r\n            keys.push(i);\r\n        }\r\n    }\r\n    return keys;\r\n}\r\nexports._objectKeys = _objectKeys;\r\n;\r\n/**\r\n* Deeply clone the object.\r\n* https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)\r\n* @param  {any} obj value to clone\r\n* @return {any} cloned obj\r\n*/\r\nfunction _deepClone(obj) {\r\n    switch (typeof obj) {\r\n        case \"object\":\r\n            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5\r\n        case \"undefined\":\r\n            return null; //this is how JSON.stringify behaves for array items\r\n        default:\r\n            return obj; //no need to clone primitives\r\n    }\r\n}\r\nexports._deepClone = _deepClone;\r\n//3x faster than cached /^\\d+$/.test(str)\r\nfunction isInteger(str) {\r\n    var i = 0;\r\n    var len = str.length;\r\n    var charCode;\r\n    while (i < len) {\r\n        charCode = str.charCodeAt(i);\r\n        if (charCode >= 48 && charCode <= 57) {\r\n            i++;\r\n            continue;\r\n        }\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nexports.isInteger = isInteger;\r\n/**\r\n* Escapes a json pointer path\r\n* @param path The raw pointer\r\n* @return the Escaped path\r\n*/\r\nfunction escapePathComponent(path) {\r\n    if (path.indexOf('/') === -1 && path.indexOf('~') === -1)\r\n        return path;\r\n    return path.replace(/~/g, '~0').replace(/\\//g, '~1');\r\n}\r\nexports.escapePathComponent = escapePathComponent;\r\n/**\r\n * Unescapes a json pointer path\r\n * @param path The escaped pointer\r\n * @return The unescaped path\r\n */\r\nfunction unescapePathComponent(path) {\r\n    return path.replace(/~1/g, '/').replace(/~0/g, '~');\r\n}\r\nexports.unescapePathComponent = unescapePathComponent;\r\nfunction _getPathRecursive(root, obj) {\r\n    var found;\r\n    for (var key in root) {\r\n        if (hasOwnProperty(root, key)) {\r\n            if (root[key] === obj) {\r\n                return escapePathComponent(key) + '/';\r\n            }\r\n            else if (typeof root[key] === 'object') {\r\n                found = _getPathRecursive(root[key], obj);\r\n                if (found != '') {\r\n                    return escapePathComponent(key) + '/' + found;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return '';\r\n}\r\nexports._getPathRecursive = _getPathRecursive;\r\nfunction getPath(root, obj) {\r\n    if (root === obj) {\r\n        return '/';\r\n    }\r\n    var path = _getPathRecursive(root, obj);\r\n    if (path === '') {\r\n        throw new Error(\"Object not found in root\");\r\n    }\r\n    return '/' + path;\r\n}\r\nexports.getPath = getPath;\r\n/**\r\n* Recursively checks whether an object has any undefined values inside.\r\n*/\r\nfunction hasUndefined(obj) {\r\n    if (obj === undefined) {\r\n        return true;\r\n    }\r\n    if (obj) {\r\n        if (Array.isArray(obj)) {\r\n            for (var i = 0, len = obj.length; i < len; i++) {\r\n                if (hasUndefined(obj[i])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        else if (typeof obj === \"object\") {\r\n            var objKeys = _objectKeys(obj);\r\n            var objKeysLength = objKeys.length;\r\n            for (var i = 0; i < objKeysLength; i++) {\r\n                if (hasUndefined(obj[objKeys[i]])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexports.hasUndefined = hasUndefined;\r\nvar PatchError = (function (_super) {\r\n    __extends(PatchError, _super);\r\n    function PatchError(message, name, index, operation, tree) {\r\n        _super.call(this, message);\r\n        this.message = message;\r\n        this.name = name;\r\n        this.index = index;\r\n        this.operation = operation;\r\n        this.tree = tree;\r\n    }\r\n    return PatchError;\r\n}(Error));\r\nexports.PatchError = PatchError;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdGxhc01ha2VyV2lkZ2V0Ly4vbm9kZV9tb2R1bGVzL2Zhc3QtanNvbi1wYXRjaC9saWIvaGVscGVycy5qcz82MjhhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsSUFBSTtBQUNmLFdBQVcsSUFBSTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG4vKiFcclxuICogaHR0cHM6Ly9naXRodWIuY29tL1N0YXJjb3VudGVyLUphY2svSlNPTi1QYXRjaFxyXG4gKiAoYykgMjAxNyBKb2FjaGltIFdlc3RlclxyXG4gKiBNSVQgbGljZW5zZVxyXG4gKi9cclxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwga2V5KSB7XHJcbiAgICByZXR1cm4gX2hhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xyXG59XHJcbmV4cG9ydHMuaGFzT3duUHJvcGVydHkgPSBoYXNPd25Qcm9wZXJ0eTtcclxuZnVuY3Rpb24gX29iamVjdEtleXMob2JqKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XHJcbiAgICAgICAgdmFyIGtleXMgPSBuZXcgQXJyYXkob2JqLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBrZXlzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgIGtleXNba10gPSBcIlwiICsgaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICB9XHJcbiAgICBpZiAoT2JqZWN0LmtleXMpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKTtcclxuICAgIH1cclxuICAgIHZhciBrZXlzID0gW107XHJcbiAgICBmb3IgKHZhciBpIGluIG9iaikge1xyXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShvYmosIGkpKSB7XHJcbiAgICAgICAgICAgIGtleXMucHVzaChpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ga2V5cztcclxufVxyXG5leHBvcnRzLl9vYmplY3RLZXlzID0gX29iamVjdEtleXM7XHJcbjtcclxuLyoqXHJcbiogRGVlcGx5IGNsb25lIHRoZSBvYmplY3QuXHJcbiogaHR0cHM6Ly9qc3BlcmYuY29tL2RlZXAtY29weS12cy1qc29uLXN0cmluZ2lmeS1qc29uLXBhcnNlLzI1IChyZWN1cnNpdmVEZWVwQ29weSlcclxuKiBAcGFyYW0gIHthbnl9IG9iaiB2YWx1ZSB0byBjbG9uZVxyXG4qIEByZXR1cm4ge2FueX0gY2xvbmVkIG9ialxyXG4qL1xyXG5mdW5jdGlvbiBfZGVlcENsb25lKG9iaikge1xyXG4gICAgc3dpdGNoICh0eXBlb2Ygb2JqKSB7XHJcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTsgLy9GYXN0ZXIgdGhhbiBFUzUgY2xvbmUgLSBodHRwOi8vanNwZXJmLmNvbS9kZWVwLWNsb25pbmctb2Ytb2JqZWN0cy81XHJcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy90aGlzIGlzIGhvdyBKU09OLnN0cmluZ2lmeSBiZWhhdmVzIGZvciBhcnJheSBpdGVtc1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7IC8vbm8gbmVlZCB0byBjbG9uZSBwcmltaXRpdmVzXHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5fZGVlcENsb25lID0gX2RlZXBDbG9uZTtcclxuLy8zeCBmYXN0ZXIgdGhhbiBjYWNoZWQgL15cXGQrJC8udGVzdChzdHIpXHJcbmZ1bmN0aW9uIGlzSW50ZWdlcihzdHIpIHtcclxuICAgIHZhciBpID0gMDtcclxuICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xyXG4gICAgdmFyIGNoYXJDb2RlO1xyXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5leHBvcnRzLmlzSW50ZWdlciA9IGlzSW50ZWdlcjtcclxuLyoqXHJcbiogRXNjYXBlcyBhIGpzb24gcG9pbnRlciBwYXRoXHJcbiogQHBhcmFtIHBhdGggVGhlIHJhdyBwb2ludGVyXHJcbiogQHJldHVybiB0aGUgRXNjYXBlZCBwYXRoXHJcbiovXHJcbmZ1bmN0aW9uIGVzY2FwZVBhdGhDb21wb25lbnQocGF0aCkge1xyXG4gICAgaWYgKHBhdGguaW5kZXhPZignLycpID09PSAtMSAmJiBwYXRoLmluZGV4T2YoJ34nKSA9PT0gLTEpXHJcbiAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKTtcclxufVxyXG5leHBvcnRzLmVzY2FwZVBhdGhDb21wb25lbnQgPSBlc2NhcGVQYXRoQ29tcG9uZW50O1xyXG4vKipcclxuICogVW5lc2NhcGVzIGEganNvbiBwb2ludGVyIHBhdGhcclxuICogQHBhcmFtIHBhdGggVGhlIGVzY2FwZWQgcG9pbnRlclxyXG4gKiBAcmV0dXJuIFRoZSB1bmVzY2FwZWQgcGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gdW5lc2NhcGVQYXRoQ29tcG9uZW50KHBhdGgpIHtcclxuICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL34xL2csICcvJykucmVwbGFjZSgvfjAvZywgJ34nKTtcclxufVxyXG5leHBvcnRzLnVuZXNjYXBlUGF0aENvbXBvbmVudCA9IHVuZXNjYXBlUGF0aENvbXBvbmVudDtcclxuZnVuY3Rpb24gX2dldFBhdGhSZWN1cnNpdmUocm9vdCwgb2JqKSB7XHJcbiAgICB2YXIgZm91bmQ7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gcm9vdCkge1xyXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShyb290LCBrZXkpKSB7XHJcbiAgICAgICAgICAgIGlmIChyb290W2tleV0gPT09IG9iaikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSArICcvJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygcm9vdFtrZXldID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgZm91bmQgPSBfZ2V0UGF0aFJlY3Vyc2l2ZShyb290W2tleV0sIG9iaik7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgIT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXNjYXBlUGF0aENvbXBvbmVudChrZXkpICsgJy8nICsgZm91bmQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJyc7XHJcbn1cclxuZXhwb3J0cy5fZ2V0UGF0aFJlY3Vyc2l2ZSA9IF9nZXRQYXRoUmVjdXJzaXZlO1xyXG5mdW5jdGlvbiBnZXRQYXRoKHJvb3QsIG9iaikge1xyXG4gICAgaWYgKHJvb3QgPT09IG9iaikge1xyXG4gICAgICAgIHJldHVybiAnLyc7XHJcbiAgICB9XHJcbiAgICB2YXIgcGF0aCA9IF9nZXRQYXRoUmVjdXJzaXZlKHJvb3QsIG9iaik7XHJcbiAgICBpZiAocGF0aCA9PT0gJycpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3Qgbm90IGZvdW5kIGluIHJvb3RcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJy8nICsgcGF0aDtcclxufVxyXG5leHBvcnRzLmdldFBhdGggPSBnZXRQYXRoO1xyXG4vKipcclxuKiBSZWN1cnNpdmVseSBjaGVja3Mgd2hldGhlciBhbiBvYmplY3QgaGFzIGFueSB1bmRlZmluZWQgdmFsdWVzIGluc2lkZS5cclxuKi9cclxuZnVuY3Rpb24gaGFzVW5kZWZpbmVkKG9iaikge1xyXG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAob2JqKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzVW5kZWZpbmVkKG9ialtpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmpLZXlzID0gX29iamVjdEtleXMob2JqKTtcclxuICAgICAgICAgICAgdmFyIG9iaktleXNMZW5ndGggPSBvYmpLZXlzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmpLZXlzTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChoYXNVbmRlZmluZWQob2JqW29iaktleXNbaV1dKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmV4cG9ydHMuaGFzVW5kZWZpbmVkID0gaGFzVW5kZWZpbmVkO1xyXG52YXIgUGF0Y2hFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUGF0Y2hFcnJvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFBhdGNoRXJyb3IobWVzc2FnZSwgbmFtZSwgaW5kZXgsIG9wZXJhdGlvbiwgdHJlZSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XHJcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcclxuICAgIH1cclxuICAgIHJldHVybiBQYXRjaEVycm9yO1xyXG59KEVycm9yKSk7XHJcbmV4cG9ydHMuUGF0Y2hFcnJvciA9IFBhdGNoRXJyb3I7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n")},function(module,exports,__webpack_require__){eval("var pSlice = Array.prototype.slice;\nvar objectKeys = __webpack_require__(6);\nvar isArguments = __webpack_require__(7);\n\nvar deepEqual = module.exports = function (actual, expected, opts) {\n  if (!opts) opts = {};\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return opts.strict ? actual === expected : actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected, opts);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer (x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') return false;\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b, opts);\n  }\n  if (isBuffer(a)) {\n    if (!isBuffer(b)) {\n      return false;\n    }\n    if (a.length !== b.length) return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdGxhc01ha2VyV2lkZ2V0Ly4vbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvaW5kZXguanM/N2ZhZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLENBQWU7QUFDeEMsa0JBQWtCLG1CQUFPLENBQUMsQ0FBdUI7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFlBQVk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuL2xpYi9rZXlzLmpzJyk7XG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2xpYi9pc19hcmd1bWVudHMuanMnKTtcblxudmFyIGRlZXBFcXVhbCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpIHtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMy4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCB8fCB0eXBlb2YgYWN0dWFsICE9ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvcHRzLnN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAoeCkge1xuICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnIHx8IHR5cGVvZiB4Lmxlbmd0aCAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB4LmNvcHkgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHguc2xpY2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHgubGVuZ3RoID4gMCAmJiB0eXBlb2YgeFswXSAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIG9wdHMpIHtcbiAgdmFyIGksIGtleTtcbiAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKGEpIHx8IGlzVW5kZWZpbmVkT3JOdWxsKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vfn5+SSd2ZSBtYW5hZ2VkIHRvIGJyZWFrIE9iamVjdC5rZXlzIHRocm91Z2ggc2NyZXd5IGFyZ3VtZW50cyBwYXNzaW5nLlxuICAvLyAgIENvbnZlcnRpbmcgdG8gYXJyYXkgc29sdmVzIHRoZSBwcm9ibGVtLlxuICBpZiAoaXNBcmd1bWVudHMoYSkpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIGRlZXBFcXVhbChhLCBiLCBvcHRzKTtcbiAgfVxuICBpZiAoaXNCdWZmZXIoYSkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLFxuICAgICAgICBrYiA9IG9iamVjdEtleXMoYik7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgb3B0cykpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n")},function(module,exports,__webpack_require__){eval("var equalsOptions = { strict: true };\r\nvar _equals = __webpack_require__(3);\r\nvar areEquals = function (a, b) {\r\n    return _equals(a, b, equalsOptions);\r\n};\r\nvar helpers_1 = __webpack_require__(2);\r\nexports.JsonPatchError = helpers_1.PatchError;\r\nexports.deepClone = helpers_1._deepClone;\r\n/* We use a Javascript hash to store each\r\n function. Each hash entry (property) uses\r\n the operation identifiers specified in rfc6902.\r\n In this way, we can map each patch operation\r\n to its dedicated function in efficient way.\r\n */\r\n/* The operations applicable to an object */\r\nvar objOps = {\r\n    add: function (obj, key, document) {\r\n        obj[key] = this.value;\r\n        return { newDocument: document };\r\n    },\r\n    remove: function (obj, key, document) {\r\n        var removed = obj[key];\r\n        delete obj[key];\r\n        return { newDocument: document, removed: removed };\r\n    },\r\n    replace: function (obj, key, document) {\r\n        var removed = obj[key];\r\n        obj[key] = this.value;\r\n        return { newDocument: document, removed: removed };\r\n    },\r\n    move: function (obj, key, document) {\r\n        /* in case move target overwrites an existing value,\r\n        return the removed value, this can be taxing performance-wise,\r\n        and is potentially unneeded */\r\n        var removed = getValueByPointer(document, this.path);\r\n        if (removed) {\r\n            removed = helpers_1._deepClone(removed);\r\n        }\r\n        var originalValue = applyOperation(document, { op: \"remove\", path: this.from }).removed;\r\n        applyOperation(document, { op: \"add\", path: this.path, value: originalValue });\r\n        return { newDocument: document, removed: removed };\r\n    },\r\n    copy: function (obj, key, document) {\r\n        var valueToCopy = getValueByPointer(document, this.from);\r\n        // enforce copy by value so further operations don't affect source (see issue #177)\r\n        applyOperation(document, { op: \"add\", path: this.path, value: helpers_1._deepClone(valueToCopy) });\r\n        return { newDocument: document };\r\n    },\r\n    test: function (obj, key, document) {\r\n        return { newDocument: document, test: areEquals(obj[key], this.value) };\r\n    },\r\n    _get: function (obj, key, document) {\r\n        this.value = obj[key];\r\n        return { newDocument: document };\r\n    }\r\n};\r\n/* The operations applicable to an array. Many are the same as for the object */\r\nvar arrOps = {\r\n    add: function (arr, i, document) {\r\n        if (helpers_1.isInteger(i)) {\r\n            arr.splice(i, 0, this.value);\r\n        }\r\n        else {\r\n            arr[i] = this.value;\r\n        }\r\n        // this may be needed when using '-' in an array\r\n        return { newDocument: document, index: i };\r\n    },\r\n    remove: function (arr, i, document) {\r\n        var removedList = arr.splice(i, 1);\r\n        return { newDocument: document, removed: removedList[0] };\r\n    },\r\n    replace: function (arr, i, document) {\r\n        var removed = arr[i];\r\n        arr[i] = this.value;\r\n        return { newDocument: document, removed: removed };\r\n    },\r\n    move: objOps.move,\r\n    copy: objOps.copy,\r\n    test: objOps.test,\r\n    _get: objOps._get\r\n};\r\n/**\r\n * Retrieves a value from a JSON document by a JSON pointer.\r\n * Returns the value.\r\n *\r\n * @param document The document to get the value from\r\n * @param pointer an escaped JSON pointer\r\n * @return The retrieved value\r\n */\r\nfunction getValueByPointer(document, pointer) {\r\n    if (pointer == '') {\r\n        return document;\r\n    }\r\n    var getOriginalDestination = { op: \"_get\", path: pointer };\r\n    applyOperation(document, getOriginalDestination);\r\n    return getOriginalDestination.value;\r\n}\r\nexports.getValueByPointer = getValueByPointer;\r\n/**\r\n * Apply a single JSON Patch Operation on a JSON document.\r\n * Returns the {newDocument, result} of the operation.\r\n * It modifies the `document` and `operation` objects - it gets the values by reference.\r\n * If you would like to avoid touching your values, clone them:\r\n * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.\r\n *\r\n * @param document The document to patch\r\n * @param operation The operation to apply\r\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\r\n * @param mutateDocument Whether to mutate the original document or clone it before applying\r\n * @return `{newDocument, result}` after the operation\r\n */\r\nfunction applyOperation(document, operation, validateOperation, mutateDocument) {\r\n    if (validateOperation === void 0) { validateOperation = false; }\r\n    if (mutateDocument === void 0) { mutateDocument = true; }\r\n    if (validateOperation) {\r\n        if (typeof validateOperation == 'function') {\r\n            validateOperation(operation, 0, document, operation.path);\r\n        }\r\n        else {\r\n            validator(operation, 0);\r\n        }\r\n    }\r\n    /* ROOT OPERATIONS */\r\n    if (operation.path === \"\") {\r\n        var returnValue = { newDocument: document };\r\n        if (operation.op === 'add') {\r\n            returnValue.newDocument = operation.value;\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === 'replace') {\r\n            returnValue.newDocument = operation.value;\r\n            returnValue.removed = document; //document we removed\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === 'move' || operation.op === 'copy') {\r\n            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field\r\n            if (operation.op === 'move') {\r\n                returnValue.removed = document;\r\n            }\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === 'test') {\r\n            returnValue.test = areEquals(document, operation.value);\r\n            if (returnValue.test === false) {\r\n                throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\r\n            }\r\n            returnValue.newDocument = document;\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === 'remove') {\r\n            returnValue.removed = document;\r\n            returnValue.newDocument = null;\r\n            return returnValue;\r\n        }\r\n        else if (operation.op === '_get') {\r\n            operation.value = document;\r\n            return returnValue;\r\n        }\r\n        else {\r\n            if (validateOperation) {\r\n                throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', 0, operation, document);\r\n            }\r\n            else {\r\n                return returnValue;\r\n            }\r\n        }\r\n    } /* END ROOT OPERATIONS */\r\n    else {\r\n        if (!mutateDocument) {\r\n            document = helpers_1._deepClone(document);\r\n        }\r\n        var path = operation.path || \"\";\r\n        var keys = path.split('/');\r\n        var obj = document;\r\n        var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift\r\n        var len = keys.length;\r\n        var existingPathFragment = undefined;\r\n        var key = void 0;\r\n        var validateFunction = void 0;\r\n        if (typeof validateOperation == 'function') {\r\n            validateFunction = validateOperation;\r\n        }\r\n        else {\r\n            validateFunction = validator;\r\n        }\r\n        while (true) {\r\n            key = keys[t];\r\n            if (validateOperation) {\r\n                if (existingPathFragment === undefined) {\r\n                    if (obj[key] === undefined) {\r\n                        existingPathFragment = keys.slice(0, t).join('/');\r\n                    }\r\n                    else if (t == len - 1) {\r\n                        existingPathFragment = operation.path;\r\n                    }\r\n                    if (existingPathFragment !== undefined) {\r\n                        validateFunction(operation, 0, document, existingPathFragment);\r\n                    }\r\n                }\r\n            }\r\n            t++;\r\n            if (Array.isArray(obj)) {\r\n                if (key === '-') {\r\n                    key = obj.length;\r\n                }\r\n                else {\r\n                    if (validateOperation && !helpers_1.isInteger(key)) {\r\n                        throw new exports.JsonPatchError(\"Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index\", \"OPERATION_PATH_ILLEGAL_ARRAY_INDEX\", 0, operation.path, operation);\r\n                    } // only parse key when it's an integer for `arr.prop` to work\r\n                    else if (helpers_1.isInteger(key)) {\r\n                        key = ~~key;\r\n                    }\r\n                }\r\n                if (t >= len) {\r\n                    if (validateOperation && operation.op === \"add\" && key > obj.length) {\r\n                        throw new exports.JsonPatchError(\"The specified index MUST NOT be greater than the number of elements in the array\", \"OPERATION_VALUE_OUT_OF_BOUNDS\", 0, operation.path, operation);\r\n                    }\r\n                    var returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch\r\n                    if (returnValue.test === false) {\r\n                        throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\r\n                    }\r\n                    return returnValue;\r\n                }\r\n            }\r\n            else {\r\n                if (key && key.indexOf('~') != -1) {\r\n                    key = helpers_1.unescapePathComponent(key);\r\n                }\r\n                if (t >= len) {\r\n                    var returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch\r\n                    if (returnValue.test === false) {\r\n                        throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\r\n                    }\r\n                    return returnValue;\r\n                }\r\n            }\r\n            obj = obj[key];\r\n        }\r\n    }\r\n}\r\nexports.applyOperation = applyOperation;\r\n/**\r\n * Apply a full JSON Patch array on a JSON document.\r\n * Returns the {newDocument, result} of the patch.\r\n * It modifies the `document` object and `patch` - it gets the values by reference.\r\n * If you would like to avoid touching your values, clone them:\r\n * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.\r\n *\r\n * @param document The document to patch\r\n * @param patch The patch to apply\r\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\r\n * @param mutateDocument Whether to mutate the original document or clone it before applying\r\n * @return An array of `{newDocument, result}` after the patch\r\n */\r\nfunction applyPatch(document, patch, validateOperation, mutateDocument) {\r\n    if (mutateDocument === void 0) { mutateDocument = true; }\r\n    if (validateOperation) {\r\n        if (!Array.isArray(patch)) {\r\n            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');\r\n        }\r\n    }\r\n    if (!mutateDocument) {\r\n        document = helpers_1._deepClone(document);\r\n    }\r\n    var results = new Array(patch.length);\r\n    for (var i = 0, length_1 = patch.length; i < length_1; i++) {\r\n        results[i] = applyOperation(document, patch[i], validateOperation);\r\n        document = results[i].newDocument; // in case root was replaced\r\n    }\r\n    results.newDocument = document;\r\n    return results;\r\n}\r\nexports.applyPatch = applyPatch;\r\n/**\r\n * Apply a single JSON Patch Operation on a JSON document.\r\n * Returns the updated document.\r\n * Suitable as a reducer.\r\n *\r\n * @param document The document to patch\r\n * @param operation The operation to apply\r\n * @return The updated document\r\n */\r\nfunction applyReducer(document, operation) {\r\n    var operationResult = applyOperation(document, operation);\r\n    if (operationResult.test === false) {\r\n        throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', 0, operation, document);\r\n    }\r\n    return operationResult.newDocument;\r\n}\r\nexports.applyReducer = applyReducer;\r\n/**\r\n * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.\r\n * @param {object} operation - operation object (patch)\r\n * @param {number} index - index of operation in the sequence\r\n * @param {object} [document] - object where the operation is supposed to be applied\r\n * @param {string} [existingPathFragment] - comes along with `document`\r\n */\r\nfunction validator(operation, index, document, existingPathFragment) {\r\n    if (typeof operation !== 'object' || operation === null || Array.isArray(operation)) {\r\n        throw new exports.JsonPatchError('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', index, operation, document);\r\n    }\r\n    else if (!objOps[operation.op]) {\r\n        throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);\r\n    }\r\n    else if (typeof operation.path !== 'string') {\r\n        throw new exports.JsonPatchError('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', index, operation, document);\r\n    }\r\n    else if (operation.path.indexOf('/') !== 0 && operation.path.length > 0) {\r\n        // paths that aren't empty string should start with \"/\"\r\n        throw new exports.JsonPatchError('Operation `path` property must start with \"/\"', 'OPERATION_PATH_INVALID', index, operation, document);\r\n    }\r\n    else if ((operation.op === 'move' || operation.op === 'copy') && typeof operation.from !== 'string') {\r\n        throw new exports.JsonPatchError('Operation `from` property is not present (applicable in `move` and `copy` operations)', 'OPERATION_FROM_REQUIRED', index, operation, document);\r\n    }\r\n    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && operation.value === undefined) {\r\n        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_REQUIRED', index, operation, document);\r\n    }\r\n    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && helpers_1.hasUndefined(operation.value)) {\r\n        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED', index, operation, document);\r\n    }\r\n    else if (document) {\r\n        if (operation.op == \"add\") {\r\n            var pathLen = operation.path.split(\"/\").length;\r\n            var existingPathLen = existingPathFragment.split(\"/\").length;\r\n            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {\r\n                throw new exports.JsonPatchError('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', index, operation, document);\r\n            }\r\n        }\r\n        else if (operation.op === 'replace' || operation.op === 'remove' || operation.op === '_get') {\r\n            if (operation.path !== existingPathFragment) {\r\n                throw new exports.JsonPatchError('Cannot perform the operation at a path that does not exist', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);\r\n            }\r\n        }\r\n        else if (operation.op === 'move' || operation.op === 'copy') {\r\n            var existingValue = { op: \"_get\", path: operation.from, value: undefined };\r\n            var error = validate([existingValue], document);\r\n            if (error && error.name === 'OPERATION_PATH_UNRESOLVABLE') {\r\n                throw new exports.JsonPatchError('Cannot perform the operation from a path that does not exist', 'OPERATION_FROM_UNRESOLVABLE', index, operation, document);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.validator = validator;\r\n/**\r\n * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.\r\n * If error is encountered, returns a JsonPatchError object\r\n * @param sequence\r\n * @param document\r\n * @returns {JsonPatchError|undefined}\r\n */\r\nfunction validate(sequence, document, externalValidator) {\r\n    try {\r\n        if (!Array.isArray(sequence)) {\r\n            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');\r\n        }\r\n        if (document) {\r\n            //clone document and sequence so that we can safely try applying operations\r\n            applyPatch(helpers_1._deepClone(document), helpers_1._deepClone(sequence), externalValidator || true);\r\n        }\r\n        else {\r\n            externalValidator = externalValidator || validator;\r\n            for (var i = 0; i < sequence.length; i++) {\r\n                externalValidator(sequence[i], i, document, undefined);\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        if (e instanceof exports.JsonPatchError) {\r\n            return e;\r\n        }\r\n        else {\r\n            throw e;\r\n        }\r\n    }\r\n}\r\nexports.validate = validate;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdGxhc01ha2VyV2lkZ2V0Ly4vbm9kZV9tb2R1bGVzL2Zhc3QtanNvbi1wYXRjaC9saWIvY29yZS5qcz8yZjEyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLHFCQUFxQjtBQUNyQixjQUFjLG1CQUFPLENBQUMsQ0FBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxDQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZ0NBQWdDO0FBQ3RGLGtDQUFrQyxtREFBbUQ7QUFDckYsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUVBQXVFO0FBQ3pHLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBLHVDQUF1QywyQkFBMkI7QUFDbEUsb0NBQW9DLHVCQUF1QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9CQUFvQjtBQUM3QztBQUNBO0FBQ0Esb0NBQW9DLHVCQUF1QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBlcXVhbHNPcHRpb25zID0geyBzdHJpY3Q6IHRydWUgfTtcclxudmFyIF9lcXVhbHMgPSByZXF1aXJlKCdkZWVwLWVxdWFsJyk7XHJcbnZhciBhcmVFcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgcmV0dXJuIF9lcXVhbHMoYSwgYiwgZXF1YWxzT3B0aW9ucyk7XHJcbn07XHJcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcclxuZXhwb3J0cy5Kc29uUGF0Y2hFcnJvciA9IGhlbHBlcnNfMS5QYXRjaEVycm9yO1xyXG5leHBvcnRzLmRlZXBDbG9uZSA9IGhlbHBlcnNfMS5fZGVlcENsb25lO1xyXG4vKiBXZSB1c2UgYSBKYXZhc2NyaXB0IGhhc2ggdG8gc3RvcmUgZWFjaFxyXG4gZnVuY3Rpb24uIEVhY2ggaGFzaCBlbnRyeSAocHJvcGVydHkpIHVzZXNcclxuIHRoZSBvcGVyYXRpb24gaWRlbnRpZmllcnMgc3BlY2lmaWVkIGluIHJmYzY5MDIuXHJcbiBJbiB0aGlzIHdheSwgd2UgY2FuIG1hcCBlYWNoIHBhdGNoIG9wZXJhdGlvblxyXG4gdG8gaXRzIGRlZGljYXRlZCBmdW5jdGlvbiBpbiBlZmZpY2llbnQgd2F5LlxyXG4gKi9cclxuLyogVGhlIG9wZXJhdGlvbnMgYXBwbGljYWJsZSB0byBhbiBvYmplY3QgKi9cclxudmFyIG9iak9wcyA9IHtcclxuICAgIGFkZDogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xyXG4gICAgICAgIG9ialtrZXldID0gdGhpcy52YWx1ZTtcclxuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcclxuICAgIH0sXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcclxuICAgICAgICB2YXIgcmVtb3ZlZCA9IG9ialtrZXldO1xyXG4gICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcclxuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcclxuICAgIH0sXHJcbiAgICByZXBsYWNlOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XHJcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBvYmpba2V5XTtcclxuICAgICAgICBvYmpba2V5XSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkOiByZW1vdmVkIH07XHJcbiAgICB9LFxyXG4gICAgbW92ZTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xyXG4gICAgICAgIC8qIGluIGNhc2UgbW92ZSB0YXJnZXQgb3ZlcndyaXRlcyBhbiBleGlzdGluZyB2YWx1ZSxcclxuICAgICAgICByZXR1cm4gdGhlIHJlbW92ZWQgdmFsdWUsIHRoaXMgY2FuIGJlIHRheGluZyBwZXJmb3JtYW5jZS13aXNlLFxyXG4gICAgICAgIGFuZCBpcyBwb3RlbnRpYWxseSB1bm5lZWRlZCAqL1xyXG4gICAgICAgIHZhciByZW1vdmVkID0gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIHRoaXMucGF0aCk7XHJcbiAgICAgICAgaWYgKHJlbW92ZWQpIHtcclxuICAgICAgICAgICAgcmVtb3ZlZCA9IGhlbHBlcnNfMS5fZGVlcENsb25lKHJlbW92ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCB7IG9wOiBcInJlbW92ZVwiLCBwYXRoOiB0aGlzLmZyb20gfSkucmVtb3ZlZDtcclxuICAgICAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgeyBvcDogXCJhZGRcIiwgcGF0aDogdGhpcy5wYXRoLCB2YWx1ZTogb3JpZ2luYWxWYWx1ZSB9KTtcclxuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcclxuICAgIH0sXHJcbiAgICBjb3B5OiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XHJcbiAgICAgICAgdmFyIHZhbHVlVG9Db3B5ID0gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIHRoaXMuZnJvbSk7XHJcbiAgICAgICAgLy8gZW5mb3JjZSBjb3B5IGJ5IHZhbHVlIHNvIGZ1cnRoZXIgb3BlcmF0aW9ucyBkb24ndCBhZmZlY3Qgc291cmNlIChzZWUgaXNzdWUgIzE3NylcclxuICAgICAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgeyBvcDogXCJhZGRcIiwgcGF0aDogdGhpcy5wYXRoLCB2YWx1ZTogaGVscGVyc18xLl9kZWVwQ2xvbmUodmFsdWVUb0NvcHkpIH0pO1xyXG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xyXG4gICAgfSxcclxuICAgIHRlc3Q6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcclxuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHRlc3Q6IGFyZUVxdWFscyhvYmpba2V5XSwgdGhpcy52YWx1ZSkgfTtcclxuICAgIH0sXHJcbiAgICBfZ2V0OiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IG9ialtrZXldO1xyXG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xyXG4gICAgfVxyXG59O1xyXG4vKiBUaGUgb3BlcmF0aW9ucyBhcHBsaWNhYmxlIHRvIGFuIGFycmF5LiBNYW55IGFyZSB0aGUgc2FtZSBhcyBmb3IgdGhlIG9iamVjdCAqL1xyXG52YXIgYXJyT3BzID0ge1xyXG4gICAgYWRkOiBmdW5jdGlvbiAoYXJyLCBpLCBkb2N1bWVudCkge1xyXG4gICAgICAgIGlmIChoZWxwZXJzXzEuaXNJbnRlZ2VyKGkpKSB7XHJcbiAgICAgICAgICAgIGFyci5zcGxpY2UoaSwgMCwgdGhpcy52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhcnJbaV0gPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0aGlzIG1heSBiZSBuZWVkZWQgd2hlbiB1c2luZyAnLScgaW4gYW4gYXJyYXlcclxuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIGluZGV4OiBpIH07XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoYXJyLCBpLCBkb2N1bWVudCkge1xyXG4gICAgICAgIHZhciByZW1vdmVkTGlzdCA9IGFyci5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkOiByZW1vdmVkTGlzdFswXSB9O1xyXG4gICAgfSxcclxuICAgIHJlcGxhY2U6IGZ1bmN0aW9uIChhcnIsIGksIGRvY3VtZW50KSB7XHJcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBhcnJbaV07XHJcbiAgICAgICAgYXJyW2ldID0gdGhpcy52YWx1ZTtcclxuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcclxuICAgIH0sXHJcbiAgICBtb3ZlOiBvYmpPcHMubW92ZSxcclxuICAgIGNvcHk6IG9iak9wcy5jb3B5LFxyXG4gICAgdGVzdDogb2JqT3BzLnRlc3QsXHJcbiAgICBfZ2V0OiBvYmpPcHMuX2dldFxyXG59O1xyXG4vKipcclxuICogUmV0cmlldmVzIGEgdmFsdWUgZnJvbSBhIEpTT04gZG9jdW1lbnQgYnkgYSBKU09OIHBvaW50ZXIuXHJcbiAqIFJldHVybnMgdGhlIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IHRvIGdldCB0aGUgdmFsdWUgZnJvbVxyXG4gKiBAcGFyYW0gcG9pbnRlciBhbiBlc2NhcGVkIEpTT04gcG9pbnRlclxyXG4gKiBAcmV0dXJuIFRoZSByZXRyaWV2ZWQgdmFsdWVcclxuICovXHJcbmZ1bmN0aW9uIGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCBwb2ludGVyKSB7XHJcbiAgICBpZiAocG9pbnRlciA9PSAnJykge1xyXG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcclxuICAgIH1cclxuICAgIHZhciBnZXRPcmlnaW5hbERlc3RpbmF0aW9uID0geyBvcDogXCJfZ2V0XCIsIHBhdGg6IHBvaW50ZXIgfTtcclxuICAgIGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCBnZXRPcmlnaW5hbERlc3RpbmF0aW9uKTtcclxuICAgIHJldHVybiBnZXRPcmlnaW5hbERlc3RpbmF0aW9uLnZhbHVlO1xyXG59XHJcbmV4cG9ydHMuZ2V0VmFsdWVCeVBvaW50ZXIgPSBnZXRWYWx1ZUJ5UG9pbnRlcjtcclxuLyoqXHJcbiAqIEFwcGx5IGEgc2luZ2xlIEpTT04gUGF0Y2ggT3BlcmF0aW9uIG9uIGEgSlNPTiBkb2N1bWVudC5cclxuICogUmV0dXJucyB0aGUge25ld0RvY3VtZW50LCByZXN1bHR9IG9mIHRoZSBvcGVyYXRpb24uXHJcbiAqIEl0IG1vZGlmaWVzIHRoZSBgZG9jdW1lbnRgIGFuZCBgb3BlcmF0aW9uYCBvYmplY3RzIC0gaXQgZ2V0cyB0aGUgdmFsdWVzIGJ5IHJlZmVyZW5jZS5cclxuICogSWYgeW91IHdvdWxkIGxpa2UgdG8gYXZvaWQgdG91Y2hpbmcgeW91ciB2YWx1ZXMsIGNsb25lIHRoZW06XHJcbiAqIGBqc29ucGF0Y2guYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIGpzb25wYXRjaC5fZGVlcENsb25lKG9wZXJhdGlvbikpYC5cclxuICpcclxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxyXG4gKiBAcGFyYW0gb3BlcmF0aW9uIFRoZSBvcGVyYXRpb24gdG8gYXBwbHlcclxuICogQHBhcmFtIHZhbGlkYXRlT3BlcmF0aW9uIGBmYWxzZWAgaXMgd2l0aG91dCB2YWxpZGF0aW9uLCBgdHJ1ZWAgdG8gdXNlIGRlZmF1bHQganNvbnBhdGNoJ3MgdmFsaWRhdGlvbiwgb3IgeW91IGNhbiBwYXNzIGEgYHZhbGlkYXRlT3BlcmF0aW9uYCBjYWxsYmFjayB0byBiZSB1c2VkIGZvciB2YWxpZGF0aW9uLlxyXG4gKiBAcGFyYW0gbXV0YXRlRG9jdW1lbnQgV2hldGhlciB0byBtdXRhdGUgdGhlIG9yaWdpbmFsIGRvY3VtZW50IG9yIGNsb25lIGl0IGJlZm9yZSBhcHBseWluZ1xyXG4gKiBAcmV0dXJuIGB7bmV3RG9jdW1lbnQsIHJlc3VsdH1gIGFmdGVyIHRoZSBvcGVyYXRpb25cclxuICovXHJcbmZ1bmN0aW9uIGFwcGx5T3BlcmF0aW9uKGRvY3VtZW50LCBvcGVyYXRpb24sIHZhbGlkYXRlT3BlcmF0aW9uLCBtdXRhdGVEb2N1bWVudCkge1xyXG4gICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uID09PSB2b2lkIDApIHsgdmFsaWRhdGVPcGVyYXRpb24gPSBmYWxzZTsgfVxyXG4gICAgaWYgKG11dGF0ZURvY3VtZW50ID09PSB2b2lkIDApIHsgbXV0YXRlRG9jdW1lbnQgPSB0cnVlOyB9XHJcbiAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRlT3BlcmF0aW9uID09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVPcGVyYXRpb24ob3BlcmF0aW9uLCAwLCBkb2N1bWVudCwgb3BlcmF0aW9uLnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFsaWRhdG9yKG9wZXJhdGlvbiwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyogUk9PVCBPUEVSQVRJT05TICovXHJcbiAgICBpZiAob3BlcmF0aW9uLnBhdGggPT09IFwiXCIpIHtcclxuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xyXG4gICAgICAgIGlmIChvcGVyYXRpb24ub3AgPT09ICdhZGQnKSB7XHJcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gb3BlcmF0aW9uLnZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ3JlcGxhY2UnKSB7XHJcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gb3BlcmF0aW9uLnZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5yZW1vdmVkID0gZG9jdW1lbnQ7IC8vZG9jdW1lbnQgd2UgcmVtb3ZlZFxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ21vdmUnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ2NvcHknKSB7XHJcbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIG9wZXJhdGlvbi5mcm9tKTsgLy8gZ2V0IHRoZSB2YWx1ZSBieSBqc29uLXBvaW50ZXIgaW4gYGZyb21gIGZpZWxkXHJcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ub3AgPT09ICdtb3ZlJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUucmVtb3ZlZCA9IGRvY3VtZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAndGVzdCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuVmFsdWUudGVzdCA9IGFyZUVxdWFscyhkb2N1bWVudCwgb3BlcmF0aW9uLnZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCAnVEVTVF9PUEVSQVRJT05fRkFJTEVEJywgMCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBkb2N1bWVudDtcclxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24ub3AgPT09ICdyZW1vdmUnKSB7XHJcbiAgICAgICAgICAgIHJldHVyblZhbHVlLnJlbW92ZWQgPSBkb2N1bWVudDtcclxuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gJ19nZXQnKSB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbi52YWx1ZSA9IGRvY3VtZW50O1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYG9wYCBwcm9wZXJ0eSBpcyBub3Qgb25lIG9mIG9wZXJhdGlvbnMgZGVmaW5lZCBpbiBSRkMtNjkwMicsICdPUEVSQVRJT05fT1BfSU5WQUxJRCcsIDAsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSAvKiBFTkQgUk9PVCBPUEVSQVRJT05TICovXHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoIW11dGF0ZURvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50ID0gaGVscGVyc18xLl9kZWVwQ2xvbmUoZG9jdW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGF0aCA9IG9wZXJhdGlvbi5wYXRoIHx8IFwiXCI7XHJcbiAgICAgICAgdmFyIGtleXMgPSBwYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgdmFyIG9iaiA9IGRvY3VtZW50O1xyXG4gICAgICAgIHZhciB0ID0gMTsgLy9za2lwIGVtcHR5IGVsZW1lbnQgLSBodHRwOi8vanNwZXJmLmNvbS90by1zaGlmdC1vci1ub3QtdG8tc2hpZnRcclxuICAgICAgICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGV4aXN0aW5nUGF0aEZyYWdtZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHZhciBrZXkgPSB2b2lkIDA7XHJcbiAgICAgICAgdmFyIHZhbGlkYXRlRnVuY3Rpb24gPSB2b2lkIDA7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWxpZGF0ZU9wZXJhdGlvbiA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb24gPSB2YWxpZGF0ZU9wZXJhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb24gPSB2YWxpZGF0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGtleSA9IGtleXNbdF07XHJcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nUGF0aEZyYWdtZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2JqW2tleV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1BhdGhGcmFnbWVudCA9IGtleXMuc2xpY2UoMCwgdCkuam9pbignLycpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0ID09IGxlbiAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSBvcGVyYXRpb24ucGF0aDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nUGF0aEZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbihvcGVyYXRpb24sIDAsIGRvY3VtZW50LCBleGlzdGluZ1BhdGhGcmFnbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHQrKztcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJy0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gb2JqLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbiAmJiAhaGVscGVyc18xLmlzSW50ZWdlcihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKFwiRXhwZWN0ZWQgYW4gdW5zaWduZWQgYmFzZS0xMCBpbnRlZ2VyIHZhbHVlLCBtYWtpbmcgdGhlIG5ldyByZWZlcmVuY2VkIHZhbHVlIHRoZSBhcnJheSBlbGVtZW50IHdpdGggdGhlIHplcm8tYmFzZWQgaW5kZXhcIiwgXCJPUEVSQVRJT05fUEFUSF9JTExFR0FMX0FSUkFZX0lOREVYXCIsIDAsIG9wZXJhdGlvbi5wYXRoLCBvcGVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gLy8gb25seSBwYXJzZSBrZXkgd2hlbiBpdCdzIGFuIGludGVnZXIgZm9yIGBhcnIucHJvcGAgdG8gd29ya1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhlbHBlcnNfMS5pc0ludGVnZXIoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSB+fmtleTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodCA+PSBsZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24gJiYgb3BlcmF0aW9uLm9wID09PSBcImFkZFwiICYmIGtleSA+IG9iai5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJUaGUgc3BlY2lmaWVkIGluZGV4IE1VU1QgTk9UIGJlIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheVwiLCBcIk9QRVJBVElPTl9WQUxVRV9PVVRfT0ZfQk9VTkRTXCIsIDAsIG9wZXJhdGlvbi5wYXRoLCBvcGVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBhcnJPcHNbb3BlcmF0aW9uLm9wXS5jYWxsKG9wZXJhdGlvbiwgb2JqLCBrZXksIGRvY3VtZW50KTsgLy8gQXBwbHkgcGF0Y2hcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUudGVzdCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgJ1RFU1RfT1BFUkFUSU9OX0ZBSUxFRCcsIDAsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICYmIGtleS5pbmRleE9mKCd+JykgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBoZWxwZXJzXzEudW5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodCA+PSBsZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBvYmpPcHNbb3BlcmF0aW9uLm9wXS5jYWxsKG9wZXJhdGlvbiwgb2JqLCBrZXksIGRvY3VtZW50KTsgLy8gQXBwbHkgcGF0Y2hcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUudGVzdCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgJ1RFU1RfT1BFUkFUSU9OX0ZBSUxFRCcsIDAsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2JqID0gb2JqW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuYXBwbHlPcGVyYXRpb24gPSBhcHBseU9wZXJhdGlvbjtcclxuLyoqXHJcbiAqIEFwcGx5IGEgZnVsbCBKU09OIFBhdGNoIGFycmF5IG9uIGEgSlNPTiBkb2N1bWVudC5cclxuICogUmV0dXJucyB0aGUge25ld0RvY3VtZW50LCByZXN1bHR9IG9mIHRoZSBwYXRjaC5cclxuICogSXQgbW9kaWZpZXMgdGhlIGBkb2N1bWVudGAgb2JqZWN0IGFuZCBgcGF0Y2hgIC0gaXQgZ2V0cyB0aGUgdmFsdWVzIGJ5IHJlZmVyZW5jZS5cclxuICogSWYgeW91IHdvdWxkIGxpa2UgdG8gYXZvaWQgdG91Y2hpbmcgeW91ciB2YWx1ZXMsIGNsb25lIHRoZW06XHJcbiAqIGBqc29ucGF0Y2guYXBwbHlQYXRjaChkb2N1bWVudCwganNvbnBhdGNoLl9kZWVwQ2xvbmUocGF0Y2gpKWAuXHJcbiAqXHJcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcclxuICogQHBhcmFtIHBhdGNoIFRoZSBwYXRjaCB0byBhcHBseVxyXG4gKiBAcGFyYW0gdmFsaWRhdGVPcGVyYXRpb24gYGZhbHNlYCBpcyB3aXRob3V0IHZhbGlkYXRpb24sIGB0cnVlYCB0byB1c2UgZGVmYXVsdCBqc29ucGF0Y2gncyB2YWxpZGF0aW9uLCBvciB5b3UgY2FuIHBhc3MgYSBgdmFsaWRhdGVPcGVyYXRpb25gIGNhbGxiYWNrIHRvIGJlIHVzZWQgZm9yIHZhbGlkYXRpb24uXHJcbiAqIEBwYXJhbSBtdXRhdGVEb2N1bWVudCBXaGV0aGVyIHRvIG11dGF0ZSB0aGUgb3JpZ2luYWwgZG9jdW1lbnQgb3IgY2xvbmUgaXQgYmVmb3JlIGFwcGx5aW5nXHJcbiAqIEByZXR1cm4gQW4gYXJyYXkgb2YgYHtuZXdEb2N1bWVudCwgcmVzdWx0fWAgYWZ0ZXIgdGhlIHBhdGNoXHJcbiAqL1xyXG5mdW5jdGlvbiBhcHBseVBhdGNoKGRvY3VtZW50LCBwYXRjaCwgdmFsaWRhdGVPcGVyYXRpb24sIG11dGF0ZURvY3VtZW50KSB7XHJcbiAgICBpZiAobXV0YXRlRG9jdW1lbnQgPT09IHZvaWQgMCkgeyBtdXRhdGVEb2N1bWVudCA9IHRydWU7IH1cclxuICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbikge1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXRjaCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ1BhdGNoIHNlcXVlbmNlIG11c3QgYmUgYW4gYXJyYXknLCAnU0VRVUVOQ0VfTk9UX0FOX0FSUkFZJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFtdXRhdGVEb2N1bWVudCkge1xyXG4gICAgICAgIGRvY3VtZW50ID0gaGVscGVyc18xLl9kZWVwQ2xvbmUoZG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkocGF0Y2gubGVuZ3RoKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGhfMSA9IHBhdGNoLmxlbmd0aDsgaSA8IGxlbmd0aF8xOyBpKyspIHtcclxuICAgICAgICByZXN1bHRzW2ldID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHBhdGNoW2ldLCB2YWxpZGF0ZU9wZXJhdGlvbik7XHJcbiAgICAgICAgZG9jdW1lbnQgPSByZXN1bHRzW2ldLm5ld0RvY3VtZW50OyAvLyBpbiBjYXNlIHJvb3Qgd2FzIHJlcGxhY2VkXHJcbiAgICB9XHJcbiAgICByZXN1bHRzLm5ld0RvY3VtZW50ID0gZG9jdW1lbnQ7XHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxufVxyXG5leHBvcnRzLmFwcGx5UGF0Y2ggPSBhcHBseVBhdGNoO1xyXG4vKipcclxuICogQXBwbHkgYSBzaW5nbGUgSlNPTiBQYXRjaCBPcGVyYXRpb24gb24gYSBKU09OIGRvY3VtZW50LlxyXG4gKiBSZXR1cm5zIHRoZSB1cGRhdGVkIGRvY3VtZW50LlxyXG4gKiBTdWl0YWJsZSBhcyBhIHJlZHVjZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcclxuICogQHBhcmFtIG9wZXJhdGlvbiBUaGUgb3BlcmF0aW9uIHRvIGFwcGx5XHJcbiAqIEByZXR1cm4gVGhlIHVwZGF0ZWQgZG9jdW1lbnRcclxuICovXHJcbmZ1bmN0aW9uIGFwcGx5UmVkdWNlcihkb2N1bWVudCwgb3BlcmF0aW9uKSB7XHJcbiAgICB2YXIgb3BlcmF0aW9uUmVzdWx0ID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIG9wZXJhdGlvbik7XHJcbiAgICBpZiAob3BlcmF0aW9uUmVzdWx0LnRlc3QgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgJ1RFU1RfT1BFUkFUSU9OX0ZBSUxFRCcsIDAsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9wZXJhdGlvblJlc3VsdC5uZXdEb2N1bWVudDtcclxufVxyXG5leHBvcnRzLmFwcGx5UmVkdWNlciA9IGFwcGx5UmVkdWNlcjtcclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBhIHNpbmdsZSBvcGVyYXRpb24uIENhbGxlZCBmcm9tIGBqc29ucGF0Y2gudmFsaWRhdGVgLiBUaHJvd3MgYEpzb25QYXRjaEVycm9yYCBpbiBjYXNlIG9mIGFuIGVycm9yLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gb3BlcmF0aW9uIC0gb3BlcmF0aW9uIG9iamVjdCAocGF0Y2gpXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4IG9mIG9wZXJhdGlvbiBpbiB0aGUgc2VxdWVuY2VcclxuICogQHBhcmFtIHtvYmplY3R9IFtkb2N1bWVudF0gLSBvYmplY3Qgd2hlcmUgdGhlIG9wZXJhdGlvbiBpcyBzdXBwb3NlZCB0byBiZSBhcHBsaWVkXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXhpc3RpbmdQYXRoRnJhZ21lbnRdIC0gY29tZXMgYWxvbmcgd2l0aCBgZG9jdW1lbnRgXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0b3Iob3BlcmF0aW9uLCBpbmRleCwgZG9jdW1lbnQsIGV4aXN0aW5nUGF0aEZyYWdtZW50KSB7XHJcbiAgICBpZiAodHlwZW9mIG9wZXJhdGlvbiAhPT0gJ29iamVjdCcgfHwgb3BlcmF0aW9uID09PSBudWxsIHx8IEFycmF5LmlzQXJyYXkob3BlcmF0aW9uKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gaXMgbm90IGFuIG9iamVjdCcsICdPUEVSQVRJT05fTk9UX0FOX09CSkVDVCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFvYmpPcHNbb3BlcmF0aW9uLm9wXSkge1xyXG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYG9wYCBwcm9wZXJ0eSBpcyBub3Qgb25lIG9mIG9wZXJhdGlvbnMgZGVmaW5lZCBpbiBSRkMtNjkwMicsICdPUEVSQVRJT05fT1BfSU5WQUxJRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBvcGVyYXRpb24ucGF0aCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGBwYXRoYCBwcm9wZXJ0eSBpcyBub3QgYSBzdHJpbmcnLCAnT1BFUkFUSU9OX1BBVEhfSU5WQUxJRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5wYXRoLmluZGV4T2YoJy8nKSAhPT0gMCAmJiBvcGVyYXRpb24ucGF0aC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gcGF0aHMgdGhhdCBhcmVuJ3QgZW1wdHkgc3RyaW5nIHNob3VsZCBzdGFydCB3aXRoIFwiL1wiXHJcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ09wZXJhdGlvbiBgcGF0aGAgcHJvcGVydHkgbXVzdCBzdGFydCB3aXRoIFwiL1wiJywgJ09QRVJBVElPTl9QQVRIX0lOVkFMSUQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgob3BlcmF0aW9uLm9wID09PSAnbW92ZScgfHwgb3BlcmF0aW9uLm9wID09PSAnY29weScpICYmIHR5cGVvZiBvcGVyYXRpb24uZnJvbSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGBmcm9tYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgbW92ZWAgYW5kIGBjb3B5YCBvcGVyYXRpb25zKScsICdPUEVSQVRJT05fRlJPTV9SRVFVSVJFRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChvcGVyYXRpb24ub3AgPT09ICdhZGQnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ3JlcGxhY2UnIHx8IG9wZXJhdGlvbi5vcCA9PT0gJ3Rlc3QnKSAmJiBvcGVyYXRpb24udmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYHZhbHVlYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgYWRkYCwgYHJlcGxhY2VgIGFuZCBgdGVzdGAgb3BlcmF0aW9ucyknLCAnT1BFUkFUSU9OX1ZBTFVFX1JFUVVJUkVEJywgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gJ2FkZCcgfHwgb3BlcmF0aW9uLm9wID09PSAncmVwbGFjZScgfHwgb3BlcmF0aW9uLm9wID09PSAndGVzdCcpICYmIGhlbHBlcnNfMS5oYXNVbmRlZmluZWQob3BlcmF0aW9uLnZhbHVlKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkpzb25QYXRjaEVycm9yKCdPcGVyYXRpb24gYHZhbHVlYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgYWRkYCwgYHJlcGxhY2VgIGFuZCBgdGVzdGAgb3BlcmF0aW9ucyknLCAnT1BFUkFUSU9OX1ZBTFVFX0NBTk5PVF9DT05UQUlOX1VOREVGSU5FRCcsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRvY3VtZW50KSB7XHJcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PSBcImFkZFwiKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXRoTGVuID0gb3BlcmF0aW9uLnBhdGguc3BsaXQoXCIvXCIpLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nUGF0aExlbiA9IGV4aXN0aW5nUGF0aEZyYWdtZW50LnNwbGl0KFwiL1wiKS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChwYXRoTGVuICE9PSBleGlzdGluZ1BhdGhMZW4gKyAxICYmIHBhdGhMZW4gIT09IGV4aXN0aW5nUGF0aExlbikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ0Nhbm5vdCBwZXJmb3JtIGFuIGBhZGRgIG9wZXJhdGlvbiBhdCB0aGUgZGVzaXJlZCBwYXRoJywgJ09QRVJBVElPTl9QQVRIX0NBTk5PVF9BREQnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAncmVwbGFjZScgfHwgb3BlcmF0aW9uLm9wID09PSAncmVtb3ZlJyB8fCBvcGVyYXRpb24ub3AgPT09ICdfZ2V0Jykge1xyXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLnBhdGggIT09IGV4aXN0aW5nUGF0aEZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Kc29uUGF0Y2hFcnJvcignQ2Fubm90IHBlcmZvcm0gdGhlIG9wZXJhdGlvbiBhdCBhIHBhdGggdGhhdCBkb2VzIG5vdCBleGlzdCcsICdPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEUnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSAnbW92ZScgfHwgb3BlcmF0aW9uLm9wID09PSAnY29weScpIHtcclxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nVmFsdWUgPSB7IG9wOiBcIl9nZXRcIiwgcGF0aDogb3BlcmF0aW9uLmZyb20sIHZhbHVlOiB1bmRlZmluZWQgfTtcclxuICAgICAgICAgICAgdmFyIGVycm9yID0gdmFsaWRhdGUoW2V4aXN0aW5nVmFsdWVdLCBkb2N1bWVudCk7XHJcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5uYW1lID09PSAnT1BFUkFUSU9OX1BBVEhfVU5SRVNPTFZBQkxFJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ0Nhbm5vdCBwZXJmb3JtIHRoZSBvcGVyYXRpb24gZnJvbSBhIHBhdGggdGhhdCBkb2VzIG5vdCBleGlzdCcsICdPUEVSQVRJT05fRlJPTV9VTlJFU09MVkFCTEUnLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy52YWxpZGF0b3IgPSB2YWxpZGF0b3I7XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgYSBzZXF1ZW5jZSBvZiBvcGVyYXRpb25zLiBJZiBgZG9jdW1lbnRgIHBhcmFtZXRlciBpcyBwcm92aWRlZCwgdGhlIHNlcXVlbmNlIGlzIGFkZGl0aW9uYWxseSB2YWxpZGF0ZWQgYWdhaW5zdCB0aGUgb2JqZWN0IGRvY3VtZW50LlxyXG4gKiBJZiBlcnJvciBpcyBlbmNvdW50ZXJlZCwgcmV0dXJucyBhIEpzb25QYXRjaEVycm9yIG9iamVjdFxyXG4gKiBAcGFyYW0gc2VxdWVuY2VcclxuICogQHBhcmFtIGRvY3VtZW50XHJcbiAqIEByZXR1cm5zIHtKc29uUGF0Y2hFcnJvcnx1bmRlZmluZWR9XHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZShzZXF1ZW5jZSwgZG9jdW1lbnQsIGV4dGVybmFsVmFsaWRhdG9yKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzZXF1ZW5jZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuSnNvblBhdGNoRXJyb3IoJ1BhdGNoIHNlcXVlbmNlIG11c3QgYmUgYW4gYXJyYXknLCAnU0VRVUVOQ0VfTk9UX0FOX0FSUkFZJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkb2N1bWVudCkge1xyXG4gICAgICAgICAgICAvL2Nsb25lIGRvY3VtZW50IGFuZCBzZXF1ZW5jZSBzbyB0aGF0IHdlIGNhbiBzYWZlbHkgdHJ5IGFwcGx5aW5nIG9wZXJhdGlvbnNcclxuICAgICAgICAgICAgYXBwbHlQYXRjaChoZWxwZXJzXzEuX2RlZXBDbG9uZShkb2N1bWVudCksIGhlbHBlcnNfMS5fZGVlcENsb25lKHNlcXVlbmNlKSwgZXh0ZXJuYWxWYWxpZGF0b3IgfHwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBleHRlcm5hbFZhbGlkYXRvciA9IGV4dGVybmFsVmFsaWRhdG9yIHx8IHZhbGlkYXRvcjtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxWYWxpZGF0b3Ioc2VxdWVuY2VbaV0sIGksIGRvY3VtZW50LCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIGV4cG9ydHMuSnNvblBhdGNoRXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n")},function(module,exports,__webpack_require__){eval("var equalsOptions = { strict: true };\r\nvar _equals = __webpack_require__(3);\r\nvar areEquals = function (a, b) {\r\n    return _equals(a, b, equalsOptions);\r\n};\r\nvar helpers_1 = __webpack_require__(2);\r\nvar core_1 = __webpack_require__(4);\r\n/* export all core functions */\r\nvar core_2 = __webpack_require__(4);\r\nexports.applyOperation = core_2.applyOperation;\r\nexports.applyPatch = core_2.applyPatch;\r\nexports.applyReducer = core_2.applyReducer;\r\nexports.getValueByPointer = core_2.getValueByPointer;\r\nexports.validate = core_2.validate;\r\nexports.validator = core_2.validator;\r\n/* export some helpers */\r\nvar helpers_2 = __webpack_require__(2);\r\nexports.JsonPatchError = helpers_2.PatchError;\r\nexports.deepClone = helpers_2._deepClone;\r\nexports.escapePathComponent = helpers_2.escapePathComponent;\r\nexports.unescapePathComponent = helpers_2.unescapePathComponent;\r\nvar beforeDict = new WeakMap();\r\nvar Mirror = (function () {\r\n    function Mirror(obj) {\r\n        this.observers = new Map();\r\n        this.obj = obj;\r\n    }\r\n    return Mirror;\r\n}());\r\nvar ObserverInfo = (function () {\r\n    function ObserverInfo(callback, observer) {\r\n        this.callback = callback;\r\n        this.observer = observer;\r\n    }\r\n    return ObserverInfo;\r\n}());\r\nfunction getMirror(obj) {\r\n    return beforeDict.get(obj);\r\n}\r\nfunction getObserverFromMirror(mirror, callback) {\r\n    return mirror.observers.get(callback);\r\n}\r\nfunction removeObserverFromMirror(mirror, observer) {\r\n    mirror.observers.delete(observer.callback);\r\n}\r\n/**\r\n * Detach an observer from an object\r\n */\r\nfunction unobserve(root, observer) {\r\n    observer.unobserve();\r\n}\r\nexports.unobserve = unobserve;\r\n/**\r\n * Observes changes made to an object, which can then be retrieved using generate\r\n */\r\nfunction observe(obj, callback) {\r\n    var patches = [];\r\n    var observer;\r\n    var mirror = getMirror(obj);\r\n    if (!mirror) {\r\n        mirror = new Mirror(obj);\r\n        beforeDict.set(obj, mirror);\r\n    }\r\n    else {\r\n        var observerInfo = getObserverFromMirror(mirror, callback);\r\n        observer = observerInfo && observerInfo.observer;\r\n    }\r\n    if (observer) {\r\n        return observer;\r\n    }\r\n    observer = {};\r\n    mirror.value = helpers_1._deepClone(obj);\r\n    if (callback) {\r\n        observer.callback = callback;\r\n        observer.next = null;\r\n        var dirtyCheck = function () {\r\n            generate(observer);\r\n        };\r\n        var fastCheck = function () {\r\n            clearTimeout(observer.next);\r\n            observer.next = setTimeout(dirtyCheck);\r\n        };\r\n        if (typeof window !== 'undefined') {\r\n            if (window.addEventListener) {\r\n                window.addEventListener('mouseup', fastCheck);\r\n                window.addEventListener('keyup', fastCheck);\r\n                window.addEventListener('mousedown', fastCheck);\r\n                window.addEventListener('keydown', fastCheck);\r\n                window.addEventListener('change', fastCheck);\r\n            }\r\n            else {\r\n                document.documentElement.attachEvent('onmouseup', fastCheck);\r\n                document.documentElement.attachEvent('onkeyup', fastCheck);\r\n                document.documentElement.attachEvent('onmousedown', fastCheck);\r\n                document.documentElement.attachEvent('onkeydown', fastCheck);\r\n                document.documentElement.attachEvent('onchange', fastCheck);\r\n            }\r\n        }\r\n    }\r\n    observer.patches = patches;\r\n    observer.object = obj;\r\n    observer.unobserve = function () {\r\n        generate(observer);\r\n        clearTimeout(observer.next);\r\n        removeObserverFromMirror(mirror, observer);\r\n        if (typeof window !== 'undefined') {\r\n            if (window.removeEventListener) {\r\n                window.removeEventListener('mouseup', fastCheck);\r\n                window.removeEventListener('keyup', fastCheck);\r\n                window.removeEventListener('mousedown', fastCheck);\r\n                window.removeEventListener('keydown', fastCheck);\r\n            }\r\n            else {\r\n                document.documentElement.detachEvent('onmouseup', fastCheck);\r\n                document.documentElement.detachEvent('onkeyup', fastCheck);\r\n                document.documentElement.detachEvent('onmousedown', fastCheck);\r\n                document.documentElement.detachEvent('onkeydown', fastCheck);\r\n            }\r\n        }\r\n    };\r\n    mirror.observers.set(callback, new ObserverInfo(callback, observer));\r\n    return observer;\r\n}\r\nexports.observe = observe;\r\n/**\r\n * Generate an array of patches from an observer\r\n */\r\nfunction generate(observer) {\r\n    var mirror = beforeDict.get(observer.object);\r\n    _generate(mirror.value, observer.object, observer.patches, \"\");\r\n    if (observer.patches.length) {\r\n        core_1.applyPatch(mirror.value, observer.patches);\r\n    }\r\n    var temp = observer.patches;\r\n    if (temp.length > 0) {\r\n        observer.patches = [];\r\n        if (observer.callback) {\r\n            observer.callback(temp);\r\n        }\r\n    }\r\n    return temp;\r\n}\r\nexports.generate = generate;\r\n// Dirty check if obj is different from mirror, generate patches and update mirror\r\nfunction _generate(mirror, obj, patches, path) {\r\n    if (obj === mirror) {\r\n        return;\r\n    }\r\n    if (typeof obj.toJSON === \"function\") {\r\n        obj = obj.toJSON();\r\n    }\r\n    var newKeys = helpers_1._objectKeys(obj);\r\n    var oldKeys = helpers_1._objectKeys(mirror);\r\n    var changed = false;\r\n    var deleted = false;\r\n    //if ever \"move\" operation is implemented here, make sure this test runs OK: \"should not generate the same patch twice (move)\"\r\n    for (var t = oldKeys.length - 1; t >= 0; t--) {\r\n        var key = oldKeys[t];\r\n        var oldVal = mirror[key];\r\n        if (helpers_1.hasOwnProperty(obj, key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {\r\n            var newVal = obj[key];\r\n            if (typeof oldVal == \"object\" && oldVal != null && typeof newVal == \"object\" && newVal != null) {\r\n                _generate(oldVal, newVal, patches, path + \"/\" + helpers_1.escapePathComponent(key));\r\n            }\r\n            else {\r\n                if (oldVal !== newVal) {\r\n                    changed = true;\r\n                    patches.push({ op: \"replace\", path: path + \"/\" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(newVal) });\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            patches.push({ op: \"remove\", path: path + \"/\" + helpers_1.escapePathComponent(key) });\r\n            deleted = true; // property has been deleted\r\n        }\r\n    }\r\n    if (!deleted && newKeys.length == oldKeys.length) {\r\n        return;\r\n    }\r\n    for (var t = 0; t < newKeys.length; t++) {\r\n        var key = newKeys[t];\r\n        if (!helpers_1.hasOwnProperty(mirror, key) && obj[key] !== undefined) {\r\n            patches.push({ op: \"add\", path: path + \"/\" + helpers_1.escapePathComponent(key), value: helpers_1._deepClone(obj[key]) });\r\n        }\r\n    }\r\n}\r\n/**\r\n * Create an array of patches from the differences in two objects\r\n */\r\nfunction compare(tree1, tree2) {\r\n    var patches = [];\r\n    _generate(tree1, tree2, patches, '');\r\n    return patches;\r\n}\r\nexports.compare = compare;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdGxhc01ha2VyV2lkZ2V0Ly4vbm9kZV9tb2R1bGVzL2Zhc3QtanNvbi1wYXRjaC9saWIvZHVwbGV4LmpzPzgxODkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEscUJBQXFCO0FBQ3JCLGNBQWMsbUJBQU8sQ0FBQyxDQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLENBQVc7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLENBQVE7QUFDN0I7QUFDQSxhQUFhLG1CQUFPLENBQUMsQ0FBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLENBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNEdBQTRHO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNFQUFzRTtBQUNoRywyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBLDBCQUEwQiwwR0FBMEc7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZXF1YWxzT3B0aW9ucyA9IHsgc3RyaWN0OiB0cnVlIH07XHJcbnZhciBfZXF1YWxzID0gcmVxdWlyZSgnZGVlcC1lcXVhbCcpO1xyXG52YXIgYXJlRXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgIHJldHVybiBfZXF1YWxzKGEsIGIsIGVxdWFsc09wdGlvbnMpO1xyXG59O1xyXG52YXIgaGVscGVyc18xID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XHJcbnZhciBjb3JlXzEgPSByZXF1aXJlKCcuL2NvcmUnKTtcclxuLyogZXhwb3J0IGFsbCBjb3JlIGZ1bmN0aW9ucyAqL1xyXG52YXIgY29yZV8yID0gcmVxdWlyZSgnLi9jb3JlJyk7XHJcbmV4cG9ydHMuYXBwbHlPcGVyYXRpb24gPSBjb3JlXzIuYXBwbHlPcGVyYXRpb247XHJcbmV4cG9ydHMuYXBwbHlQYXRjaCA9IGNvcmVfMi5hcHBseVBhdGNoO1xyXG5leHBvcnRzLmFwcGx5UmVkdWNlciA9IGNvcmVfMi5hcHBseVJlZHVjZXI7XHJcbmV4cG9ydHMuZ2V0VmFsdWVCeVBvaW50ZXIgPSBjb3JlXzIuZ2V0VmFsdWVCeVBvaW50ZXI7XHJcbmV4cG9ydHMudmFsaWRhdGUgPSBjb3JlXzIudmFsaWRhdGU7XHJcbmV4cG9ydHMudmFsaWRhdG9yID0gY29yZV8yLnZhbGlkYXRvcjtcclxuLyogZXhwb3J0IHNvbWUgaGVscGVycyAqL1xyXG52YXIgaGVscGVyc18yID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XHJcbmV4cG9ydHMuSnNvblBhdGNoRXJyb3IgPSBoZWxwZXJzXzIuUGF0Y2hFcnJvcjtcclxuZXhwb3J0cy5kZWVwQ2xvbmUgPSBoZWxwZXJzXzIuX2RlZXBDbG9uZTtcclxuZXhwb3J0cy5lc2NhcGVQYXRoQ29tcG9uZW50ID0gaGVscGVyc18yLmVzY2FwZVBhdGhDb21wb25lbnQ7XHJcbmV4cG9ydHMudW5lc2NhcGVQYXRoQ29tcG9uZW50ID0gaGVscGVyc18yLnVuZXNjYXBlUGF0aENvbXBvbmVudDtcclxudmFyIGJlZm9yZURpY3QgPSBuZXcgV2Vha01hcCgpO1xyXG52YXIgTWlycm9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1pcnJvcihvYmopIHtcclxuICAgICAgICB0aGlzLm9ic2VydmVycyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLm9iaiA9IG9iajtcclxuICAgIH1cclxuICAgIHJldHVybiBNaXJyb3I7XHJcbn0oKSk7XHJcbnZhciBPYnNlcnZlckluZm8gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gT2JzZXJ2ZXJJbmZvKGNhbGxiYWNrLCBvYnNlcnZlcikge1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gT2JzZXJ2ZXJJbmZvO1xyXG59KCkpO1xyXG5mdW5jdGlvbiBnZXRNaXJyb3Iob2JqKSB7XHJcbiAgICByZXR1cm4gYmVmb3JlRGljdC5nZXQob2JqKTtcclxufVxyXG5mdW5jdGlvbiBnZXRPYnNlcnZlckZyb21NaXJyb3IobWlycm9yLCBjYWxsYmFjaykge1xyXG4gICAgcmV0dXJuIG1pcnJvci5vYnNlcnZlcnMuZ2V0KGNhbGxiYWNrKTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmVPYnNlcnZlckZyb21NaXJyb3IobWlycm9yLCBvYnNlcnZlcikge1xyXG4gICAgbWlycm9yLm9ic2VydmVycy5kZWxldGUob2JzZXJ2ZXIuY2FsbGJhY2spO1xyXG59XHJcbi8qKlxyXG4gKiBEZXRhY2ggYW4gb2JzZXJ2ZXIgZnJvbSBhbiBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIHVub2JzZXJ2ZShyb290LCBvYnNlcnZlcikge1xyXG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlKCk7XHJcbn1cclxuZXhwb3J0cy51bm9ic2VydmUgPSB1bm9ic2VydmU7XHJcbi8qKlxyXG4gKiBPYnNlcnZlcyBjaGFuZ2VzIG1hZGUgdG8gYW4gb2JqZWN0LCB3aGljaCBjYW4gdGhlbiBiZSByZXRyaWV2ZWQgdXNpbmcgZ2VuZXJhdGVcclxuICovXHJcbmZ1bmN0aW9uIG9ic2VydmUob2JqLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIHBhdGNoZXMgPSBbXTtcclxuICAgIHZhciBvYnNlcnZlcjtcclxuICAgIHZhciBtaXJyb3IgPSBnZXRNaXJyb3Iob2JqKTtcclxuICAgIGlmICghbWlycm9yKSB7XHJcbiAgICAgICAgbWlycm9yID0gbmV3IE1pcnJvcihvYmopO1xyXG4gICAgICAgIGJlZm9yZURpY3Quc2V0KG9iaiwgbWlycm9yKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBvYnNlcnZlckluZm8gPSBnZXRPYnNlcnZlckZyb21NaXJyb3IobWlycm9yLCBjYWxsYmFjayk7XHJcbiAgICAgICAgb2JzZXJ2ZXIgPSBvYnNlcnZlckluZm8gJiYgb2JzZXJ2ZXJJbmZvLm9ic2VydmVyO1xyXG4gICAgfVxyXG4gICAgaWYgKG9ic2VydmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG9ic2VydmVyO1xyXG4gICAgfVxyXG4gICAgb2JzZXJ2ZXIgPSB7fTtcclxuICAgIG1pcnJvci52YWx1ZSA9IGhlbHBlcnNfMS5fZGVlcENsb25lKG9iaik7XHJcbiAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICBvYnNlcnZlci5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIG9ic2VydmVyLm5leHQgPSBudWxsO1xyXG4gICAgICAgIHZhciBkaXJ0eUNoZWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBnZW5lcmF0ZShvYnNlcnZlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgZmFzdENoZWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQob2JzZXJ2ZXIubmV4dCk7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQgPSBzZXRUaW1lb3V0KGRpcnR5Q2hlY2spO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBmYXN0Q2hlY2spO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmYXN0Q2hlY2spO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmYXN0Q2hlY2spO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ubW91c2V1cCcsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ua2V5dXAnLCBmYXN0Q2hlY2spO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dGFjaEV2ZW50KCdvbm1vdXNlZG93bicsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ua2V5ZG93bicsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uY2hhbmdlJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9ic2VydmVyLnBhdGNoZXMgPSBwYXRjaGVzO1xyXG4gICAgb2JzZXJ2ZXIub2JqZWN0ID0gb2JqO1xyXG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGdlbmVyYXRlKG9ic2VydmVyKTtcclxuICAgICAgICBjbGVhclRpbWVvdXQob2JzZXJ2ZXIubmV4dCk7XHJcbiAgICAgICAgcmVtb3ZlT2JzZXJ2ZXJGcm9tTWlycm9yKG1pcnJvciwgb2JzZXJ2ZXIpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpZiAod2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kZXRhY2hFdmVudCgnb25tb3VzZXVwJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kZXRhY2hFdmVudCgnb25rZXl1cCcsIGZhc3RDaGVjayk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGV0YWNoRXZlbnQoJ29ubW91c2Vkb3duJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kZXRhY2hFdmVudCgnb25rZXlkb3duJywgZmFzdENoZWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBtaXJyb3Iub2JzZXJ2ZXJzLnNldChjYWxsYmFjaywgbmV3IE9ic2VydmVySW5mbyhjYWxsYmFjaywgb2JzZXJ2ZXIpKTtcclxuICAgIHJldHVybiBvYnNlcnZlcjtcclxufVxyXG5leHBvcnRzLm9ic2VydmUgPSBvYnNlcnZlO1xyXG4vKipcclxuICogR2VuZXJhdGUgYW4gYXJyYXkgb2YgcGF0Y2hlcyBmcm9tIGFuIG9ic2VydmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZShvYnNlcnZlcikge1xyXG4gICAgdmFyIG1pcnJvciA9IGJlZm9yZURpY3QuZ2V0KG9ic2VydmVyLm9iamVjdCk7XHJcbiAgICBfZ2VuZXJhdGUobWlycm9yLnZhbHVlLCBvYnNlcnZlci5vYmplY3QsIG9ic2VydmVyLnBhdGNoZXMsIFwiXCIpO1xyXG4gICAgaWYgKG9ic2VydmVyLnBhdGNoZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgY29yZV8xLmFwcGx5UGF0Y2gobWlycm9yLnZhbHVlLCBvYnNlcnZlci5wYXRjaGVzKTtcclxuICAgIH1cclxuICAgIHZhciB0ZW1wID0gb2JzZXJ2ZXIucGF0Y2hlcztcclxuICAgIGlmICh0ZW1wLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBvYnNlcnZlci5wYXRjaGVzID0gW107XHJcbiAgICAgICAgaWYgKG9ic2VydmVyLmNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLmNhbGxiYWNrKHRlbXApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0ZW1wO1xyXG59XHJcbmV4cG9ydHMuZ2VuZXJhdGUgPSBnZW5lcmF0ZTtcclxuLy8gRGlydHkgY2hlY2sgaWYgb2JqIGlzIGRpZmZlcmVudCBmcm9tIG1pcnJvciwgZ2VuZXJhdGUgcGF0Y2hlcyBhbmQgdXBkYXRlIG1pcnJvclxyXG5mdW5jdGlvbiBfZ2VuZXJhdGUobWlycm9yLCBvYmosIHBhdGNoZXMsIHBhdGgpIHtcclxuICAgIGlmIChvYmogPT09IG1pcnJvcikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xyXG4gICAgfVxyXG4gICAgdmFyIG5ld0tleXMgPSBoZWxwZXJzXzEuX29iamVjdEtleXMob2JqKTtcclxuICAgIHZhciBvbGRLZXlzID0gaGVscGVyc18xLl9vYmplY3RLZXlzKG1pcnJvcik7XHJcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgdmFyIGRlbGV0ZWQgPSBmYWxzZTtcclxuICAgIC8vaWYgZXZlciBcIm1vdmVcIiBvcGVyYXRpb24gaXMgaW1wbGVtZW50ZWQgaGVyZSwgbWFrZSBzdXJlIHRoaXMgdGVzdCBydW5zIE9LOiBcInNob3VsZCBub3QgZ2VuZXJhdGUgdGhlIHNhbWUgcGF0Y2ggdHdpY2UgKG1vdmUpXCJcclxuICAgIGZvciAodmFyIHQgPSBvbGRLZXlzLmxlbmd0aCAtIDE7IHQgPj0gMDsgdC0tKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IG9sZEtleXNbdF07XHJcbiAgICAgICAgdmFyIG9sZFZhbCA9IG1pcnJvcltrZXldO1xyXG4gICAgICAgIGlmIChoZWxwZXJzXzEuaGFzT3duUHJvcGVydHkob2JqLCBrZXkpICYmICEob2JqW2tleV0gPT09IHVuZGVmaW5lZCAmJiBvbGRWYWwgIT09IHVuZGVmaW5lZCAmJiBBcnJheS5pc0FycmF5KG9iaikgPT09IGZhbHNlKSkge1xyXG4gICAgICAgICAgICB2YXIgbmV3VmFsID0gb2JqW2tleV07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2xkVmFsID09IFwib2JqZWN0XCIgJiYgb2xkVmFsICE9IG51bGwgJiYgdHlwZW9mIG5ld1ZhbCA9PSBcIm9iamVjdFwiICYmIG5ld1ZhbCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBfZ2VuZXJhdGUob2xkVmFsLCBuZXdWYWwsIHBhdGNoZXMsIHBhdGggKyBcIi9cIiArIGhlbHBlcnNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9sZFZhbCAhPT0gbmV3VmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwicmVwbGFjZVwiLCBwYXRoOiBwYXRoICsgXCIvXCIgKyBoZWxwZXJzXzEuZXNjYXBlUGF0aENvbXBvbmVudChrZXkpLCB2YWx1ZTogaGVscGVyc18xLl9kZWVwQ2xvbmUobmV3VmFsKSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwicmVtb3ZlXCIsIHBhdGg6IHBhdGggKyBcIi9cIiArIGhlbHBlcnNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSkgfSk7XHJcbiAgICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlOyAvLyBwcm9wZXJ0eSBoYXMgYmVlbiBkZWxldGVkXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFkZWxldGVkICYmIG5ld0tleXMubGVuZ3RoID09IG9sZEtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCBuZXdLZXlzLmxlbmd0aDsgdCsrKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IG5ld0tleXNbdF07XHJcbiAgICAgICAgaWYgKCFoZWxwZXJzXzEuaGFzT3duUHJvcGVydHkobWlycm9yLCBrZXkpICYmIG9ialtrZXldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwiYWRkXCIsIHBhdGg6IHBhdGggKyBcIi9cIiArIGhlbHBlcnNfMS5lc2NhcGVQYXRoQ29tcG9uZW50KGtleSksIHZhbHVlOiBoZWxwZXJzXzEuX2RlZXBDbG9uZShvYmpba2V5XSkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgYW4gYXJyYXkgb2YgcGF0Y2hlcyBmcm9tIHRoZSBkaWZmZXJlbmNlcyBpbiB0d28gb2JqZWN0c1xyXG4gKi9cclxuZnVuY3Rpb24gY29tcGFyZSh0cmVlMSwgdHJlZTIpIHtcclxuICAgIHZhciBwYXRjaGVzID0gW107XHJcbiAgICBfZ2VuZXJhdGUodHJlZTEsIHRyZWUyLCBwYXRjaGVzLCAnJyk7XHJcbiAgICByZXR1cm4gcGF0Y2hlcztcclxufVxyXG5leHBvcnRzLmNvbXBhcmUgPSBjb21wYXJlO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n")},function(module,exports){eval("exports = module.exports = typeof Object.keys === 'function'\n  ? Object.keys : shim;\n\nexports.shim = shim;\nfunction shim (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdGxhc01ha2VyV2lkZ2V0Ly4vbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2tleXMuanM/MzI2MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nXG4gID8gT2JqZWN0LmtleXMgOiBzaGltO1xuXG5leHBvcnRzLnNoaW0gPSBzaGltO1xuZnVuY3Rpb24gc2hpbSAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n")},function(module,exports){eval("var supportsArgumentsClass = (function(){\n  return Object.prototype.toString.call(arguments)\n})() == '[object Arguments]';\n\nexports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\nexports.supported = supported;\nfunction supported(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nexports.unsupported = unsupported;\nfunction unsupported(object){\n  return object &&\n    typeof object == 'object' &&\n    typeof object.length == 'number' &&\n    Object.prototype.hasOwnProperty.call(object, 'callee') &&\n    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||\n    false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdGxhc01ha2VyV2lkZ2V0Ly4vbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2lzX2FyZ3VtZW50cy5qcz85OTdkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHN1cHBvcnRzQXJndW1lbnRzQ2xhc3MgPSAoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudHMpXG59KSgpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID8gc3VwcG9ydGVkIDogdW5zdXBwb3J0ZWQ7XG5cbmV4cG9ydHMuc3VwcG9ydGVkID0gc3VwcG9ydGVkO1xuZnVuY3Rpb24gc3VwcG9ydGVkKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG5leHBvcnRzLnVuc3VwcG9ydGVkID0gdW5zdXBwb3J0ZWQ7XG5mdW5jdGlvbiB1bnN1cHBvcnRlZChvYmplY3Qpe1xuICByZXR1cm4gb2JqZWN0ICYmXG4gICAgdHlwZW9mIG9iamVjdCA9PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBvYmplY3QubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ2NhbGxlZScpICYmXG4gICAgIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsICdjYWxsZWUnKSB8fFxuICAgIGZhbHNlO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n")},function(module,exports,__webpack_require__){eval("var require;var require;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (Buffer){\nfunction toArrayBuffer(buf) {\n    var ab = new ArrayBuffer(buf.length);\n    var view = new Uint8Array(ab);\n    for (var i = 0; i < buf.length; ++i) {\n        view[i] = buf[i];\n    }\n    return view;\n}\nfunction toBuffer(ab) {\n    return new Buffer( new Uint8Array(ab) );\n}\n\nwindow.toArrayBuffer=toArrayBuffer;\nwindow.toBuffer=toBuffer;\n\nwindow.Struct=require('struct');\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":4,\"struct\":2}],2:[function(require,module,exports){\n(function (Buffer){\n/**\r\n * Default export `Struct`.\r\n */\r\n// export default Struct;\r\nmodule.exports = exports = Struct;\r\n\r\n// compatibility\r\nexports.Struct = Struct;\r\n\r\nfunction byteField(p, offset) {\r\n    this.length = 1;\r\n    this.offset = offset;\r\n    this.get = function () {\r\n        return p.buf[offset];\r\n    }\r\n    this.set = function (val) {\r\n        p.buf[offset] = val;\r\n    }\r\n}\r\n\r\nfunction boolField(p, offset, length) {\r\n    this.length = length;\r\n    this.offset = offset;\r\n    this.get = function() {\r\n        return (p.buf[offset] > 0);\r\n    }\r\n    this.set = function (val) {\r\n        p.buf[offset] = val ? 1 : 0;\r\n    }\r\n}\r\n\r\nfunction intField(p, offset, length, le, signed) {\r\n    this.length = length;\r\n    this.offset = offset;\r\n    \r\n    function bec(cb) {\r\n        for (var i = 0; i < length; i++)\r\n            cb(i, length - i - 1);\r\n    }\r\n    \r\n    function lec(cb) {\r\n        for (var i = 0; i < length; i++)\r\n            cb(i, i);\r\n    }\r\n    \r\n    function getUVal(bor) {\r\n        var val = 0;\r\n        bor(function (i, o) {\r\n            val += Math.pow(256, o) * p.buf[offset + i];\r\n        })\r\n        return val;\r\n    }\r\n    \r\n    function getSVal(bor) {\r\n        \r\n        var val = getUVal(bor);\r\n        if ((p.buf[offset + (le ? (length - 1) : 0)] & 0x80) == 0x80) {\r\n            val -= Math.pow(256, length);\r\n        }\r\n        return val;\r\n    }\r\n    \r\n    function setVal(bor, val) {\r\n        bor(function (i, o) {\r\n            p.buf[offset + i] = Math.floor(val / Math.pow(256, o)) & 0xff;\r\n        });\r\n    }\r\n    \r\n    var \r\n     nativeSuff = (signed?'':'U') + 'Int' + (length * 8) + (le?'LE':'BE'),\r\n        readMethod = Buffer.prototype['read' + nativeSuff], writeMethod = Buffer.prototype['write' + nativeSuff];\r\n    \r\n    \r\n    if (!readMethod) {\r\n        this.get = function () {\r\n            var bor = le ? lec : bec;\r\n            return (signed ? getSVal(bor) : getUVal(bor));\r\n        }\r\n    }\r\n    else {\r\n        this.get = function () {\r\n            return readMethod.call(p.buf, offset);\r\n        };\r\n    }\r\n    \r\n    \r\n    if (!writeMethod) {\r\n        this.set = function (val) {\r\n            var bor = le ? lec : bec;\r\n            setVal(bor, val);\r\n        }\r\n    }\r\n    else {\r\n        this.set = function (val) {\r\n            writeMethod.call(p.buf, val, offset);\r\n        }\r\n    }\r\n\r\n}\r\n\r\nfunction floatField(p, offset, le) {\r\n    this.length = 4;\r\n    this.offset = offset;\r\n    this.get = function () {\r\n        return le ? p.buf.readFloatLE(offset) : p.buf.readFloatBE(offset);\r\n    }\r\n    this.set = function (val) {\r\n        return le ? p.buf.writeFloatLE(val, offset) : p.buf.writeFloatBE(val, offset);\r\n    }\r\n}\r\n\r\nfunction doubleField(p, offset, le) {\r\n    this.length = 8;\r\n    this.offset = offset;\r\n    this.get = function () {\r\n        return le ? p.buf.readDoubleLE(offset) : p.buf.readDoubleBE(offset);\r\n    }\r\n    this.set = function (val) {\r\n        return le ? p.buf.writeDoubleLE(val, offset) : p.buf.writeDoubleBE(val, offset);\r\n    }\r\n}\r\n\r\nfunction charField(p, offset, length, encoding, secure) {\r\n    var self = this;\r\n    self.length = length;\r\n    self.offset = offset;\r\n    self.encoding = encoding;\r\n    self.secure = secure;\r\n    self.get = function () {\r\n        if (!length)\r\n            return;\r\n\r\n        var result = p.buf.toString(self.encoding, offset, (offset + length));\r\n        var strlen = result.indexOf(\"\\0\");\r\n        if (strlen == -1) {\r\n            return result;\r\n        } else {\r\n            return result.slice(0, strlen);\r\n        }\r\n    }\r\n    self.set = function (val) {\r\n        if (!length)\r\n            return;\r\n        \r\n        // Be string is terminated with the null char, else troncate it\r\n        if (secure === true) {\r\n            \r\n            // Append \\0 to the string\r\n            val += \"\\0\";\r\n            if (val.length >= length) {\r\n                val = val.substring(0, length - 1);\r\n                val += \"\\0\";\r\n            }\r\n            \r\n            // Write to buffer\r\n            p.buf.write(val, offset, val.length, self.encoding);\r\n            \r\n            // Fill rest of the buffer with \\0\r\n            var remainSpace = (length - val.length);\r\n            if (remainSpace > 0) {\r\n                p.buf.fill(0, (offset + val.length), length);\r\n            }\r\n\r\n        } else {\r\n            // Trust Buffer class to write the string into the buffer\r\n            p.buf.write(val, offset, length, self.encoding);\r\n        }\r\n    }\r\n}\r\n\r\nfunction structField(p, offset, struct) {\r\n    this.length = struct.length();\r\n    this.offset = offset;\r\n    this.get = function () {\r\n        return struct;\r\n    }\r\n    this.set = function (val) {\r\n        struct.set(val);\r\n    }\r\n    this.allocate = function () {\r\n        struct._setBuff(p.buf.slice(offset, offset + struct.length()));\r\n    }\r\n}\r\n\r\nfunction arrayField(p, offset, len, type) {\r\n    var as = Struct();\r\n    var args = [].slice.call(arguments, 4);\r\n    args.unshift(0);\r\n    for (var i = 0; i < len; i++) {\r\n        if (type instanceof Struct) {\r\n            as.struct(i, type.clone());\r\n        } else if (type in as) {\r\n            args[0] = i;\r\n            as[type].apply(as, args);\r\n        }\r\n    }\r\n    this.length = as.length();\r\n    this.offset = offset;\r\n    this.allocate = function () {\r\n        as._setBuff(p.buf.slice(offset, offset + as.length()));\r\n    }\r\n    this.get = function () {\r\n        return as;\r\n    }\r\n    this.set = function (val) {\r\n        as.set(val);\r\n    }\r\n}\r\n\r\nfunction Struct() {\r\n    if (!(this instanceof Struct))\r\n        return new Struct;\r\n    \r\n    var priv = {\r\n        buf : {},\r\n        allocated : false,\r\n        len : 0,\r\n        fields : {},\r\n        closures : []\r\n    }, self = this;\r\n    \r\n    function checkAllocated() {\r\n        if (priv.allocated)\r\n            throw new Error('Cant change struct after allocation');\r\n    }\r\n        \r\n    // Create handlers for various float Field Variants\r\n    [true, false].forEach(function (le) {\r\n        self['float' + (le ? 'le' : 'be')] = function (key) {\r\n            checkAllocated();\r\n            priv.closures.push(function (p) {\r\n                var n = 4;\r\n                p.fields[key] = new floatField(p, p.len, le);\r\n                p.len += n;\r\n            });\r\n            return this;\r\n        }\r\n    });\r\n    \r\n    // Create handlers for various double Field Variants\r\n    [true, false].forEach(function (le) {\r\n        self['double' + (le ? 'le' : 'be')] = function (key) {\r\n            checkAllocated();\r\n            priv.closures.push(function (p) {\r\n                var n = 8;\r\n                p.fields[key] = new doubleField(p, p.len, le);\r\n                p.len += n;\r\n            });\r\n            return this;\r\n        }\r\n    });\r\n    \r\n    // Create handlers for various Bool Field Variants\r\n    [1, 2, 3, 4].forEach(function (n) {\r\n        self['bool' + (n == 1 ? '' : n)] = function (key) {\r\n            checkAllocated();\r\n            priv.closures.push(function (p) {\r\n                p.fields[key] = new boolField(p, p.len, n);\r\n                p.len += n;\r\n            });\r\n            return this;\r\n        }\r\n    });\r\n    \r\n    // Create handlers for various Integer Field Variants\r\n    [1, 2, 3, 4, 6, 8].forEach(function (n) {\r\n        [true, false].forEach(function (le) {\r\n            [true, false].forEach(function (signed) {\r\n                var name = 'word' + (n * 8) + (signed ? 'S' : 'U') + (le ? 'le' : 'be');\r\n                self[name] = function (key) {\r\n                    checkAllocated();\r\n                    priv.closures.push(function (p) {\r\n                        p.fields[key] = new intField(p, p.len, n, le, signed);\r\n                        p.len += n;\r\n                    });\r\n                    return this;\r\n                };\r\n            });\r\n        });\r\n    });\r\n    this.word8 = this.word8Ule;\r\n    \r\n    ['chars', 'charsnt'].forEach(function (c) {\r\n        self[c] = function (key, length, encoding) {\r\n            checkAllocated();\r\n            priv.closures.push(function (p) {\r\n                p.fields[key] = new charField(p, p.len, length, encoding || 'ascii', (c == 'charsnt'));\r\n                p.len += length;\r\n            });\r\n            return this;\r\n        }\r\n    });\r\n\r\n    this.struct = function (key, struct) {\r\n        checkAllocated();\r\n        priv.closures.push(function (p) {\r\n            p.fields[key] = new structField(p, p.len, struct.clone());\r\n            p.len += p.fields[key].length;\r\n        });\r\n        return this;\r\n    }\r\n    function construct(constructor, args) {\r\n        function F() {\r\n            return constructor.apply(this, args);\r\n        }\r\n        \r\n        F.prototype = constructor.prototype;\r\n        return new F();\r\n    }\r\n    \r\n    \r\n    this.array = function (key, length, type) {\r\n        checkAllocated();\r\n        var args = [].slice.call(arguments, 1);\r\n        args.unshift(null);\r\n        args.unshift(null);\r\n        priv.closures.push(function (p) {\r\n            args[0] = p;\r\n            args[1] = p.len;\r\n            p.fields[key] = construct(arrayField, args);\r\n            p.len += p.fields[key].length;\r\n        });\r\n        \r\n        return this;\r\n    }\r\n    var beenHere = false;\r\n    \r\n    function applyClosures(p) {\r\n        if (beenHere)\r\n            return;\r\n        p.closures.forEach(function (el) {\r\n            el(p);\r\n        });\r\n        beenHere = true;\r\n    }\r\n    \r\n    function allocateFields() {\r\n        for (var key in priv.fields) {\r\n            if ('allocate' in priv.fields[key])\r\n                priv.fields[key].allocate();\r\n        }\r\n    }\r\n    \r\n    this._setBuff = this.setBuffer = function (buff, buffLength) {\r\n        applyClosures(priv);\r\n        if (typeof (buffLength) === 'number') {\r\n            if (buffLength > buff.length) {\r\n                throw new Error('Invalid specified buffer size !');\r\n            }\r\n            priv.buf = buff.slice(0, buffLength);\r\n        } else {\r\n            priv.buf = buff;\r\n        }\r\n        if (priv.buf.length < priv.len) {\r\n            throw new Error('Buffer size too small for struct layout !');\r\n        }\r\n        allocateFields();\r\n        priv.allocated = true;\r\n    }\r\n    \r\n    this.allocate = function () {\r\n        applyClosures(priv);\r\n        priv.buf = new Buffer(priv.len);\r\n        allocateFields();\r\n        priv.allocated = true;\r\n        return this;\r\n    }\r\n    \r\n    this._getPriv = function () {\r\n        return priv;\r\n    }\r\n    \r\n    this.getOffset = function (field) {\r\n        if (priv.fields[field]) return priv.fields[field].offset;\r\n    }\r\n    \r\n    this.clone = function () {\r\n        var c = new Struct;\r\n        var p = c._getPriv();\r\n        p.closures = priv.closures.slice(0);\r\n        return c;\r\n    }\r\n    \r\n    this.length = function () {\r\n        applyClosures(priv);\r\n        return priv.len;\r\n    }\r\n    \r\n    this.get = function (key) {\r\n        if (key in priv.fields) {\r\n            return priv.fields[key].get();\r\n        } else\r\n            throw new Error('Can not find field ' + key);\r\n    }\r\n    \r\n    this.set = function (key, val) {\r\n        if (arguments.length == 2) {\r\n            if (key in priv.fields) {\r\n                priv.fields[key].set(val);\r\n            } else\r\n                throw new Error('Can not find field ' + key);\r\n        } else if (Buffer.isBuffer(key)) {\r\n            this._setBuff(key);\r\n        } else {\r\n            for (var k in key) {\r\n                this.set(k, key[k]);\r\n            }\r\n        }\r\n    }\r\n    this.buffer = function () {\r\n        return priv.buf;\r\n    }\r\n    \r\n    \r\n    function getFields() {\r\n        var fields = {};\r\n        Object.keys(priv.fields).forEach(function (key) {\r\n            var setFunc, getFunc;\r\n            if (priv.fields[key] instanceof structField ||\r\n               priv.fields[key] instanceof arrayField) {\r\n                getFunc = function () {\r\n                    return priv.fields[key].get().fields;\r\n                };\r\n                setFunc = function (newVal) {\r\n                    self.set(key, newVal);\r\n                };\r\n            }\r\n            else {\r\n                getFunc = priv.fields[key].get;\r\n                setFunc = priv.fields[key].set;\r\n            };\r\n            \r\n            Object.defineProperty(fields, key, {\r\n                get : getFunc,\r\n                set : setFunc,\r\n                enumerable : true\r\n            });\r\n        });\r\n        return fields;\r\n    };\r\n    \r\n    var _fields;\r\n    Object.defineProperty(this, 'fields', {\r\n        get : function () {\r\n            if (_fields)\r\n                return _fields;\r\n            return (_fields = getFields());\r\n        },\r\n        enumerable : true,\r\n        configurable : true\r\n    });\r\n\r\n}\r\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":4}],3:[function(require,module,exports){\n'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n},{}],4:[function(require,module,exports){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('Invalid typed array length')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (value instanceof ArrayBuffer) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  return fromObject(value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj) {\n    if (isArrayBufferView(obj) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n        return createBuffer(0)\n      }\n      return fromArrayLike(obj)\n    }\n\n    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n      return fromArrayLike(obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (isArrayBufferView(string) || string instanceof ArrayBuffer) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : new Buffer(val, encoding)\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`\nfunction isArrayBufferView (obj) {\n  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)\n}\n\nfunction numberIsNaN (obj) {\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n},{\"base64-js\":3,\"ieee754\":5}],5:[function(require,module,exports){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n},{}]},{},[1]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdGxhc01ha2VyV2lkZ2V0Ly4vdmlldy9kb3dubG9hZHMvc3RydWN0LmpzP2U5NTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMkNBQW1CLGdCQUFnQixVQUFVLFVBQVUsMENBQTBDLGdCQUFnQixPQUFDLE9BQU8sb0JBQW9CLDhDQUE4QyxrQ0FBa0MsWUFBWSxZQUFZLG1DQUFtQyxpQkFBaUIsZ0JBQWdCLHNCQUFzQixvQkFBb0IsMENBQTBDLFlBQVksV0FBVyxZQUFZLFNBQVMsR0FBRztBQUM1YjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRCxDQUFDLEVBQUUsc0JBQXNCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLENBQUM7QUFDRCxDQUFDLEVBQUUsV0FBVztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLENBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFtRDtBQUN4RTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFlBQVk7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUMsRUFBRSwwQkFBMEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsUUFBUSxVQUFVOztBQUVsQjtBQUNBOztBQUVBLENBQUMsR0FBRyxFQUFFLEdBQUciLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoQnVmZmVyKXtcbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIoYnVmKSB7XG4gICAgdmFyIGFiID0gbmV3IEFycmF5QnVmZmVyKGJ1Zi5sZW5ndGgpO1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZpZXdbaV0gPSBidWZbaV07XG4gICAgfVxuICAgIHJldHVybiB2aWV3O1xufVxuZnVuY3Rpb24gdG9CdWZmZXIoYWIpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlciggbmV3IFVpbnQ4QXJyYXkoYWIpICk7XG59XG5cbndpbmRvdy50b0FycmF5QnVmZmVyPXRvQXJyYXlCdWZmZXI7XG53aW5kb3cudG9CdWZmZXI9dG9CdWZmZXI7XG5cbndpbmRvdy5TdHJ1Y3Q9cmVxdWlyZSgnc3RydWN0Jyk7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpXG59LHtcImJ1ZmZlclwiOjQsXCJzdHJ1Y3RcIjoyfV0sMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKEJ1ZmZlcil7XG4vKipcclxuICogRGVmYXVsdCBleHBvcnQgYFN0cnVjdGAuXHJcbiAqL1xyXG4vLyBleHBvcnQgZGVmYXVsdCBTdHJ1Y3Q7XHJcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFN0cnVjdDtcclxuXHJcbi8vIGNvbXBhdGliaWxpdHlcclxuZXhwb3J0cy5TdHJ1Y3QgPSBTdHJ1Y3Q7XHJcblxyXG5mdW5jdGlvbiBieXRlRmllbGQocCwgb2Zmc2V0KSB7XHJcbiAgICB0aGlzLmxlbmd0aCA9IDE7XHJcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBwLmJ1ZltvZmZzZXRdO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zZXQgPSBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgcC5idWZbb2Zmc2V0XSA9IHZhbDtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYm9vbEZpZWxkKHAsIG9mZnNldCwgbGVuZ3RoKSB7XHJcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcclxuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgdGhpcy5nZXQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gKHAuYnVmW29mZnNldF0gPiAwKTtcclxuICAgIH1cclxuICAgIHRoaXMuc2V0ID0gZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgIHAuYnVmW29mZnNldF0gPSB2YWwgPyAxIDogMDtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaW50RmllbGQocCwgb2Zmc2V0LCBsZW5ndGgsIGxlLCBzaWduZWQpIHtcclxuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xyXG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGJlYyhjYikge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGNiKGksIGxlbmd0aCAtIGkgLSAxKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gbGVjKGNiKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgY2IoaSwgaSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGdldFVWYWwoYm9yKSB7XHJcbiAgICAgICAgdmFyIHZhbCA9IDA7XHJcbiAgICAgICAgYm9yKGZ1bmN0aW9uIChpLCBvKSB7XHJcbiAgICAgICAgICAgIHZhbCArPSBNYXRoLnBvdygyNTYsIG8pICogcC5idWZbb2Zmc2V0ICsgaV07XHJcbiAgICAgICAgfSlcclxuICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBnZXRTVmFsKGJvcikge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciB2YWwgPSBnZXRVVmFsKGJvcik7XHJcbiAgICAgICAgaWYgKChwLmJ1ZltvZmZzZXQgKyAobGUgPyAobGVuZ3RoIC0gMSkgOiAwKV0gJiAweDgwKSA9PSAweDgwKSB7XHJcbiAgICAgICAgICAgIHZhbCAtPSBNYXRoLnBvdygyNTYsIGxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHNldFZhbChib3IsIHZhbCkge1xyXG4gICAgICAgIGJvcihmdW5jdGlvbiAoaSwgbykge1xyXG4gICAgICAgICAgICBwLmJ1ZltvZmZzZXQgKyBpXSA9IE1hdGguZmxvb3IodmFsIC8gTWF0aC5wb3coMjU2LCBvKSkgJiAweGZmO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2YXIgXHJcbiAgICAgbmF0aXZlU3VmZiA9IChzaWduZWQ/Jyc6J1UnKSArICdJbnQnICsgKGxlbmd0aCAqIDgpICsgKGxlPydMRSc6J0JFJyksXHJcbiAgICAgICAgcmVhZE1ldGhvZCA9IEJ1ZmZlci5wcm90b3R5cGVbJ3JlYWQnICsgbmF0aXZlU3VmZl0sIHdyaXRlTWV0aG9kID0gQnVmZmVyLnByb3RvdHlwZVsnd3JpdGUnICsgbmF0aXZlU3VmZl07XHJcbiAgICBcclxuICAgIFxyXG4gICAgaWYgKCFyZWFkTWV0aG9kKSB7XHJcbiAgICAgICAgdGhpcy5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBib3IgPSBsZSA/IGxlYyA6IGJlYztcclxuICAgICAgICAgICAgcmV0dXJuIChzaWduZWQgPyBnZXRTVmFsKGJvcikgOiBnZXRVVmFsKGJvcikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVhZE1ldGhvZC5jYWxsKHAuYnVmLCBvZmZzZXQpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIFxyXG4gICAgaWYgKCF3cml0ZU1ldGhvZCkge1xyXG4gICAgICAgIHRoaXMuc2V0ID0gZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgICAgICB2YXIgYm9yID0gbGUgPyBsZWMgOiBiZWM7XHJcbiAgICAgICAgICAgIHNldFZhbChib3IsIHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zZXQgPSBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgIHdyaXRlTWV0aG9kLmNhbGwocC5idWYsIHZhbCwgb2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBmbG9hdEZpZWxkKHAsIG9mZnNldCwgbGUpIHtcclxuICAgIHRoaXMubGVuZ3RoID0gNDtcclxuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgdGhpcy5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGxlID8gcC5idWYucmVhZEZsb2F0TEUob2Zmc2V0KSA6IHAuYnVmLnJlYWRGbG9hdEJFKG9mZnNldCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnNldCA9IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICByZXR1cm4gbGUgPyBwLmJ1Zi53cml0ZUZsb2F0TEUodmFsLCBvZmZzZXQpIDogcC5idWYud3JpdGVGbG9hdEJFKHZhbCwgb2Zmc2V0KTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZG91YmxlRmllbGQocCwgb2Zmc2V0LCBsZSkge1xyXG4gICAgdGhpcy5sZW5ndGggPSA4O1xyXG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICB0aGlzLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbGUgPyBwLmJ1Zi5yZWFkRG91YmxlTEUob2Zmc2V0KSA6IHAuYnVmLnJlYWREb3VibGVCRShvZmZzZXQpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zZXQgPSBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIGxlID8gcC5idWYud3JpdGVEb3VibGVMRSh2YWwsIG9mZnNldCkgOiBwLmJ1Zi53cml0ZURvdWJsZUJFKHZhbCwgb2Zmc2V0KTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2hhckZpZWxkKHAsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZywgc2VjdXJlKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICBzZWxmLmxlbmd0aCA9IGxlbmd0aDtcclxuICAgIHNlbGYub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgc2VsZi5lbmNvZGluZyA9IGVuY29kaW5nO1xyXG4gICAgc2VsZi5zZWN1cmUgPSBzZWN1cmU7XHJcbiAgICBzZWxmLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIWxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gcC5idWYudG9TdHJpbmcoc2VsZi5lbmNvZGluZywgb2Zmc2V0LCAob2Zmc2V0ICsgbGVuZ3RoKSk7XHJcbiAgICAgICAgdmFyIHN0cmxlbiA9IHJlc3VsdC5pbmRleE9mKFwiXFwwXCIpO1xyXG4gICAgICAgIGlmIChzdHJsZW4gPT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnNsaWNlKDAsIHN0cmxlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VsZi5zZXQgPSBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgaWYgKCFsZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBcclxuICAgICAgICAvLyBCZSBzdHJpbmcgaXMgdGVybWluYXRlZCB3aXRoIHRoZSBudWxsIGNoYXIsIGVsc2UgdHJvbmNhdGUgaXRcclxuICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgXFwwIHRvIHRoZSBzdHJpbmdcclxuICAgICAgICAgICAgdmFsICs9IFwiXFwwXCI7XHJcbiAgICAgICAgICAgIGlmICh2YWwubGVuZ3RoID49IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gdmFsLnN1YnN0cmluZygwLCBsZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgIHZhbCArPSBcIlxcMFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBXcml0ZSB0byBidWZmZXJcclxuICAgICAgICAgICAgcC5idWYud3JpdGUodmFsLCBvZmZzZXQsIHZhbC5sZW5ndGgsIHNlbGYuZW5jb2RpbmcpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gRmlsbCByZXN0IG9mIHRoZSBidWZmZXIgd2l0aCBcXDBcclxuICAgICAgICAgICAgdmFyIHJlbWFpblNwYWNlID0gKGxlbmd0aCAtIHZhbC5sZW5ndGgpO1xyXG4gICAgICAgICAgICBpZiAocmVtYWluU3BhY2UgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBwLmJ1Zi5maWxsKDAsIChvZmZzZXQgKyB2YWwubGVuZ3RoKSwgbGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUcnVzdCBCdWZmZXIgY2xhc3MgdG8gd3JpdGUgdGhlIHN0cmluZyBpbnRvIHRoZSBidWZmZXJcclxuICAgICAgICAgICAgcC5idWYud3JpdGUodmFsLCBvZmZzZXQsIGxlbmd0aCwgc2VsZi5lbmNvZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzdHJ1Y3RGaWVsZChwLCBvZmZzZXQsIHN0cnVjdCkge1xyXG4gICAgdGhpcy5sZW5ndGggPSBzdHJ1Y3QubGVuZ3RoKCk7XHJcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBzdHJ1Y3Q7XHJcbiAgICB9XHJcbiAgICB0aGlzLnNldCA9IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICBzdHJ1Y3Quc2V0KHZhbCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmFsbG9jYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHN0cnVjdC5fc2V0QnVmZihwLmJ1Zi5zbGljZShvZmZzZXQsIG9mZnNldCArIHN0cnVjdC5sZW5ndGgoKSkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcnJheUZpZWxkKHAsIG9mZnNldCwgbGVuLCB0eXBlKSB7XHJcbiAgICB2YXIgYXMgPSBTdHJ1Y3QoKTtcclxuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDQpO1xyXG4gICAgYXJncy51bnNoaWZ0KDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGlmICh0eXBlIGluc3RhbmNlb2YgU3RydWN0KSB7XHJcbiAgICAgICAgICAgIGFzLnN0cnVjdChpLCB0eXBlLmNsb25lKCkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSBpbiBhcykge1xyXG4gICAgICAgICAgICBhcmdzWzBdID0gaTtcclxuICAgICAgICAgICAgYXNbdHlwZV0uYXBwbHkoYXMsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMubGVuZ3RoID0gYXMubGVuZ3RoKCk7XHJcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgIHRoaXMuYWxsb2NhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgYXMuX3NldEJ1ZmYocC5idWYuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBhcy5sZW5ndGgoKSkpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGFzO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zZXQgPSBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgYXMuc2V0KHZhbCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFN0cnVjdCgpIHtcclxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHJ1Y3QpKVxyXG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0O1xyXG4gICAgXHJcbiAgICB2YXIgcHJpdiA9IHtcclxuICAgICAgICBidWYgOiB7fSxcclxuICAgICAgICBhbGxvY2F0ZWQgOiBmYWxzZSxcclxuICAgICAgICBsZW4gOiAwLFxyXG4gICAgICAgIGZpZWxkcyA6IHt9LFxyXG4gICAgICAgIGNsb3N1cmVzIDogW11cclxuICAgIH0sIHNlbGYgPSB0aGlzO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBjaGVja0FsbG9jYXRlZCgpIHtcclxuICAgICAgICBpZiAocHJpdi5hbGxvY2F0ZWQpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FudCBjaGFuZ2Ugc3RydWN0IGFmdGVyIGFsbG9jYXRpb24nKTtcclxuICAgIH1cclxuICAgICAgICBcclxuICAgIC8vIENyZWF0ZSBoYW5kbGVycyBmb3IgdmFyaW91cyBmbG9hdCBGaWVsZCBWYXJpYW50c1xyXG4gICAgW3RydWUsIGZhbHNlXS5mb3JFYWNoKGZ1bmN0aW9uIChsZSkge1xyXG4gICAgICAgIHNlbGZbJ2Zsb2F0JyArIChsZSA/ICdsZScgOiAnYmUnKV0gPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGNoZWNrQWxsb2NhdGVkKCk7XHJcbiAgICAgICAgICAgIHByaXYuY2xvc3VyZXMucHVzaChmdW5jdGlvbiAocCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG4gPSA0O1xyXG4gICAgICAgICAgICAgICAgcC5maWVsZHNba2V5XSA9IG5ldyBmbG9hdEZpZWxkKHAsIHAubGVuLCBsZSk7XHJcbiAgICAgICAgICAgICAgICBwLmxlbiArPSBuO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIENyZWF0ZSBoYW5kbGVycyBmb3IgdmFyaW91cyBkb3VibGUgRmllbGQgVmFyaWFudHNcclxuICAgIFt0cnVlLCBmYWxzZV0uZm9yRWFjaChmdW5jdGlvbiAobGUpIHtcclxuICAgICAgICBzZWxmWydkb3VibGUnICsgKGxlID8gJ2xlJyA6ICdiZScpXSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgY2hlY2tBbGxvY2F0ZWQoKTtcclxuICAgICAgICAgICAgcHJpdi5jbG9zdXJlcy5wdXNoKGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IDg7XHJcbiAgICAgICAgICAgICAgICBwLmZpZWxkc1trZXldID0gbmV3IGRvdWJsZUZpZWxkKHAsIHAubGVuLCBsZSk7XHJcbiAgICAgICAgICAgICAgICBwLmxlbiArPSBuO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIENyZWF0ZSBoYW5kbGVycyBmb3IgdmFyaW91cyBCb29sIEZpZWxkIFZhcmlhbnRzXHJcbiAgICBbMSwgMiwgMywgNF0uZm9yRWFjaChmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHNlbGZbJ2Jvb2wnICsgKG4gPT0gMSA/ICcnIDogbildID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBjaGVja0FsbG9jYXRlZCgpO1xyXG4gICAgICAgICAgICBwcml2LmNsb3N1cmVzLnB1c2goZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgICAgIHAuZmllbGRzW2tleV0gPSBuZXcgYm9vbEZpZWxkKHAsIHAubGVuLCBuKTtcclxuICAgICAgICAgICAgICAgIHAubGVuICs9IG47XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gQ3JlYXRlIGhhbmRsZXJzIGZvciB2YXJpb3VzIEludGVnZXIgRmllbGQgVmFyaWFudHNcclxuICAgIFsxLCAyLCAzLCA0LCA2LCA4XS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgW3RydWUsIGZhbHNlXS5mb3JFYWNoKGZ1bmN0aW9uIChsZSkge1xyXG4gICAgICAgICAgICBbdHJ1ZSwgZmFsc2VdLmZvckVhY2goZnVuY3Rpb24gKHNpZ25lZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSAnd29yZCcgKyAobiAqIDgpICsgKHNpZ25lZCA/ICdTJyA6ICdVJykgKyAobGUgPyAnbGUnIDogJ2JlJyk7XHJcbiAgICAgICAgICAgICAgICBzZWxmW25hbWVdID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrQWxsb2NhdGVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJpdi5jbG9zdXJlcy5wdXNoKGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuZmllbGRzW2tleV0gPSBuZXcgaW50RmllbGQocCwgcC5sZW4sIG4sIGxlLCBzaWduZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxlbiArPSBuO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMud29yZDggPSB0aGlzLndvcmQ4VWxlO1xyXG4gICAgXHJcbiAgICBbJ2NoYXJzJywgJ2NoYXJzbnQnXS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgc2VsZltjXSA9IGZ1bmN0aW9uIChrZXksIGxlbmd0aCwgZW5jb2RpbmcpIHtcclxuICAgICAgICAgICAgY2hlY2tBbGxvY2F0ZWQoKTtcclxuICAgICAgICAgICAgcHJpdi5jbG9zdXJlcy5wdXNoKGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgICAgICAgICBwLmZpZWxkc1trZXldID0gbmV3IGNoYXJGaWVsZChwLCBwLmxlbiwgbGVuZ3RoLCBlbmNvZGluZyB8fCAnYXNjaWknLCAoYyA9PSAnY2hhcnNudCcpKTtcclxuICAgICAgICAgICAgICAgIHAubGVuICs9IGxlbmd0aDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuc3RydWN0ID0gZnVuY3Rpb24gKGtleSwgc3RydWN0KSB7XHJcbiAgICAgICAgY2hlY2tBbGxvY2F0ZWQoKTtcclxuICAgICAgICBwcml2LmNsb3N1cmVzLnB1c2goZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgcC5maWVsZHNba2V5XSA9IG5ldyBzdHJ1Y3RGaWVsZChwLCBwLmxlbiwgc3RydWN0LmNsb25lKCkpO1xyXG4gICAgICAgICAgICBwLmxlbiArPSBwLmZpZWxkc1trZXldLmxlbmd0aDtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbnN0cnVjdChjb25zdHJ1Y3RvciwgYXJncykge1xyXG4gICAgICAgIGZ1bmN0aW9uIEYoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgRi5wcm90b3R5cGUgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGKCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIFxyXG4gICAgdGhpcy5hcnJheSA9IGZ1bmN0aW9uIChrZXksIGxlbmd0aCwgdHlwZSkge1xyXG4gICAgICAgIGNoZWNrQWxsb2NhdGVkKCk7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICAgICAgYXJncy51bnNoaWZ0KG51bGwpO1xyXG4gICAgICAgIGFyZ3MudW5zaGlmdChudWxsKTtcclxuICAgICAgICBwcml2LmNsb3N1cmVzLnB1c2goZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgYXJnc1swXSA9IHA7XHJcbiAgICAgICAgICAgIGFyZ3NbMV0gPSBwLmxlbjtcclxuICAgICAgICAgICAgcC5maWVsZHNba2V5XSA9IGNvbnN0cnVjdChhcnJheUZpZWxkLCBhcmdzKTtcclxuICAgICAgICAgICAgcC5sZW4gKz0gcC5maWVsZHNba2V5XS5sZW5ndGg7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB2YXIgYmVlbkhlcmUgPSBmYWxzZTtcclxuICAgIFxyXG4gICAgZnVuY3Rpb24gYXBwbHlDbG9zdXJlcyhwKSB7XHJcbiAgICAgICAgaWYgKGJlZW5IZXJlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgcC5jbG9zdXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgICAgICBlbChwKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBiZWVuSGVyZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGFsbG9jYXRlRmllbGRzKCkge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwcml2LmZpZWxkcykge1xyXG4gICAgICAgICAgICBpZiAoJ2FsbG9jYXRlJyBpbiBwcml2LmZpZWxkc1trZXldKVxyXG4gICAgICAgICAgICAgICAgcHJpdi5maWVsZHNba2V5XS5hbGxvY2F0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5fc2V0QnVmZiA9IHRoaXMuc2V0QnVmZmVyID0gZnVuY3Rpb24gKGJ1ZmYsIGJ1ZmZMZW5ndGgpIHtcclxuICAgICAgICBhcHBseUNsb3N1cmVzKHByaXYpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgKGJ1ZmZMZW5ndGgpID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBpZiAoYnVmZkxlbmd0aCA+IGJ1ZmYubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3BlY2lmaWVkIGJ1ZmZlciBzaXplICEnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcml2LmJ1ZiA9IGJ1ZmYuc2xpY2UoMCwgYnVmZkxlbmd0aCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcHJpdi5idWYgPSBidWZmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJpdi5idWYubGVuZ3RoIDwgcHJpdi5sZW4pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIgc2l6ZSB0b28gc21hbGwgZm9yIHN0cnVjdCBsYXlvdXQgIScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhbGxvY2F0ZUZpZWxkcygpO1xyXG4gICAgICAgIHByaXYuYWxsb2NhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5hbGxvY2F0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBhcHBseUNsb3N1cmVzKHByaXYpO1xyXG4gICAgICAgIHByaXYuYnVmID0gbmV3IEJ1ZmZlcihwcml2Lmxlbik7XHJcbiAgICAgICAgYWxsb2NhdGVGaWVsZHMoKTtcclxuICAgICAgICBwcml2LmFsbG9jYXRlZCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMuX2dldFByaXYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHByaXY7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gKGZpZWxkKSB7XHJcbiAgICAgICAgaWYgKHByaXYuZmllbGRzW2ZpZWxkXSkgcmV0dXJuIHByaXYuZmllbGRzW2ZpZWxkXS5vZmZzZXQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGMgPSBuZXcgU3RydWN0O1xyXG4gICAgICAgIHZhciBwID0gYy5fZ2V0UHJpdigpO1xyXG4gICAgICAgIHAuY2xvc3VyZXMgPSBwcml2LmNsb3N1cmVzLnNsaWNlKDApO1xyXG4gICAgICAgIHJldHVybiBjO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aGlzLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBhcHBseUNsb3N1cmVzKHByaXYpO1xyXG4gICAgICAgIHJldHVybiBwcml2LmxlbjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgaWYgKGtleSBpbiBwcml2LmZpZWxkcykge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJpdi5maWVsZHNba2V5XS5nZXQoKTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGZpbmQgZmllbGQgJyArIGtleSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xyXG4gICAgICAgICAgICBpZiAoa2V5IGluIHByaXYuZmllbGRzKSB7XHJcbiAgICAgICAgICAgICAgICBwcml2LmZpZWxkc1trZXldLnNldCh2YWwpO1xyXG4gICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBmaW5kIGZpZWxkICcgKyBrZXkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGtleSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0QnVmZihrZXkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldChrLCBrZXlba10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5idWZmZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHByaXYuYnVmO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGdldEZpZWxkcygpIHtcclxuICAgICAgICB2YXIgZmllbGRzID0ge307XHJcbiAgICAgICAgT2JqZWN0LmtleXMocHJpdi5maWVsZHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB2YXIgc2V0RnVuYywgZ2V0RnVuYztcclxuICAgICAgICAgICAgaWYgKHByaXYuZmllbGRzW2tleV0gaW5zdGFuY2VvZiBzdHJ1Y3RGaWVsZCB8fFxyXG4gICAgICAgICAgICAgICBwcml2LmZpZWxkc1trZXldIGluc3RhbmNlb2YgYXJyYXlGaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgZ2V0RnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJpdi5maWVsZHNba2V5XS5nZXQoKS5maWVsZHM7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgc2V0RnVuYyA9IGZ1bmN0aW9uIChuZXdWYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldChrZXksIG5ld1ZhbCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZ2V0RnVuYyA9IHByaXYuZmllbGRzW2tleV0uZ2V0O1xyXG4gICAgICAgICAgICAgICAgc2V0RnVuYyA9IHByaXYuZmllbGRzW2tleV0uc2V0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZpZWxkcywga2V5LCB7XHJcbiAgICAgICAgICAgICAgICBnZXQgOiBnZXRGdW5jLFxyXG4gICAgICAgICAgICAgICAgc2V0IDogc2V0RnVuYyxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGUgOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBmaWVsZHM7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB2YXIgX2ZpZWxkcztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZmllbGRzJywge1xyXG4gICAgICAgIGdldCA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKF9maWVsZHMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZpZWxkcztcclxuICAgICAgICAgICAgcmV0dXJuIChfZmllbGRzID0gZ2V0RmllbGRzKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZSA6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlIDogdHJ1ZVxyXG4gICAgfSk7XHJcblxyXG59XHJcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxufSx7XCJidWZmZXJcIjo0fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIHJldHVybiBiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxuXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJ1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPT0nXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9J1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpXG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cbn0se31dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmIChpc0FycmF5QnVmZmVyVmlldyhvYmopIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoaXNBcnJheUJ1ZmZlclZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBOb2RlIDAuMTAgc3VwcG9ydHMgYEFycmF5QnVmZmVyYCBidXQgbGFja3MgYEFycmF5QnVmZmVyLmlzVmlld2BcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3IChvYmopIHtcbiAgcmV0dXJuICh0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nKSAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKVxufVxuXG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG59LHtcImJhc2U2NC1qc1wiOjMsXCJpZWVlNzU0XCI6NX1dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG5cbn0se31dfSx7fSxbMV0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/jquery/dist/jquery.js\nvar jquery = __webpack_require__(0);\nvar jquery_default = /*#__PURE__*/__webpack_require__.n(jquery);\n\n// EXTERNAL MODULE: ./node_modules/fast-json-patch/lib/duplex.js\nvar duplex = __webpack_require__(5);\n\n// EXTERNAL MODULE: ./view/downloads/struct.js\nvar struct = __webpack_require__(8);\n\n// CONCATENATED MODULE: ./view/atlasMaker/src/atlasMaker-draw.js\n/*! AtlasMaker: Image Drawing */\n\n\n/**\n * @page AtlasMaker: Image Drawing\n */\n\nvar AtlasMakerDraw = {\n    /**\n     * @function resizeWindow\n     */\n    resizeWindow: function resizeWindow() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(resizeWindow,1);if(l)console.log.apply(undefined,l);\n\n        var wH=me.container.height();\n        var wW=me.container.width();    \n        var    wAspect=wW/wH;\n        var    bAspect=me.brain_W*me.brain_Wdim/(me.brain_H*me.brain_Hdim);\n        \n        /*\n        if(me.editMode==1) {\n        */\n            // In edit mode width or height can be fixed to 100%\n            // depending on the slice and container aspect ratio\n            if(wAspect>bAspect)\n                jquery_default()(\'#resizable\').css({width:(100*bAspect/wAspect)+\'%\',height:\'100%\'});\n            else\n                jquery_default()(\'#resizable\').css({width:\'100%\',height:(100*wAspect/bAspect)+\'%\'});\n        /*\n        } else {\n            // In display mode slice width is always fixed to 100%\n            $(\'#resizable\').css({width:\'100%\',height:(100*wAspect/bAspect)+\'%\'});\n            \n            // Slice height cannot be larger than window\'s inner height:\n            var sliceH=me.container.height();\n            var windowH=window.innerHeight;\n            if(sliceH>windowH) {\n                var f=windowH/sliceH;\n                $(\'#resizable\').css({width:(f*100)+\'%\',height:f*(100*wAspect/bAspect)+\'%\'});\n            }\n        }\n        */\n    },\n    /**\n     * @function configureBrainImage\n     */\n    configureBrainImage: function configureBrainImage() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(configureBrainImage);if(l)console.log.apply(undefined,l);\n    \n        if(me.User.view==null)\n            me.User.view="sag";\n            \n        var s2v=me.User.s2v;\n        switch(me.User.view) {\n            case \'sag\':    me.brain_W=s2v.sdim[1]; me.brain_H=s2v.sdim[2]; me.brain_D=s2v.sdim[0]; me.brain_Wdim=s2v.wpixdim[1]; me.brain_Hdim=s2v.wpixdim[2]; break; // sagital\n            case \'cor\':    me.brain_W=s2v.sdim[0]; me.brain_H=s2v.sdim[2]; me.brain_D=s2v.sdim[1]; me.brain_Wdim=s2v.wpixdim[0]; me.brain_Hdim=s2v.wpixdim[2]; break; // coronal\n            case \'axi\':    me.brain_W=s2v.sdim[0]; me.brain_H=s2v.sdim[1]; me.brain_D=s2v.sdim[2]; me.brain_Wdim=s2v.wpixdim[0]; me.brain_Hdim=s2v.wpixdim[1]; break; // axial\n        }\n\n        me.canvas.width=me.brain_W;\n        me.canvas.height=me.brain_H*me.brain_Hdim/me.brain_Wdim;\n        me.brain_offcn.width=me.brain_W;\n        me.brain_offcn.height=me.brain_H;\n        me.brain_px=me.brain_offtx.getImageData(0,0,me.brain_offcn.width,me.brain_offcn.height);\n        \n        if(me.User.slice==null || me.User.slice>=me.brain_D-1)\n            me.User.slice=parseInt(me.brain_D/2);\n\n        me.sendUserDataMessage(JSON.stringify({\'view\':me.User.view,\'slice\':me.User.slice}));\n        \n        // configure toolbar slider\n        jquery_default()(".slider#slice").data({max:me.brain_D-1,val:me.User.slice});\n        if(jquery_default()("#slice .thumb")[0]) jquery_default()("#slice .thumb")[0].style.left=(me.User.slice/(me.brain_D-1)*100)+"%";\n        me.drawImages();\n        me.initCursor();\n    },\n    /**\n     * @function configureAtlasImage\n     */\n    configureAtlasImage: function configureAtlasImage() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(configureAtlasImage);if(l)console.log.apply(undefined,l);\n    \n        // has to be run *after* configureBrainImage\n        me.atlas_offcn.width=me.brain_W;\n        me.atlas_offcn.height=me.brain_H;\n        me.atlas_px=me.atlas_offtx.getImageData(0,0,me.atlas_offcn.width,me.atlas_offcn.height);\n    },\n    /**\n     * @function nearestNeighbour\n     */\n    nearestNeighbour: function nearestNeighbour(ctx) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(nearestNeighbour,1);if(l)console.log.apply(undefined,l);\n    \n        ctx.imageSmoothingEnabled = false;\n        ctx.mozImageSmoothingEnabled = false;\n    },\n    /**\n     * @function computeSegmentedVolume\n     */\n    computeSegmentedVolume: function computeSegmentedVolume() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(computeSegmentedVolume,1);if(l)console.log.apply(undefined,l);\n\n        var i,sum=0;\n        var    data=me.atlas.data;\n        var    dim=me.atlas.dim;\n\n        for(i=0;i<dim[0]*dim[1]*dim[2];i++) {\n            if(data[i]>0)\n                sum++;\n        }\n        return sum*me.User.pixdim[0]*me.User.pixdim[1]*me.User.pixdim[2];\n    },\n    /**\n     * @function displayInformation\n     * @desc Overlays text and vectorial information on top of the annotation volume slice. Text information is added from the AtlasMakerWidget.info object. Vectorial information is displayed using svg format\n     */\n    displayInformation: function displayInformation() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(displayInformation,1);if(l)console.log.apply(undefined,l);\n            \n        me.info.slice=me.User.slice;\n        var i=0,str;\n        var text=me.container.find("#text-layer");\n        var vector=me.container.find("#vector-layer");\n        \n        str="";\n        for(var k in me.info) {\n            str+="<span>"+k+": "+me.info[k]+"</span><br/>";\n        }\n        text.html(str);\n        \n        str="";\n        if(me.User.measureLength) {\n            var W=parseFloat(jquery_default()(\'#atlasMaker canvas\').css(\'width\'));\n            var w=parseFloat(jquery_default()(\'#atlasMaker canvas\').attr(\'width\'));\n            var zx=W/w,zy=zx*me.brain_Hdim/me.brain_Wdim,p=me.User.measureLength,str1;\n            var W=parseFloat(jquery_default()(\'#atlasMaker canvas\').css(\'width\'));\n            var w=parseFloat(jquery_default()(\'#atlasMaker canvas\').attr(\'width\'));\n            str1="M"+zx*p[0].x+","+zy*p[0].y;\n            for(i=1;i<p.length;i++)\n                str1+="L"+zx*p[i].x+","+zy*p[i].y;\n            str+=[    "<circle fill=\'#00ff00\' cx="+zx*p[0].x+" cy="+zy*p[0].y+" r=3 />",\n                    "<path stroke=\'#00ff00\' fill=\'none\' d=\'"+str1+"\'/>",\n                    (i>0)?"<circle fill=\'#00ff00\' cx="+zx*p[i-1].x+" cy="+zy*p[i-1].y+" r=3 />":""].join("\\n");\n        }\n        vector.html(str);\n    },\n    /**\n     * @function drawImages\n     */\n    drawImages: function drawImages() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(drawImages,1);if(l)console.log.apply(undefined,l);\n    \n        if(me.brain_img.img\n           && me.flagLoadingImg.view\n           && me.flagLoadingImg.slice) {\n            me.context.clearRect(0,0,me.context.canvas.width,me.canvas.height);\n            me.displayInformation();\n\n            me.nearestNeighbour(me.context);\n            \n            me.context.drawImage(me.brain_img.img,0,0,me.brain_W,me.brain_H*me.brain_Hdim/me.brain_Wdim);\n            me.drawAtlasImage(me.flagLoadingImg.view,me.flagLoadingImg.slice);\n        }\n\n        if(!me.brain_img.img || me.brain_img.view!=me.User.view || me.brain_img.slice!=me.User.slice) {\n            me.sendRequestSliceMessage();\n        }\n    },\n    /**\n     * @function drawAtlasImage\n     */\n    drawAtlasImage: function drawAtlasImage(view,slice) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(drawAtlasImage,1);if(l)console.log.apply(undefined,l);\n    \n        if(!me.atlas)\n            return;\n\n        const data = me.atlas.data;\n        const dim = me.atlas.dim;\n        let i, s, val;\n\n        let x, y;\n        let ys=slice, yc=slice, ya=slice;\n        for(y = 0; y < me.brain_H; y++)\n        for(x = 0; x < me.brain_W; x++) {\n            switch(view) {\n                case \'sag\':s = [ys,x,me.brain_H-1-y]; break;\n                case \'cor\':s = [x,yc,me.brain_H-1-y]; break;\n                case \'axi\':s = [x,me.brain_H-1-y,ya]; break;\n            }\n            i = me.S2I(s,me.User);\n\n            var c=me.ontologyValueToColor(data[i]);\n            var alpha=(data[i]>0)?255:0;\n            i = (y*me.atlas_offcn.width+x)*4;\n            me.atlas_px.data[ i ]  =c[0];\n            me.atlas_px.data[ i+1 ]=c[1];\n            me.atlas_px.data[ i+2 ]=c[2];\n            me.atlas_px.data[ i+3 ]=alpha*me.alphaLevel;\n        }\n        me.atlas_offtx.putImageData(me.atlas_px, 0, 0);\n\n        me.nearestNeighbour(me.context);\n        me.context.drawImage(me.atlas_offcn,0,0,me.brain_W,me.brain_H*me.brain_Hdim/me.brain_Wdim);\n    }\n};\n\n// CONCATENATED MODULE: ./view/atlasMaker/src/atlasMaker-interaction.js\n/*! AtlasMaker: Interaction */\n\n\n/**\n * @page AtlasMaker: Interaction\n */\nvar AtlasMakerInteraction = {\n    //========================================================================================\n    // Local user interaction\n    //========================================================================================\n    /**\n     * @function changeToolbarDisplay\n     */\n    changeToolbarDisplay: function changeToolbarDisplay(display) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(changeToolbarDisplay,0,"#f00");if(l)console.log.apply(undefined,l);\n        \n        switch(display) {\n            case "minimize":\n                jquery_default()("#tools-maximized").hide();\n                jquery_default()("#tools-minimized").show();\n                break;\n            case "maximize":\n                jquery_default()("#tools-maximized").show();\n                jquery_default()("#tools-minimized").hide();\n                break;\n            case "left":\n                jquery_default()("body").attr("data-toolbarDisplay","left");\n                break;\n            case "right":\n                jquery_default()("body").attr("data-toolbarDisplay","right");\n                break;\n        }\n    },\n    /**\n     * @function changeView\n     */\n    changeView: function changeView(theView) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(changeView,0,"#f00");if(l)console.log.apply(undefined,l);\n    \n        switch(theView) {\n            case \'sag\':\n                me.User.view=\'sag\';\n                break;\n            case \'cor\':\n                me.User.view=\'cor\';\n                break;\n            case \'axi\':\n                me.User.view=\'axi\';\n                break;\n        }\n        me.sendUserDataMessage(JSON.stringify({\'view\':me.User.view}));\n    \n        me.configureBrainImage();\n        me.configureAtlasImage();\n        me.resizeWindow();\n\n        me.drawImages();\n        \n        me.initCursor();\n\n    },\n    /**\n     * @function changeTool\n     * @desc Change the tool that defines the effect of mouse clicks\n     * @param {String} theToole Name of the tool: Paint, Erase, Measure, Adjust\n     */\n    changeTool: function changeTool(theTool) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(changeTool,0,"#f00");if(l)console.log.apply(undefined,l);\n    \n        if(theTool.toLowerCase()==me.User.tool)\n            return;\n        \n        switch(theTool) {\n            case \'Show\':\n                me.User.tool=\'show\';\n                break;\n            case \'Paint\':\n                me.User.tool=\'paint\';\n                break;\n            case \'Erase\':\n                me.User.tool=\'erase\';\n                break;\n            case \'Measure\':\n                me.User.tool=\'measure\';\n                break;\n            case \'Adjust\':\n                me.User.tool=\'adjust\';\n                if(jquery_default()("#adjust").length==0) {\n                    me.container.find("#resizable").append(me.html.adjust);\n                }\n                break;\n            case \'Eyedrop\':\n                me.User.tool=\'eyedrop\';\n                break;\n        }\n        me.sendUserDataMessage(JSON.stringify({\'tool\':me.User.tool}));\n        me.User.measureLength=null;\n    },\n    /**\n     * @function changePenSize\n     */\n    changePenSize: function changePenSize(theSize) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(changePenSize,0,"#f00");if(l)console.log.apply(undefined,l);\n    \n        me.User.penSize=parseInt(theSize);\n        me.sendUserDataMessage(JSON.stringify({\'penSize\':me.User.penSize}));\n    },\n    /**\n     * @function changePenColor\n     */\n    changePenColor: function changePenColor(index) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(changePenColor,0,"#f00");if(l)console.log.apply(undefined,l);\n        \n        var c=me.ontology.labels[index].color;\n        jquery_default()("#color").css({backgroundColor:\'rgb(\'+c[0]+\',\'+c[1]+\',\'+c[2]+\')\'});\n        me.User.penValue=me.ontology.labels[index].value;\n        me.sendUserDataMessage(JSON.stringify({\'penValue\':me.User.penValue}));\n    },\n    /**\n     * @function changeSlice\n     */\n    changeSlice: function changeSlice(x) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(changeSlice,1,"#f00");if(l)console.log.apply(undefined,l);\n    \n        me.User.slice=x;\n        me.sendUserDataMessage(JSON.stringify({\'slice\':me.User.slice}));\n\n        me.drawImages();\n    },\n    /**\n     * @function prevSlice\n     */\n    prevSlice: function prevSlice() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(prevSlice,1,"#f00");if(l)console.log.apply(undefined,l);\n\n        var x=jquery_default()("#slice").data("val")-1;\n        if(x<0) x=0;\n        x=Math.round(x);\n        if(x!=jquery_default()("#slice").data("val")) {\n            jquery_default()("#slice").data("val",x);\n            me.changeSlice(x);\n        }\n    },\n    /**\n     * @function nextSlice\n     */\n    nextSlice: function nextSlice() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(nextSlice,1,"#f00");if(l)console.log.apply(undefined,l);\n\n        var max=jquery_default()("#slice").data("max");\n        var x=jquery_default()("#slice").data("val")+1;\n        if(x>max) x=max;\n        x=Math.round(x);\n        if(x!=jquery_default()("#slice").data("val")) {\n            jquery_default()("#slice").data("val",x);\n            me.changeSlice(x);\n        }\n    },\n    /**\n     * @function toggleFill\n     */\n    toggleFill: function toggleFill(x) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(toggleFill,0,"#f00");if(l)console.log.apply(undefined,l);\n    \n        me.User.doFill=x;\n        me.sendUserDataMessage(JSON.stringify({\'doFill\':me.User.doFill}));\n    },\n    /**\n     * @function toggleChat\n     */\n    toggleChat: function toggleChat() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(toggleChat,0,"#f00");if(l)console.log.apply(undefined,l);\n    \n        jquery_default()("#chatBlock").toggle();\n    },\n    /**\n     * @function toggleFullscreen\n     */\n    toggleFullscreen: function toggleFullscreen() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(toggleFullscreen,0,"#f00");if(l)console.log.apply(undefined,l);\n\n        if(me.fullscreen==false) {\n            // Enter fullscreen\n            //-----------------\n        \n            // add black overlay\n            var black=jquery_default()("<div id=\'blackOverlay\'>");\n            black.css({position:\'fixed\',top:0,left:0,width:\'100%\',height:\'100%\',\'z-index\':5,\'background-color\':\'#222\'});\n            jquery_default()(\'body\').append(black);\n    \n            // configure display mode\n            //    $("#atlasMaker").removeClass(\'display-mode\');\n            jquery_default()("body").addClass(\'atlasMaker-fullscreen\');\n            jquery_default()("#atlasMaker").detach().appendTo(\'body\');\n            \n            //    me.editMode=1;\n            me.resizeWindow();\n    \n            // configure toolbar for edit mode\n            //$("#log").outerHeight($("#tools-side").outerHeight()-$("#log").offset().top-$("#msg").closest("tr").outerHeight());\n            me.fullscreen=true;\n        } else {\n\n            // Exit fullscreen\n            //----------------\n        \n            // remove black overlay\n            jquery_default()("#blackOverlay").remove();\n    \n            // go back to display mode\n            jquery_default()("body").removeClass(\'atlasMaker-fullscreen\');\n            //    $("#atlasMaker").addClass(\'display-mode\');\n            jquery_default()("#atlasMaker").detach().appendTo(\'#stereotaxic\');\n            //    me.editMode=0;\n            me.resizeWindow();\n\n            me.fullscreen=false;\n        }\n    },\n    /**\n     * @function render3D\n     */\n    render3D: function render3D() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(render3D,0,"#f00");if(l)console.log.apply(undefined,l);\n        \n        // puts a fresh version of the segmentation in localStorage\n        localStorage.brainbox=URL.createObjectURL(new Blob([me.encodeNifti()]));\n        \n        // opens 3d render window\n        window.open(me.hostname + "/surface.html?path="+me.User.dirname+me.User.atlasFilename,"_blank");\n    },\n    /**\n     * @function link\n     */\n    link: function link() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(link,0,"#f00");if(l)console.log.apply(undefined,l);\n        window.prompt("Copy to clipboard:", location.href+"&view="+AtlasMakerWidget.User.view+"&slice="+AtlasMakerWidget.User.slice);\n    },\n    /**\n     * @function upload\n     */\n    upload: function upload() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(upload,0,"#f00");if(l)console.log.apply(undefined,l);\n        \n        var inp=jquery_default()("<input>");\n        inp.hide();\n        jquery_default()("body").append(inp);\n        var input=inp.get(0);\n        input.type="file";\n        input.onchange=function from_upload(e){\n            var name=this.files[0];\n            var reader = new FileReader();\n            reader.onload = function from_upload(e) {\n                var result=e.target.result;\n                var nii;\n                if(name.name.split(\'.\').pop()=="gz") {\n                    var inflate=new pako.Inflate();\n                    inflate.push(new Uint8Array(result),true);\n                    nii=inflate.result.buffer;\n                }\n                else\n                    nii=result;\n                var mri=me.loadNifti(nii);\n\n                if(    mri.dim[0]!=me.User.dim[0] ||\n                    mri.dim[1]!=me.User.dim[1] ||\n                    mri.dim[2]!=me.User.dim[2]) {\n                    console.log("ERROR: Volume dimensions do not match");\n                    return;\n                }\n                \n                // copy uploaded data to atlas data\n                var i;\n                for(i=0;i<me.atlas.data.length;i++)\n                    me.atlas.data[i]=mri.data[i];\n                \n                // send uploaded data to server (compressed)\n                me.socket.binaryType="arraybuffer";\n                me.socket.send(pako.deflate(mri.data));\n                me.socket.binaryType="blob";\n                \n                // redraw images\n                me.drawImages();\n            }\n            reader.readAsArrayBuffer(name);\n            inp.remove();\n        }\n        input.click();\n    },\n    /**\n     * @function download\n     */\n    download: function download() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(download,0,"#f00");if(l)console.log.apply(undefined,l);\n            \n        var a = document.createElement(\'a\');\n        var niigz=me.encodeNifti();\n        var niigzBlob = new Blob([niigz]);\n        a.href=window.URL.createObjectURL(niigzBlob);\n        a.download=me.atlasName+".nii.gz";\n        document.body.appendChild(a);\n        a.click();\n    },\n    /**\n     * @function color\n     */\n    color: function color() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(color,0,"#f00");if(l)console.log.apply(undefined,l);\n        \n        jquery_default()("#labelset").appendTo(me.container);\n        jquery_default()("#labelset").show();\n\n        var obj=jquery_default()("#labelset");\n        jquery_default()(obj).find("span#labels-name").text(me.ontology.name);\n        jquery_default()(obj).find("#label-list").html("");\n        for(var i=0;i<me.ontology.labels.length;i++) {\n            var l=me.ontology.labels[i];\n            var la=jquery_default()(obj).find("#label-template").clone();\n            la.attr({"data-index":i});\n            la.find(".label-color").css({backgroundColor:"rgb("+l.color[0]+","+l.color[1]+","+l.color[2]+")"});\n            la.find(".label-name").text(l.name);\n            la.click(function() {\n                me.changePenColor(jquery_default()(this).attr("data-index"));\n                jquery_default()(obj).hide();\n            });\n            jquery_default()(obj).find("#label-list").append(la);\n            la.show();\n        }\n    },\n    /**\n     * @function ontologyValueToColor\n     */\n    ontologyValueToColor: function ontologyValueToColor(val) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(ontologyValueToColor,3,"#f00");if(l)console.log.apply(undefined,l);\n\n        var c=[0,0,0];\n        var i;\n        if(val in me.ontology.valueToIndex)\n            i=me.ontology.valueToIndex[val];\n        if(i!=undefined) {\n            c=me.ontology.labels[i].color;\n        } else if(val) {\n            c=[255,0,0]; // unavailable labels are set to pure red\n        }\n        return c;\n    },\n    /**\n     * @function eyedrop\n     */\n    eyedrop : function eyedrop( x,y,usr) {\n        var me = AtlasMakerWidget;\n        var l = me.traceLog(eyedrop,0,"#f00");if(l)console.log.apply(undefined,l);\n        \n        var    z = usr.slice;\n        var i = me.slice2index( x,y,z,usr.view );\n        return me.atlas.data[i];\n    },\n    /**\n     * @function togglePreciseCursor\n     */\n    togglePreciseCursor: function togglePreciseCursor() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(togglePreciseCursor,0,"#f00");if(l)console.log.apply(undefined,l);\n    \n        me.flagUsePreciseCursor=!me.flagUsePreciseCursor;\n        me.initCursor();\n    },\n    /**\n     * @function initCursor\n     */\n    initCursor: function initCursor() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(initCursor,1,"#f00");if(l)console.log.apply(undefined,l);\n\n        var W=parseFloat(jquery_default()(\'#atlasMaker canvas\').css(\'width\'));\n        var H=parseFloat(jquery_default()(\'#atlasMaker canvas\').css(\'height\'));\n        var w=parseFloat(jquery_default()(\'#atlasMaker canvas\').attr(\'width\'));\n        var h=parseFloat(jquery_default()(\'#atlasMaker canvas\').attr(\'height\'));\n        \n        me.Crsr.x=parseInt(w/2);\n        me.Crsr.y=parseInt(h/2);\n        \n        me.Crsr.fx=parseInt(w/2)*(W/w);\n        me.Crsr.fy=parseInt(h/2)*(H/h);\n        jquery_default()("#cursor").css({left:(me.Crsr.x*(W/w))+"px",top:(me.Crsr.y*(H/h))+"px",width:me.User.penSize*(W/w),height:me.User.penSize*(H/h)});\n        \n        if(me.flagUsePreciseCursor) {\n            if(jquery_default()("#finger").length==0) {\n                me.container.append("<div id=\'finger\'></div>");\n                jquery_default()("#finger").addClass("touchDevice");\n\n                // configure touch events for tablets\n                jquery_default()("#finger").on("touchstart",function(e){me.touchstart(e)});\n                jquery_default()("#finger").on("touchend",function(e){me.touchend(e)});\n                jquery_default()("#finger").on("touchmove",function(e){me.touchmove(e)});\n            \n                // turn off eventual touch events handled by canvas\n                me.canvas.ontouchstart=null;\n                me.canvas.ontouchmove=null;\n                me.canvas.ontouchend=null;\n            }\n            me.updateCursor();\n\n            jquery_default()("#finger").css({left:me.Crsr.fx+"px",top:me.Crsr.fy+"px"});\n        } else {\n            // remove precise cursor\n            jquery_default()("#finger").remove();\n\n            // configure touch events for tablets\n            me.canvas.ontouchstart=me.touchstart;\n            me.canvas.ontouchmove=me.touchmove;\n            me.canvas.ontouchend=me.touchend;\n        }\n    },\n    /**\n     * @function updateCursor\n     */\n    updateCursor: function updateCursor() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(updateCursor,1,"#f00");if(l)console.log.apply(undefined,l);\n\n        jquery_default()("#finger").removeClass("move draw configure");\n        switch(me.Crsr.state) {\n            case "move": jquery_default()("#finger").addClass("move");    break;\n            case "draw": jquery_default()("#finger").addClass("draw");    break;\n            case "configure": jquery_default()("#finger").addClass("configure");    break;\n        }\n    },\n    /**\n     * @function mousedown\n     */\n    mousedown: function mousedown(e) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(mousedown,0,"#f00");if(l)console.log.apply(undefined,l);\n    \n        e.preventDefault();\n\n        var W=parseFloat(jquery_default()(\'#atlasMaker canvas\').css(\'width\'));\n        var H=parseFloat(jquery_default()(\'#atlasMaker canvas\').css(\'height\'));\n        var w=parseFloat(jquery_default()(\'#atlasMaker canvas\').attr(\'width\'));\n        var h=parseFloat(jquery_default()(\'#atlasMaker canvas\').attr(\'height\'));\n        var o=jquery_default()(\'#atlasMaker canvas\').offset();\n        var x=parseInt((e.pageX-o.left)*(w/W));\n        // i have to add here the compensation for rectangular pixels: f(brain_Wdim, brain_Hdim)\n        var y=parseInt((e.pageY-o.top)*(h/H));\n        me.down(x,Math.round(y*me.brain_Wdim/me.brain_Hdim));\n    },\n    /**\n     * @function mousemove\n     * @desc Handles a mouse move event. The x and y slice screens are computed from the pageX and pageY screen coordinates and dispatched to the generic move handler. The position and size of the cursor are adjusted.\n     * @param {Event} e Event object\n     */\n    mousemove: function mousemove(e) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(mousemove,2,"#f00");if(l)console.log.apply(undefined,l);\n    \n        e.preventDefault();\n        var W=parseFloat(jquery_default()(\'#atlasMaker canvas\').css(\'width\'));\n        var H=parseFloat(jquery_default()(\'#atlasMaker canvas\').css(\'height\'));\n        var w=parseFloat(jquery_default()(\'#atlasMaker canvas\').attr(\'width\'));\n        var h=parseFloat(jquery_default()(\'#atlasMaker canvas\').attr(\'height\'));\n        var o=jquery_default()(\'#atlasMaker canvas\').offset();\n        var x=parseInt((e.pageX-o.left)*(w/W));\n        var y=parseInt((e.pageY-o.top)*(h/H));\n    \n        jquery_default()("#cursor").css({\n            left:(x*(W/w))+\'px\',\n            top:(y*(H/h))+\'px\',\n            width:me.User.penSize*(W/w),\n            height:me.User.penSize*(H/h)\n        });\n        me.move(x,Math.round(y*me.brain_Wdim/me.brain_Hdim));\n    },\n    /**\n     * @function mouseup\n     */\n    mouseup: function mouseup(e) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(mouseup,0,"#f00");if(l)console.log.apply(undefined,l);\n    \n        me.up(e);\n    },\n    /**\n     * @function touchstart\n     */\n    touchstart: function touchstart(e) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(touchstart,0,"#f00");if(l)console.log.apply(undefined,l);\n    \n        e.preventDefault();\n\n        var W=parseFloat(jquery_default()(\'#atlasMaker canvas\').css(\'width\'));\n        var H=parseFloat(jquery_default()(\'#atlasMaker canvas\').css(\'height\'));\n        var w=parseFloat(jquery_default()(\'#atlasMaker canvas\').attr(\'width\'));\n        var h=parseFloat(jquery_default()(\'#atlasMaker canvas\').attr(\'height\'));\n        var o=jquery_default()(\'#atlasMaker canvas\').offset();\n        var    touchEvent;\n        if(e.originalEvent)\n            touchEvent=e.originalEvent.changedTouches[0];\n        else\n            touchEvent=e.changedTouches[0];\n        var x=parseInt((touchEvent.pageX-o.left)*(w/W));\n        var y=parseInt((touchEvent.pageY-o.top)*(h/H));\n    \n        if(me.flagUsePreciseCursor) {\n            // Precision cursor\n            me.Crsr.x0=x;\n            me.Crsr.cachedX=x;\n            me.Crsr.y0=y;\n            me.Crsr.cachedY=y;\n            me.Crsr.fx=jquery_default()("#finger").offset().left;\n            me.Crsr.fy=jquery_default()("#finger").offset().top;\n            me.Crsr.touchStarted=true;\n            setTimeout(function() {\n                if( me.Crsr.cachedX == me.Crsr.x0 && me.Crsr.cachedY==me.Crsr.y0 && !me.Crsr.touchStarted) {\n                    // short tap: change mode\n                    me.Crsr.state=(me.Crsr.state=="move")?"draw":"move";\n                    me.updateCursor();\n                }\n            },200);\n            setTimeout(function() {\n                if (me.Crsr.cachedX==me.Crsr.x0 && me.Crsr.cachedY==me.Crsr.y0 && me.Crsr.touchStarted) {\n                    // long tap: change to configure mode\n                    me.Crsr.prevState=me.Crsr.state;\n                    me.Crsr.state="configure";\n                    me.updateCursor();\n                }\n            },1000);\n            me.down(me.Crsr.x,Math.round(me.Crsr.y*me.brain_Wdim/me.brain_Hdim));\n        } else\n            me.down(x,Math.round(y*me.brain_Wdim/me.brain_Hdim));\n    },\n    /**\n     * @function touchmove\n     */\n    touchmove: function touchmove(e) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(touchmove,2,"#f00");if(l)console.log.apply(undefined,l);\n        \n        if(me.Crsr.touchStarted==false && me.debug) {\n            console.log("WARNING: touch can move without having started");\n        }\n    \n        e.preventDefault();\n\n        var W=parseFloat(jquery_default()(\'#atlasMaker canvas\').css(\'width\'));\n        var H=parseFloat(jquery_default()(\'#atlasMaker canvas\').css(\'height\'));\n        var w=parseFloat(jquery_default()(\'#atlasMaker canvas\').attr(\'width\'));\n        var h=parseFloat(jquery_default()(\'#atlasMaker canvas\').attr(\'height\'));\n        var o=jquery_default()(\'#atlasMaker canvas\').offset();\n        var    touchEvent;\n        if(e.originalEvent)\n            touchEvent=e.originalEvent.changedTouches[0];\n        else\n            touchEvent=e.changedTouches[0];\n        var x=parseInt((touchEvent.pageX-o.left)*(w/W));\n        var y=parseInt((touchEvent.pageY-o.top)*(h/H));\n    \n        if(me.flagUsePreciseCursor) {\n            // Precision cursor\n            var dx=x-me.Crsr.x0;\n            var dy=y-me.Crsr.y0;\n            if(me.Crsr.state=="move"||me.Crsr.state=="draw") {\n                me.Crsr.x+=dx;\n                me.Crsr.y+=dy;\n                jquery_default()("#cursor").css({left:me.Crsr.x*(W/w),top:me.Crsr.y*(H/h),width:me.User.penSize*(W/w),height:me.User.penSize*(H/h)});\n                if(me.Crsr.state=="draw")\n                    me.move(me.Crsr.x,Math.round(me.Crsr.y*me.brain_Wdim/me.brain_Hdim));\n            }\n            me.Crsr.fx+=dx*(W/w);\n            me.Crsr.fy+=dy*(H/h);\n            jquery_default()("#finger").offset({left:me.Crsr.fx,top:me.Crsr.fy});\n        \n            me.Crsr.x0=x;\n            me.Crsr.y0=y;\n        } else {\n            jquery_default()("#cursor").css({\n                left:(x*(W/w))+\'px\',\n                top:(y*(H/h))+\'px\',\n                width:me.User.penSize*(W/w),\n                height:me.User.penSize*(H/h)\n            });\n            me.move(x,Math.round(y*me.brain_Wdim/me.brain_Hdim));\n        }\n    },\n    /**\n     * @function touchend\n     */\n    touchend: function touchend(e) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(touchend,0,"#f00");if(l)console.log.apply(undefined,l);\n        \n        e.preventDefault();\n    \n        if(me.flagUsePreciseCursor) {\n            // Precision cursor\n            me.Crsr.touchStarted=false;\n            if(me.Crsr.state=="configure") {\n                me.Crsr.state=me.Crsr.prevState;\n                me.updateCursor();\n            }\n        }    \n        me.up(e);\n    },\n    /**\n     * @function down\n     * @desc Generic pointer down event: Deals with down events generated by mouse clicks or touch events. The effect of the down event is determined by the current User.tool\n     * @param {integer} x X coordinate in slice space\n     * @param {integer} y Y coordinate in slice space\n     */\n    down: function down(x,y) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(down,0,"#f00");if(l)console.log.apply(undefined,l);\n    \n        var z=me.User.slice;\n        \n        switch(me.User.tool) {\n            case \'show\':\n                me.User.mouseIsDown = true;\n                me.sendUserDataMessage(JSON.stringify({\'mouseIsDown\':true}));\n                me.showxy(-1,\'m\',x,y,me.User);\n                break;\n            case \'paint\':\n                // check for \'edit\' access\n                if(me.editMode == 0)\n                    return;\n                // fill\n                if(me.User.doFill)\n                    me.paintxy(-1,\'f\',x,y,me.User);\n                //paint\n                else {\n                    me.User.mouseIsDown = true;\n                    me.sendUserDataMessage(JSON.stringify({\'mouseIsDown\':true}));\n                    me.paintxy(-1,\'mf\',x,y,me.User);\n                }\n                break;\n            case \'erase\':\n                // check for \'edit\' access\n                if(me.editMode == 0)\n                    return;\n                // fill\n                if(me.User.doFill)\n                    me.paintxy(-1,\'e\',x,y,me.User);\n                // erase\n                else {\n                    me.User.mouseIsDown = true;\n                    me.sendUserDataMessage(JSON.stringify({\'mouseIsDown\':true}));\n                    me.paintxy(-1,\'me\',x,y,me.User);\n                }\n                break;\n            case \'measure\':\n                if(me.User.measureLength==null)\n                    me.User.measureLength=[{x:x,y:y}];\n                else\n                    me.User.measureLength.push({x:x,y:y});\n                break;\n            case \'adjust\':\n                me.User.mouseIsDown = true;\n                me.info.x=x/me.brain_W;\n                me.info.y=1-y/me.brain_H;\n                break;\n            case \'eyedrop\':\n                var value = me.eyedrop( x,y,me.User );\n                if (!value) { break; }\n                var index = me.ontology.valueToIndex[ value ];\n                var selRegionName = me.ontology.labels[ index ].name;\n                me.info.region = selRegionName;\n                me.changePenColor( index );\n                var selRegionColor = me.ontology.labels[ index ].color;\n                break;\n        }\n    \n        // init annotation length counter\n        me.annotationLength=0;\n    },\n    /**\n     * @function move\n     * @desc Generic pointer move event: Deals with move events generated by mouse clicks or touch events. The effect of the move event is determined by the current User.tool\n     * @param {integer} x X coordinate in slice space\n     * @param {integer} y Y coordinate in slice space\n     */\n    move: function move(x,y) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(move,2,"#f00");if(l)console.log.apply(undefined,l);\n    \n        /*\n        if(MyLoginWidget.loggedin==0 || me.editMode==0)\n            return;\n        */\n\n        var z=me.User.slice;\n\n        if(!me.User.mouseIsDown)\n            return;\n        \n        switch(me.User.tool) {\n            case \'show\':\n                me.showxy(-1,\'m\',x,y,me.User);\n                break;\n            case \'paint\':\n                me.paintxy(-1,\'lf\',x,y,me.User);\n                break;\n            case \'erase\':\n                me.paintxy(-1,\'le\',x,y,me.User);\n                break;\n            case \'adjust\':\n                me.info.x=x/me.brain_W;\n                me.info.y=1-y/me.brain_H;\n                me.drawImages();\n                break;\n        }\n    },\n    /**\n     * @function up\n     * @desc Generic pointer up event: Deals with up events generated by mouse clicks or touch events.\n     * @param {integer} x X coordinate in slice space\n     * @param {integer} y Y coordinate in slice space\n     */\n    up: function up(e) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(up,0,"#f00");if(l)console.log.apply(undefined,l);\n\n        /*\n        if(MyLoginWidget.loggedin==0 || me.editMode==0)\n            return;\n        */\n\n        // Send mouse up (touch ended) message\n        me.User.mouseIsDown = false;\n        me.User.x0=-1;\n\n        me.sendUserDataMessage(JSON.stringify({\'mouseIsDown\':false}));\n        \n        var msg;\n        \n        switch(me.User.tool) {\n            case \'show\':\n                var msg={"c":"u"};\n                me.sendShowMessage(msg);\n                break;\n            case \'paint\':\n            case \'erase\':\n                var msg={c:"mu"};\n                me.sendPaintMessage(msg);\n                \n                // add annotated length to User.annotation length and post to DB\n                me.logToDatabase("annotationLength",{\n                    source:me.User.source,\n                    atlas:me.User.atlasFilename,\n                    length:me.annotationLength\n                })\n                .then(function(response){\n                    var length = parseInt(response.length);\n                    me.info.length = length+" mm";\n                    me.displayInformation();\n                });\n                \n                me.annotationLength=0;\n                \n                // compute total segmented volume\n                var vol=me.computeSegmentedVolume();\n                me.info.volume=parseInt(vol)+" mm3";\n                break;\n            case \'eyedrop\':\n                me.displayInformation();\n                \n                var msg={"c":"mu"};\n                me.sendPaintMessage(msg);\n                break;\n            default:\n                var msg={"c":"mu"};\n                me.sendPaintMessage(msg);\n        }\n        \n        /*\n            TEST\n        */\n        //me.sendRequestSliceMessage();\n    },\n    /**\n     * @function keyDown\n     */\n    keyDown: function keyDown(e) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(keyDown,2,"#f00");if(l)console.log.apply(undefined,l);\n    \n        // console.log("key:",e.which);\n        \n        if(e.which==13 && jquery_default()(e.target).attr(\'contenteditable\')) {\n            e.preventDefault();\n            return;\n        }\n        \n        if(e.target.tagName!="BODY")\n            return;\n    \n        switch(e.which) {\n            case 13: // return\n                if(me.User.measureLength) {\n                    var length=0;\n                    var p=me.User.measureLength;\n                    var wdim=me.brain_Wdim,hdim=me.brain_Hdim;\n                    var i;\n                    for(i=1;i<p.length;i++)\n                        length+=Math.sqrt(Math.pow(wdim*(p[i].x-p[i-1].x),2)+Math.pow(hdim*(p[i].y-p[i-1].y),2));\n                    jquery_default()("#log").append("Length: "+length+"<br/>");\n                    me.User.measureLength=null;\n                }\n                break;\n            case 37: // left arrow\n                me.prevSlice();\n                e.preventDefault();\n                break;\n            case 39: // right arrow\n                me.nextSlice(this);\n                e.preventDefault();\n                break;\n        }\n    },\n    /**\n     * @function onkey\n     */\n    onkey: function onkey(e) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(onkey,2,"#f00");if(l)console.log.apply(undefined,l);\n\n        if (e.keyCode == 13) {\n            me.sendChatMessage();\n        }\n    }\n}\n\n// EXTERNAL MODULE: ./view/downloads/pako.min.js\nvar pako_min = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./view/atlasMaker/src/atlasMaker-io.js\n/*! AtlasMaker: Input/Output */\n\n\n\n/**\n * @page AtlasMaker: Input/Output\n */\nvar AtlasMakerIO = {\n    NiiHdrLE: Struct()\n        .word32Sle(\'sizeof_hdr\')        // Size of the header. Must be 348 (bytes)\n        .chars(\'data_type\',10)          // Not used; compatibility with analyze.\n        .chars(\'db_name\',18)            // Not used; compatibility with analyze.\n        .word32Sle(\'extents\')           // Not used; compatibility with analyze.\n        .word16Sle(\'session_error\')     // Not used; compatibility with analyze.\n        .word8(\'regular\')               // Not used; compatibility with analyze.\n        .word8(\'dim_info\')              // Encoding directions (phase, frequency, slice).\n        .array(\'dim\',8,\'word16Sle\')     // Data array dimensions.\n        .floatle(\'intent_p1\')           // 1st intent parameter.\n        .floatle(\'intent_p2\')           // 2nd intent parameter.\n        .floatle(\'intent_p3\')           // 3rd intent parameter.\n        .word16Sle(\'intent_code\')       // nifti intent.\n        .word16Sle(\'datatype\')            // Data type.\n        .word16Sle(\'bitpix\')            // Number of bits per voxel.\n        .word16Sle(\'slice_start\')        // First slice index.\n        .array(\'pixdim\',8,\'floatle\')    // Grid spacings (unit per dimension).\n        .floatle(\'vox_offset\')            // Offset into a .nii file.\n        .floatle(\'scl_slope\')            // Data scaling, slope.\n        .floatle(\'scl_inter\')            // Data scaling, offset.\n        .word16Sle(\'slice_end\')            // Last slice index.\n        .word8(\'slice_code\')            // Slice timing order.\n        .word8(\'xyzt_units\')            // Units of pixdim[1..4].\n        .floatle(\'cal_max\')                // Maximum display intensity.\n        .floatle(\'cal_min\')                // Minimum display intensity.\n        .floatle(\'slice_duration\')        // Time for one slice.\n        .floatle(\'toffset\')                // Time axis shift.\n        .word32Sle(\'glmax\')                // Not used; compatibility with analyze.\n        .word32Sle(\'glmin\')                // Not used; compatibility with analyze.\n        .chars(\'descrip\',80)            // Any text.\n        .chars(\'aux_file\',24)            // Auxiliary filename.\n        .word16Sle(\'qform_code\')        // Use the quaternion fields.\n        .word16Sle(\'sform_code\')        // Use of the affine fields.\n        .floatle(\'quatern_b\')            // Quaternion b parameter.\n        .floatle(\'quatern_c\')            // Quaternion c parameter.\n        .floatle(\'quatern_d\')            // Quaternion d parameter.\n        .floatle(\'qoffset_x\')            // Quaternion x shift.\n        .floatle(\'qoffset_y\')            // Quaternion y shift.\n        .floatle(\'qoffset_z\')            // Quaternion z shift.\n        .array(\'srow_x\',4,\'floatle\')    // 1st row affine transform\n        .array(\'srow_y\',4,\'floatle\')    // 2nd row affine transform.\n        .array(\'srow_z\',4,\'floatle\')    // 3rd row affine transform.\n        .chars(\'intent_name\',16)        // Name or meaning of the data.\n        .chars(\'magic\',4),                // Magic string.\n    NiiHdrBE: Struct()\n        .word32Sbe(\'sizeof_hdr\')        // Size of the header. Must be 348 (bytes)\n        .chars(\'data_type\',10)          // Not used; compatibility with analyze.\n        .chars(\'db_name\',18)            // Not used; compatibility with analyze.\n        .word32Sbe(\'extents\')           // Not used; compatibility with analyze.\n        .word16Sbe(\'session_error\')     // Not used; compatibility with analyze.\n        .word8(\'regular\')               // Not used; compatibility with analyze.\n        .word8(\'dim_info\')              // Encoding directions (phase, frequency, slice).\n        .array(\'dim\',8,\'word16Sbe\')     // Data array dimensions.\n        .floatbe(\'intent_p1\')           // 1st intent parameter.\n        .floatbe(\'intent_p2\')           // 2nd intent parameter.\n        .floatbe(\'intent_p3\')           // 3rd intent parameter.\n        .word16Sbe(\'intent_code\')       // nifti intent.\n        .word16Sbe(\'datatype\')            // Data type.\n        .word16Sbe(\'bitpix\')            // Number of bits per voxel.\n        .word16Sbe(\'slice_start\')        // First slice index.\n        .array(\'pixdim\',8,\'floatbe\')    // Grid spacings (unit per dimension).\n        .floatbe(\'vox_offset\')            // Offset into a .nii file.\n        .floatbe(\'scl_slope\')            // Data scaling, slope.\n        .floatbe(\'scl_inter\')            // Data scaling, offset.\n        .word16Sbe(\'slice_end\')            // Last slice index.\n        .word8(\'slice_code\')            // Slice timing order.\n        .word8(\'xyzt_units\')            // Units of pixdim[1..4].\n        .floatbe(\'cal_max\')                // Maximum display intensity.\n        .floatbe(\'cal_min\')                // Minimum display intensity.\n        .floatbe(\'slice_duration\')        // Time for one slice.\n        .floatbe(\'toffset\')                // Time axis shift.\n        .word32Sbe(\'glmax\')                // Not used; compatibility with analyze.\n        .word32Sbe(\'glmin\')                // Not used; compatibility with analyze.\n        .chars(\'descrip\',80)            // Any text.\n        .chars(\'aux_file\',24)            // Auxiliary filename.\n        .word16Sbe(\'qform_code\')        // Use the quaternion fields.\n        .word16Sbe(\'sform_code\')        // Use of the affine fields.\n        .floatbe(\'quatern_b\')            // Quaternion b parameter.\n        .floatbe(\'quatern_c\')            // Quaternion c parameter.\n        .floatbe(\'quatern_d\')            // Quaternion d parameter.\n        .floatbe(\'qoffset_x\')            // Quaternion x shift.\n        .floatbe(\'qoffset_y\')            // Quaternion y shift.\n        .floatbe(\'qoffset_z\')            // Quaternion z shift.\n        .array(\'srow_x\',4,\'floatbe\')    // 1st row affine transform\n        .array(\'srow_y\',4,\'floatbe\')    // 2nd row affine transform.\n        .array(\'srow_z\',4,\'floatbe\')    // 3rd row affine transform.\n        .chars(\'intent_name\',16)        // Name or meaning of the data.\n        .chars(\'magic\',4),                // Magic string.\n    MghHdr: Struct()\n        .word32Sbe(\'v\')\n        .word32Sbe(\'ndim1\')\n        .word32Sbe(\'ndim2\')\n        .word32Sbe(\'ndim3\')\n        .word32Sbe(\'nframes\')\n        .word32Sbe(\'type\')\n        .word32Sbe(\'dof\')\n        .word16Sbe(\'ras_good_flag\')\n        .array(\'delta\',3,\'floatbe\')\n        .array(\'Mdc\',9,\'floatbe\')\n        .array(\'Pxyz_c\',3,\'floatbe\'),\n    MghFtr: Struct()\n        .array(\'mrparms\',4,\'floatbe\'),\n    /**\n     * @function encodeNifti\n     */\n    encodeNifti: function encodeNifti() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(encodeNifti);if(l)console.log.apply(undefined,l);\n\n        var sizeof_hdr=348;\n        var dimensions=4;            // number of dimension values provided\n        var spacetimeunits=2+8;        // 2=nifti code for millimetres | 8=nifti code for seconds\n        var datatype=2;                // datatype for 8 bits (DT_UCHAR8 in nifti or UCHAR in analyze)\n        var vox_offset=352;\n        var bitsPerVoxel=8;\n    \n        var newHdr = {\n            sizeof_hdr: sizeof_hdr,\n                data_type: \'\', db_name: \'\', extents: 0, session_error: 0, regular: 0, dim_info: 0,\n            dim: [3, me.User.dim[0], me.User.dim[1], me.User.dim[2], 1, 1, 1, 1],\n                intent_p1: 0, intent_p2: 0, intent_p3: 0, intent_code: 0,\n            datatype: datatype,    // uchar\n            bitpix: bitsPerVoxel,\n                slice_start: 0,\n            pixdim: [-1, me.User.pixdim[0], me.User.pixdim[1], me.User.pixdim[2], 0, 1, 1, 1],\n            vox_offset: vox_offset,\n                scl_slope: 1, scl_inter: 0, slice_end: 0, slice_code: 0,\n                xyzt_units: 10,\n                cal_max: 0, cal_min: 0, slice_duration: 0, toffset: 0,\n                glmax: 0, glmin: 0,\n                descrip: \'BrainBox, 20 August 2016\',\n                aux_file: \'\',\n                qform_code: 0,\n                sform_code: 1,\n                quatern_b: 0, quatern_c: 0, quatern_d: 0,\n                qoffset_x: 0, qoffset_y: 0, qoffset_z: 0,\n            srow_x: [me.User.v2w[0][0], me.User.v2w[1][0], me.User.v2w[2][0], me.User.wori[0]],\n            srow_y: [me.User.v2w[0][1], me.User.v2w[1][1], me.User.v2w[2][1], me.User.wori[1]],\n            srow_z: [me.User.v2w[0][2], me.User.v2w[1][2], me.User.v2w[2][2], me.User.wori[2]],\n                intent_name: \'\',\n                magic: \'n+1\'\n        };\n        me.NiiHdrLE.allocate();\n        niihdr = me.NiiHdrLE.buffer();\n        for(i in newHdr)\n            me.NiiHdrLE.fields[i] = newHdr[i];\n        hdr = toArrayBuffer(niihdr);\n        var data=me.atlas.data;\n        var nii = new Uint8Array(vox_offset+data.length);\n        for(i=0;i<sizeof_hdr;i++)\n            nii[i]=hdr[i];\n        for(i=0;i<data.length;i++)\n            nii[i+vox_offset]=data[i];\n\n        var niigz=new pako_min["Deflate"]({gzip:true});\n        niigz.push(nii,true);\n            \n        return niigz.result;\n    },\n    /**\n     * @function saveNifti\n     */\n    saveNifti: function saveNifti() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(saveNifti);if(l)console.log.apply(undefined,l);\n    \n        var niigz=me.encodeNifti();\n        var niigzBlob = new Blob([niigz]);\n    \n        jquery_default()("a#download_atlas").attr("href",window.URL.createObjectURL(niigzBlob));\n        jquery_default()("a#download_atlas").attr("download",me.User.atlasFilename);\n    },\n    swapInt16: function swapInt16(arr) {\n        var i,dv = new DataView(arr.buffer);\n        for(i=0;i<arr.length;i++) {\n            arr[i]= dv.getInt16(2*i,false);\n        }\n        return arr;\n    },\n    swapUint16: function swapUint16(arr) {\n        var i,dv = new DataView(arr.buffer);\n        for(i=0;i<arr.length;i++) {\n            arr[i]= dv.getUint16(2*i,false);\n        }\n        return arr;\n    },\n    swapInt32: function swapInt32(arr) {\n        var i,dv = new DataView(arr.buffer);\n        for(i=0;i<arr.length;i++) {\n            arr[i]= dv.getInt32(4*i,false);\n        }\n        return arr;\n    },\n    swapFloat32: function swapFloat32(arr) {\n        var i,dv = new DataView(arr.buffer);\n        for(i=0;i<arr.length;i++) {\n            arr[i]= dv.getFloat32(4*i,false);\n        }\n        return arr;\n    },\n    /**\n     * @function loadNifti\n     */\n    loadNifti: function loadNifti(nii) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(loadNifti,1);if(l)console.log.apply(undefined,l);\n        var endianness=\'le\';\n\n        me.NiiHdrLE._setBuff(toBuffer(nii));\n        var h=JSON.parse(JSON.stringify(me.NiiHdrLE.fields));\n        if(h.sizeof_hdr!=348) {\n            me.NiiHdrBE._setBuff(toBuffer(nii));\n            h=JSON.parse(JSON.stringify(me.NiiHdrBE.fields));   \n            endianness=\'be\';     \n        }\n\n        var    vox_offset=h.vox_offset;\n        var    sizeof_hdr=h.sizeof_hdr;\n    \n        var mri={};\n        mri.hdr=nii.slice(0,vox_offset);\n        mri.datatype=h.datatype;\n        mri.dim=[h.dim[1],h.dim[2],h.dim[3]];\n        mri.pixdim=[h.pixdim[1],h.pixdim[2],h.pixdim[3]];\n        \n        switch(mri.datatype)\n        {\n            case 2: // UCHAR\n                mri.data=new Uint8Array(nii,vox_offset);\n                break;\n            case 256: // INT8\n                mri.data=new Uint8Array(nii,vox_offset);\n                break;\n            case 4: // SHORT\n                if(endianness==\'le\')\n                    mri.data=new Int16Array(nii,vox_offset);\n                else\n                    mri.data=me.swapInt16(new Int16Array(nii,vox_offset));\n                break;\n            case 8:  // INT\n                if(endianness==\'le\')\n                    mri.data=new Int32Array(nii,vox_offset);\n                else\n                    mri.data=me.swapInt32(new Int32Array(nii,vox_offset));\n                break;\n            case 16: // FLOAT\n                if(endianness==\'le\')\n                    mri.data=new Float32Array(nii,vox_offset);\n                else\n                    mri.data=me.swapFloat32(new Float32Array(nii,vox_offset));\n                break;\n            case 256: // INT8\n                mri.data=new Int8Array(nii,vox_offset);\n                break;\n            case 512: // UINT16\n                if(endianness==\'le\')\n                    mri.data=new Uint16Array(nii,vox_offset);\n                else\n                    mri.data=me.swapUint16(new Uint16Array(nii,vox_offset));\n                break;\n            default:\n                console.log("ERROR: Unknown dataType: "+mri.datatype);\n        }\n    \n        return mri;\n    },\n    /*\n        {Linear algebra\n    */\n    /**\n     * @function computeS2VTransformation\n     */\n    computeS2VTransformation: function computeS2VTransformation() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(computeS2VTransformation);if(l)console.log.apply(undefined,l);\n        \n        /**\n         * @todo Much of the code downstairs can be removed\n         */\n\n        var mri = me.User;\n        var v2w=mri.v2w;\n        var wori=mri.wori;\n        var wpixdim=me.subVecVec(me.mulMatVec(v2w,[1,1,1]),me.mulMatVec(v2w,[0,0,0]));\n        var wvmax=me.addVecVec(me.mulMatVec(v2w,[mri.dim[0]-1,mri.dim[1]-1,mri.dim[2]-1]),wori);\n        var wvmin=me.addVecVec(me.mulMatVec(v2w,[0,0,0]),wori);\n        var wmin=[Math.min(wvmin[0],wvmax[0]),Math.min(wvmin[1],wvmax[1]),Math.min(wvmin[2],wvmax[2])];\n        var wmax=[Math.max(wvmin[0],wvmax[0]),Math.max(wvmin[1],wvmax[1]),Math.max(wvmin[2],wvmax[2])];\n        var w2s=[[1/Math.abs(wpixdim[0]),0,0],[0,1/Math.abs(wpixdim[1]),0],[0,0,1/Math.abs(wpixdim[2])]];\n\n        var i=v2w[0];\n        var j=v2w[1];\n        var k=v2w[2];\n        var mi={i:0,v:0};i.map(function(o,n){if(Math.abs(o)>Math.abs(mi.v)) mi={i:n,v:o}});\n        var mj={i:0,v:0};j.map(function(o,n){if(Math.abs(o)>Math.abs(mj.v)) mj={i:n,v:o}});\n        var mk={i:0,v:0};k.map(function(o,n){if(Math.abs(o)>Math.abs(mk.v)) mk={i:n,v:o}});\n        mri.s2v = {\n            // old s2v fields\n            s2w: me.invMat(w2s),\n            sdim: [],\n            sori: [-wmin[0]/Math.abs(wpixdim[0]),-wmin[1]/Math.abs(wpixdim[1]),-wmin[2]/Math.abs(wpixdim[2])],\n            wpixdim: [],\n            w2v: me.invMat(v2w),\n            wori: wori,\n\n            // new s2v transformation\n            x: mi.i, // correspondence between space coordinate x and voxel coordinate i\n            y: mj.i, // same for y\n            z: mk.i, // same for z\n            dx: (mi.v>0)?1:(-1), // direction of displacement in space coordinate x with displacement in voxel coordinate i\n            dy: (mj.v>0)?1:(-1), // same for y\n            dz: (mk.v>0)?1:(-1), // same for z\n            X: (mi.v>0)?0:(mri.dim[0]-1), // starting value for space coordinate x when voxel coordinate i starts\n            Y: (mj.v>0)?0:(mri.dim[1]-1), // same for y\n            Z: (mk.v>0)?0:(mri.dim[2]-1) // same for z\n        };\n        mri.v2w=v2w;\n        mri.wori=wori;\n        mri.s2v.sdim[mi.i] = mri.dim[0];\n        mri.s2v.sdim[mj.i] = mri.dim[1];\n        mri.s2v.sdim[mk.i] = mri.dim[2];\n        mri.s2v.wpixdim[mi.i] = mri.pixdim[0];\n        mri.s2v.wpixdim[mj.i] = mri.pixdim[1];\n        mri.s2v.wpixdim[mk.i] = mri.pixdim[2];\n    },\n    /**\n     * @function testS2VTransformation\n     */\n    testS2VTransformation: function testS2VTransformation() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(testS2VTransformation);if(l)console.log.apply(undefined,l);\n        \n        /*\n            check the S2V transformation to see if it looks correct.\n            If it does not, reset it\n        */\n        var mri=me.User; // this line is different from server\n        var doReset=false;\n    \n        // console.log("Transformation TEST:");\n        // console.log("  1. transformation volume");\n        \n        var vv=mri.dim[0]*mri.dim[1]*mri.dim[2];\n        var vs=mri.s2v.sdim[0]*mri.s2v.sdim[1]*mri.s2v.sdim[2];\n        var diff=(vs-vv)/vv;\n        if(Math.abs(diff)>0.001) {\n            console.log("    ERROR: Difference is too large");\n            console.log("    original volume:",vv);\n            console.log("    rotated volume:",vs);\n            console.log("    % difference:",diff*100);\n            doReset=true;\n        } else {\n            // console.log("    ok.");\n        }\n    \n        // console.log("  2. transformation origin");\n        if(    mri.s2v.sori[0]<0||mri.s2v.sori[0]>mri.s2v.sdim[0] ||\n            mri.s2v.sori[1]<0||mri.s2v.sori[1]>mri.s2v.sdim[1] ||\n            mri.s2v.sori[2]<0||mri.s2v.sori[2]>mri.s2v.sdim[2]) {\n            // console.log("    Origin point is outside the dimensions of the data");\n            doReset=true;\n        } else {\n            // console.log("    ok.");\n        }\n\n        if(doReset) {\n            // console.log("THE TRANSFORMATION WILL BE RESET");\n            mri.v2w=[[mri.pixdim[0],0,0],[0,-mri.pixdim[1],0],[0,0,-mri.pixdim[2]]];\n            mri.wori=[0,mri.dim[1]-1,mri.dim[2]-1];\n\n            // re-compute the transformation from voxel space to screen space\n            me.computeS2VTransformation(); // this line is different from server\n            /*\n            console.log(mri.dir);\n            console.log(mri.ori);\n            console.log(mri.s2v);\n            */\n        }\n    },\n    /**\n     * @function S2I\n     */\n    S2I: function S2I(s,mri) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(S2I,3);if(l)console.log.apply(undefined,l);\n        \n        var s2v = mri.s2v;\n        var v = [s2v.X+s2v.dx*s[s2v.x],s2v.Y+s2v.dy*s[s2v.y],s2v.Z+s2v.dz*s[s2v.z]];\n        const index = v[0] + v[1]*mri.dim[0] + v[2]*mri.dim[0]*mri.dim[1];\n        return index;\n    },\n    /**\n     * @function mulMatVec\n     */\n    mulMatVec: function mulMatVec(m,v) {\n        return [\n            m[0][0]*v[0]+m[0][1]*v[1]+m[0][2]*v[2],\n            m[1][0]*v[0]+m[1][1]*v[1]+m[1][2]*v[2],\n            m[2][0]*v[0]+m[2][1]*v[1]+m[2][2]*v[2]\n        ];\n    },\n    /**\n     * @function invMat\n     */\n    invMat: function invMat(m) {\n        var det;\n        var w=[[],[],[]];\n\n        det=m[0][1]*m[1][2]*m[2][0] + m[0][2]*m[1][0]*m[2][1] + m[0][0]*m[1][1]*m[2][2] - m[0][2]*m[1][1]*m[2][0] - m[0][0]*m[1][2]*m[2][1] - m[0][1]*m[1][0]*m[2][2];\n    \n        w[0][0]=(m[1][1]*m[2][2] - m[1][2]*m[2][1])/det;\n        w[0][1]=(m[0][2]*m[2][1] - m[0][1]*m[2][2])/det;\n        w[0][2]=(m[0][1]*m[1][2] - m[0][2]*m[1][1])/det;\n    \n        w[1][0]=(m[1][2]*m[2][0] - m[1][0]*m[2][2])/det;\n        w[1][1]=(m[0][0]*m[2][2] - m[0][2]*m[2][0])/det;\n        w[1][2]=(m[0][2]*m[1][0] - m[0][0]*m[1][2])/det;\n    \n        w[2][0]=(m[1][0]*m[2][1] - m[1][1]*m[2][0])/det;\n        w[2][1]=(m[0][1]*m[2][0] - m[0][0]*m[2][1])/det;\n        w[2][2]=(m[0][0]*m[1][1] - m[0][1]*m[1][0])/det;\n    \n        return w;\n    },\n    /**\n     * @function subVecVec\n     */\n    subVecVec: function subVecVec(a,b) {\n        return [a[0]-b[0],a[1]-b[1],a[2]-b[2]];\n    },\n    /**\n     * @function addVecVec\n     */\n    addVecVec: function addVecVec(a,b) {\n        return [a[0]+b[0],a[1]+b[1],a[2]+b[2]];\n    },\n    /*\n        Linear Algebra}\n    */\n};\n// CONCATENATED MODULE: ./view/atlasMaker/src/atlasMaker-paint.js\n/*! AtlasMaker: Painting commands */\n\n\n/**\n * @page AtlasMaker: Painting commands\n */\nvar AtlasMakerPaint = {\n    //====================================================================================\n    // Paint functions\n    //====================================================================================\n    showxy: function showxy(u,c,x,y,usr) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(showxy,1,"#0c0");if(l)console.log.apply(undefined,l);\n    \n        // u: user number\n        // c: command\n        // x, y: coordinates\n        msg={c: c, x: x, y: y};\n        if(u==-1 && JSON.stringify(msg)!=JSON.stringify(me.msg0)) {\n            me.sendShowMessage(msg);\n            me.msg0=msg;\n        }\n        if(u!=-1) {\n            switch(c) {\n                case \'u\':\n                    if(usr.pointer) {\n                        usr.pointer.remove();\n                        delete usr.pointer;\n                    }\n                    break;\n                case \'m\':\n                    if(!usr.pointer) {\n                        usr.pointer = jquery_default()([\n                            \'<div style="display:inline-block;height:20px;margin-left:-10px;margin-top:-10px;position:absolute;color:white">\',\n                            \'<img src="\' + me.hostname + \'/img/show.svg" height="100%"/>\',\n                            ((usr.username == \'Anonymous\')?u:usr.username),\n                            \'</div>\'\n                            ].join(\'\'));\n                        jquery_default()("#resizable").append(usr.pointer);\n                    }\n                    usr.pointer.css({left:x*jquery_default()("#resizable").width()/me.brain_W,top:y*jquery_default()("#resizable").height()/me.brain_H});\n                    break;\n            }\n        }\n        usr.x0=x;\n        usr.y0=y;\n    },\n    /**\n     * @function paintxy\n     * @desc Dispatches paint/erase commands to the annotation volume and to the server for broadcast\n     * @param {integer} u The number of the user producing the paint event. u === -1 means that the paint event was produced by a different user, and it is not broadcasted (to prevent loops)\n     * @param {character} c The paint command: le, lf, e, f.\n     * @param {integer} x X coordinate in slice space\n     * @param {integer} y Y coordinate in slice space\n     * @param {Object} usr User object for the current user. Contains the painting value, view and slice\n     */\n    paintxy: function paintxy(u,c,x,y,usr) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(paintxy,1,"#0c0");if(l)console.log.apply(undefined,l);\n    \n        // u: user number\n        // c: command\n        // x, y: coordinates\n        msg={c:c,x:x,y:y};\n        \n        if(u==-1 && JSON.stringify(msg)!=JSON.stringify(me.msg0)) {\n            me.sendPaintMessage(msg);\n            me.msg0=msg;\n        }\n        \n        var    dim=me.atlas.dim;\n    \n        var    coord={x:x,y:y,z:usr.slice};\n        if(usr.x0<0) {\n            usr.x0=coord.x;\n            usr.y0=coord.y;\n        }\n\n        if(u!=-1) {\n            if(c === \'mu\') {\n                if(usr.pointer) {\n                    usr.pointer.remove();\n                    delete usr.pointer;\n                }\n            } else {\n                if(!usr.pointer) {\n                    usr.pointer = jquery_default()([\n                        \'<div style="display:inline-block;height:20px;margin-left:-10px;margin-top:-10px;position:absolute;color:white">\',\n                        \'<img src="\' + me.hostname + \'/img/show.svg" height="100%"/>\',\n                        ((usr.username == \'Anonymous\')?u:usr.username),\n                        \'</div>\'\n                        ].join(\'\'));\n                    jquery_default()("#resizable").append(usr.pointer);\n                }\n                usr.pointer.css({left:x*jquery_default()("#resizable").width()/me.brain_W,top:y*jquery_default()("#resizable").height()/me.brain_H});\n            }\n        }\n        var val=usr.penValue;\n        switch(c) {\n            case \'le\':\n                me.line(coord.x,coord.y,0,usr);\n                break;\n            case \'lf\':\n                me.line(coord.x,coord.y,val,usr);\n                break;\n            case \'e\':\n                me.fill(coord.x,coord.y,coord.z,0,usr.view);\n                break;\n            case \'f\':\n                me.fill(coord.x,coord.y,coord.z,val,usr.view);\n                break;\n        }\n\n        usr.x0=coord.x;\n        usr.y0=coord.y;\n    },\n    /**\n     * @function paintvol\n     * @desc Paints a series of voxels as indicated in an array. This function is exclusively used for undoing\n     * @param {Array} voxels Array where each object contains a voxel index and a voxel value. The voxel index goes from 0 to dim[0]*dim[1]*dim[2]-1\n     */\n    paintvol: function paintvol(voxels) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(paintvol,0,"#0c0");if(l)console.log.apply(undefined,l);\n    \n        var    i,\n            ind,            // voxel index\n            val;            // voxel delta-value, such that -=val undoes\n        for(i=0;i<voxels.length;i++) {\n            ind=voxels[i][0];\n            val=voxels[i][1];\n            \n            me.atlas.data[ind]=val;\n        }\n\n        me.drawImages();\n    },\n    /**\n     * @function fill\n     * @desc Fills a 2D slice in an annotation volume starting at coordinates x, y, z replacing all the connected pixels of same value as the original value at x, y, z\n     * @param {Integer} x X coordinate in voxel space\n     * @param {Integer} y Y coordinate in voxel space\n     * @param {Integer} z Z coordinate in voxel space\n     * @param {Integer} val Value to fill with\n     * @param {String} myView The stereotaxic plane along which to fill: either \'cor\', \'axi\' or \'sag\'\n     */\n    fill: function fill(x,y,z,val,myView) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(fill,0,"#0c0");if(l)console.log.apply(undefined,l);\n    \n        var    atlas=me.atlas;\n        var    dim=atlas.dim;\n\n        var    Q=[],\n            left,\n            right,\n            n;\n        var    i,max=0;\n        var bval=atlas.data[me.slice2index(x,y,z,myView)]; // background-value: value of the voxel where the click occurred\n        \n        if(bval==val)    // nothing to do\n            return;\n        \n        Q.push({x:x,y:y});\n        while(Q.length>0) {\n            if(Q.length>max)\n                max=Q.length;\n            n=Q.shift();\n            if(atlas.data[me.slice2index(n.x,n.y,z,myView)]!=bval)\n                continue;\n            left=n.x;\n            right=n.x;\n            y=n.y;\n            while (left-1>=0 && atlas.data[me.slice2index(left-1,y,z,myView)]==bval) {\n                left--;\n            }\n            while (right+1<me.brain_W && atlas.data[me.slice2index(right+1,y,z,myView)]==bval) {\n                right++;\n            }\n            for(x=left;x<=right;x++) {\n                atlas.data[me.slice2index(x,y,z,myView)]=val;\n                if(y-1>=0         && atlas.data[me.slice2index(x,y-1,z,myView)]==bval)\n                    Q.push({x:x,y:y-1});\n                if(y+1<me.brain_H && atlas.data[me.slice2index(x,y+1,z,myView)]==bval)\n                    Q.push({x:x,y:y+1});\n            }\n        }\n        me.drawImages();\n        console.log("max array size for fill:",max);\n    },\n    /**\n     * @function line\n     */\n    line: function line(x,y,val,usr) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(line,1,"#0c0");if(l)console.log.apply(undefined,l);\n    \n        // Bresenham\'s line algorithm adapted from\n        // http://stackoverflow.com/questions/4672279/bresenham-algorithm-in-javascript\n\n        var    atlas=me.atlas;\n        var    dim=atlas.dim;\n        var    xyzi1=new Array(4);\n        var    xyzi2=new Array(4);\n        var    i;\n        var    x1=usr.x0;\n        var y1=usr.y0;\n        var x2=x;\n        var y2=y;\n        var    z=usr.slice;\n\n        // Define differences and error check\n        var dx = Math.abs(x2 - x1);\n        var dy = Math.abs(y2 - y1);\n        var sx = (x1 < x2) ? 1 : -1;\n        var sy = (y1 < y2) ? 1 : -1;\n        var err = dx - dy;\n\n        xyzi1=me.slice2xyzi(x1,y1,z,usr.view);\n        xyzi2=me.slice2xyzi(x2,y2,z,usr.view);\n        me.annotationLength+=Math.sqrt(    Math.pow(me.brain_pixdim[0]*(xyzi1[0]-xyzi2[0]),2)+\n                                        Math.pow(me.brain_pixdim[1]*(xyzi1[1]-xyzi2[1]),2)+\n                                        Math.pow(me.brain_pixdim[2]*(xyzi1[2]-xyzi2[2]),2));\n    \n        for(j=0;j<Math.min(usr.penSize,me.brain_W-x1);j++)\n        for(k=0;k<Math.min(usr.penSize,me.brain_H-y1);k++) {\n            i=me.slice2index(x1+j,y1+k,z,usr.view);\n            atlas.data[i]=val;\n        }\n    \n        while (!((x1 == x2) && (y1 == y2))) {\n            var e2 = err << 1;\n            if (e2 > -dy) {\n                err -= dy;\n                x1 += sx;\n            }\n            if (e2 < dx) {\n                err += dx;\n                y1 += sy;\n            }\n            for(j=0;j<Math.min(usr.penSize,me.brain_W-x1);j++)\n            for(k=0;k<Math.min(usr.penSize,me.brain_H-y1);k++) {\n                i=me.slice2index(x1+j,y1+k,z,usr.view);\n                atlas.data[i]=val;\n            }\n        }\n        me.drawImages();\n    },\n    /**\n     * @function slice2index\n     */\n    slice2index: function slice2index(mx,my,mz,myView) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(slice2index,3,"#0c0");if(l)console.log.apply(undefined,l);\n    \n        var    dim=me.atlas.dim;\n        var    x,y,z,i;\n        switch(myView) {\n            case \'sag\':    x=mz; y=mx; z=me.brain_H-1-my;break; // sagital\n            case \'cor\':    x=mx; y=mz; z=me.brain_H-1-my;break; // coronal\n            case \'axi\':    x=mx; y=me.brain_H-1-my; z=mz;break; // axial\n        }\n/*\n    TRANSFORM SCREEN SPACE INTO VOXEL INDEX\n*/\n        var s=[x,y,z];\n        i=me.S2I(s,me.User);\n\n        return i;\n    },\n    /**\n     * @function slice2xyzi\n     * @desc Convert slice coordinates into voxel coordinates\n     * @return An array [x,y,z,i] where the first 3 values are the voxel coordinates and the 4th value is the voxel index (value from 0 to dim[0]*dim[1]*dim[2]-1)\n     */\n    slice2xyzi: function slice2xyzi(mx,my,mz,myView) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(slice2xyzi,1,"#0c0");if(l)console.log.apply(undefined,l);\n    \n        var    dim=me.atlas.dim;\n        var    x,y,z,i;\n        switch(myView) {\n            case \'sag\':    x=mz; y=mx; z=me.brain_H-1-my;break; // sagital\n            case \'cor\':    x=mx; y=mz; z=me.brain_H-1-my;break; // coronal\n            case \'axi\':    x=mx; y=me.brain_H-1-my; z=mz;break; // axial\n        }\n/*\n    TRANSFORM SCREEN SPACE INTO VOXEL INDEX\n*/\n        var s=[x,y,z];\n        i=me.S2I(s,me.User);\n\n        return [x,y,z,i];    \n    }\n};\n\n// CONCATENATED MODULE: ./view/atlasMaker/src/atlasMaker-ui.js\n/*! AtlasMaker: User Interface Elements */\n\n\n/**\n * @page AtlasMaker: User Interface Elements\n */\nvar AtlasMakerUI = {\n    /**\n     * @function slider\n     */\n    slider: function slider(elem,callback) {\n        // Initialise a \'slider\' control\n\n        jquery_default()(elem).data({\n            drag:false,\n            val:0,\n            max:100\n        });\n    \n        var movex=function(el,clientX) {\n            if (jquery_default()(el).data("drag")==true) {\n                var R=jquery_default()(el).find(".track")[0].getBoundingClientRect();\n                var x=(clientX-R.left)/R.width;\n                if(x<0) x=0;\n                if(x>1) x=1;\n                x=x*jquery_default()(el).data("max");\n                if(x!=jquery_default()(el).data("val")) {\n                    var max=jquery_default()(el).data("max");\n                    jquery_default()(el).data("val",x);\n                    jquery_default()(el).find(".thumb")[0].style.left=(x*100/max)+"%";\n                    callback(x);\n                }\n            }\n        };\n        jquery_default()(document).on("mousemove",function from_slider(ev){movex(elem,ev.clientX);});\n        jquery_default()(document).on("touchmove",function from_slider(ev){movex(elem,ev.originalEvent.changedTouches[0].pageX);});        \n        jquery_default()(document).on("mouseup touchend",function from_slider(){jquery_default()(elem).data({drag:false})});\n        jquery_default()(elem).on(\'mousedown touchstart\',function from_slider(){jquery_default()(elem).data({drag:true})});\n    },\n    /**\n     * @function chose\n     */\n    chose: function chose(elem,callback) {\n        // Initialise a \'chose\' control\n        var ch=jquery_default()(elem).find(".a");\n        ch.each(function(c,d){\n            jquery_default()(d).click(function(){\n                if(jquery_default()(this).hasClass("pressed")) {\n                    callback(jquery_default()(this).attr(\'title\'));\n                    return;\n                }\n                ch.each(function(){jquery_default()(this).removeClass("pressed")});\n                jquery_default()(this).addClass("pressed");\n                if(callback)\n                    callback(jquery_default()(this).attr(\'title\'));\n            });\n        });\n    },\n    /**\n     * @function toggle\n     */\n    toggle: function toggle(elem,callback) {\n        // Initialise a \'toggle\' control\n        jquery_default()(elem).click(function(){\n            jquery_default()(this).hasClass("pressed")?jquery_default()(this).removeClass("pressed"):jquery_default()(this).addClass("pressed");\n            if(callback)\n                callback(jquery_default()(this).hasClass("pressed"));\n        });\n    },\n    /**\n     * @function push\n     */\n    push: function push(elem,callback) {\n        // Initialise a \'push\' control\n        jquery_default()(elem).click(function(){\n            if(callback)\n                callback();\n        });\n    }\n};\n// CONCATENATED MODULE: ./view/atlasMaker/src/atlasMaker-ws.js\n/*! AtlasMaker: WebSockets */\n\n\n\n/**\n * @page AtlasMaker: WebSockets\n */\nvar AtlasMakerWS = {\n    //====================================================================================\n    // Web sockets\n    //====================================================================================\n    /**\n     * @function createSocket\n     * @desc  Create a WebSocket connection using the WebSocket object or the MozWebSocket\n     *        object.\n     */\n    createSocket: function createSocket(host) {\n        var me = AtlasMakerWidget;\n        var l = me.traceLog(createSocket, 0, "#aca"); if (l) console.log.apply(undefined, l);\n\n        var ws;\n\n        if (window.WebSocket) {\n            ws = new WebSocket(host);\n        } else if (window.MozWebSocket) {\n            ws = new MozWebSocket(host);\n        } else {\n            console.log("ERROR: browser does not support WebSockets");\n        }\n\n        return ws;\n    },\n    /**\n    * @function initSocketConnection\n    */\n    initSocketConnection: function initSocketConnection() {\n        var me = AtlasMakerWidget;\n        var l = me.traceLog(initSocketConnection, 0, "#aca"); if (l) console.log.apply(undefined, l);\n\n        return new Promise(function (resolve, reject) {\n            // WS connection\n            //var host = "ws://" + window.location.hostname + ":8080/";\n            var host = me.wshostname;\n\n            if (me.debug)\n                console.log("[initSocketConnection] host:", host);\n            if (me.progress)\n                me.progress.html("Connecting...");\n\n            try {\n                me.socket = me.createSocket(host);\n\n                me.socket.onopen = function (msg) {\n                    if (me.debug)\n                        console.log("[initSocketConnection] connection open", msg);\n                    me.progress.html("<img src=\'" + me.hostname + "/img/download.svg\' style=\'vertical-align:middle\'/>MRI");\n                    jquery_default()("#chat").text("Chat (1 connected)");\n                    me.flagConnected = 1;\n                    me.reconnectionTimeout = 5;\n                    resolve();\n                };\n\n                me.receiveFunctions["saveMetadata"] = me.receiveMetadata;\n                me.receiveFunctions["userData"] = me.receiveUserDataMessage;\n                me.receiveFunctions["volInfo"] = function (data) { console.log("volInfo", data) };\n                me.receiveFunctions["chat"] = me.receiveChatMessage;\n                me.receiveFunctions["show"] = me.receiveShowMessage;\n                me.receiveFunctions["paint"] = me.receivePaintMessage;\n                me.receiveFunctions["paintvol"] = me.receivePaintVolumeMessage;\n                me.receiveFunctions["disconnect"] = me.receiveDisconnectMessage;\n                me.receiveFunctions["serverMessage"] = me.receiveServerMessage;\n\n                me.receiveFunctions["requestSlice"] = function (data) { console.log("requestSlice", data) };\n                me.receiveFunctions["requestSlice2"] = function (data) { console.log("requestSlice2", data) };\n\n                me.socket.onmessage = me.receiveSocketMessage;\n\n                me.socket.onclose = function (msg) {\n                    me.flagConnected = 0;\n\n                    // Try to reconnect\n                    // wait a random initial time, to prevent an avalanche\n                    // of reconnections in case of server crash\n                    var rand = 1000 + 5000 * Math.random();\n                    console.log("Initial random time:", rand);\n                    setTimeout(function () {\n                        var timeout = me.reconnectionTimeout;\n                        jquery_default()("#chat").text("Disconnected. Try to reconnect in " + (timeout--) + " s...");\n                        if (me.timer) {\n                            clearInterval(me.timer);\n                        }\n                        me.timer = setInterval(function () {\n                            if (timeout < 0) {\n                                jquery_default()("#chat").text("Reconnecting...");\n                                me.socket = null;\n                                clearInterval(me.timer);\n                                setTimeout(function () {\n                                    me.reconnectionTimeout *= 2;\n                                    me.initSocketConnection()\n                                        .then(function () {\n                                            me.sendUserDataMessage("allUserData");\n                                            me.sendUserDataMessage("sendAtlas");\n                                            clearInterval(me.timer);\n                                        })\n                                        .catch(function () {\n                                            timeout = me.reconnectionTimeout;\n                                            jquery_default()("#chat").text("Disconnected. Try to reconnect in " + (timeout--) + " s...");\n                                        });\n                                }, 1000);\n                            } else {\n                                jquery_default()("#chat").text("Disconnected. Try to reconnect in " + (timeout--) + " s...");\n                            }\n                        }, 1000);\n                    }, rand);\n                };\n\n                window.onbeforeunload = function () {\n                    me.socket.onclose = function () { }; // disable onclose handler first\n                    me.socket.close()\n                };\n            }\n            catch (ex) {\n                jquery_default()("#chat").text("Chat (not connected - connection error)");\n            }\n        })\n    },\n    /**\n     * @function receiveSocketMessage\n     */\n    receiveSocketMessage: function receiveSocketMessage(msg) {\n        var me = AtlasMakerWidget;\n        var l = me.traceLog(receiveSocketMessage, 1, "#aca"); if (l) console.log.apply(undefined, l);\n\n        // Message: atlas data initialisation\n        if (msg.data instanceof Blob) {\n            me.receiveBinaryMessage(msg.data);\n            return;\n        }\n\n        // Message: interaction message\n        var data = JSON.parse(msg.data);\n        me.receiveFunctions[data.type](data);\n    },\n    /**\n     * @function sendUserDataMessage\n     */\n    sendUserDataMessage: function sendUserDataMessage(description) {\n        var me = AtlasMakerWidget;\n        var l = me.traceLog(sendUserDataMessage, 1, "#aca"); if (l) console.log.apply(undefined, l);\n\n        if (me.flagConnected == 0)\n            return;\n\n        if (me.debug > 1) console.log("message: " + description);\n\n        if (description === "allUserData")\n            var msg = { "type": "userData", "user": me.User, "description": description };\n        else\n            var msg = { "type": "userData", "description": description };\n        try {\n            me.socket.send(JSON.stringify(msg));\n        } catch (ex) {\n            console.log("ERROR: Unable to sendUserDataMessage", ex);\n        }\n    },\n    /**\n     * @function receiveBinaryMessage\n     */\n    receiveBinaryMessage: function receiveBinaryMessage(msgData) {\n        var me = AtlasMakerWidget;\n        var l = me.traceLog(receiveBinaryMessage, 1, "#aca"); if (l) console.log.apply(undefined, l);\n\n        var fileReader = new FileReader();\n        fileReader.onload = function from_receiveSocketMessage() {\n            var data = new Uint8Array(this.result);\n            var sz = data.length;\n            var ext = String.fromCharCode(data[sz - 8], data[sz - 7], data[sz - 6]);\n\n            if (me.debug > 1) console.log("type: " + ext);\n\n            switch (ext) {\n                case \'nii\': {\n                    var inflate = new pako_min["Inflate"]();\n                    inflate.push(data, true);\n                    var atlas = new Object();\n                    atlas.data = inflate.result;\n                    atlas.name = me.atlasFilename;\n                    atlas.dim = me.brain_dim;\n\n                    me.atlas = atlas;\n\n                    me.configureBrainImage();\n                    me.configureAtlasImage();\n                    me.resizeWindow();\n\n                    me.brain_img.img = null;\n                    me.drawImages();\n\n                    // compute total segmented volume\n                    var vol = me.computeSegmentedVolume();\n                    me.info.volume = parseInt(vol) + " mm3";\n\n                    // setup download link\n                    var link = me.container.find("span#download_atlas");\n                    link.html([\n                        "<a class=\'download\' href=\'" + me.User.dirname + me.User.atlasFilename + "\'>",\n                        "<img src=\'" + me.hostname + "/img/download.svg\' style=\'vertical-align:middle\'/>",\n                        "</a>" + atlas.name\n                    ].join(\'\'));\n\n                    break;\n                }\n                case \'jpg\': {\n                    var urlCreator = window.URL || window.webkitURL;\n                    var imageUrl = urlCreator.createObjectURL(msgData);\n                    var img = new Image();\n\n                    me.isMRILoaded = true; // receiving a jpg is proof of a loaded MRI\n\n                    img.onload = function from_initSocketConnection() {\n                        var flagFirstImage = (me.brain_img.img == null);\n                        me.brain_img.img = img;\n                        me.brain_img.view = me.flagLoadingImg.view;\n                        me.brain_img.slice = me.flagLoadingImg.slice;\n\n                        me.drawImages();\n\n                        me.flagLoadingImg.loading = false;\n\n                        if (flagFirstImage || me.flagLoadingImg.view != me.User.view || me.flagLoadingImg.slice != me.User.slice) {\n                            me.sendRequestSliceMessage();\n                        }\n\n                        // remove loading indicator\n                        jquery_default()("#loadingIndicator").hide();\n                    }\n                    img.src = imageUrl;\n\n                    break;\n                }\n            }\n        };\n        fileReader.readAsArrayBuffer(msgData);\n    },\n    /**\n     * @function receiveUserDataMessage\n     */\n    receiveUserDataMessage: function receiveUserDataMessage(data) {\n        var me = AtlasMakerWidget;\n        var l = me.traceLog(receiveUserDataMessage, 0, "#aca"); if (l) console.log.apply(undefined, l);\n\n        if (me.debug > 1) console.log("description: " + data.description, data);\n\n        var u = data.uid;\n\n        // First time the user is observed\n        if (me.Collab[u] === undefined) {\n            try {\n                //var    msg="<b>"+data.user.username+"</b> entered atlas "+data.user.specimenName+"/"+data.user.atlasFilename+"<br />"\n                var msg;\n                if (data.user === undefined || data.user.username === "Anonymous") {\n                    msg = "<b>" + data.uid + "</b> entered<br />";\n                } else {\n                    msg = "<b>" + data.user.username + "</b> entered<br />";\n                }\n                jquery_default()("#log").append(msg);\n                jquery_default()("#log").scrollTop(jquery_default()("#log")[0].scrollHeight);\n            } catch (e) {\n                console.log("data:", data);\n                console.log(e);\n            }\n        }\n\n        if (data.description === "allUserData")\n            me.Collab[u] = data.user;\n        else {\n            try {\n                var changes = JSON.parse(data.description);\n                var i;\n                for (i in changes)\n                    me.Collab[u][i] = changes[i];\n            } catch (e) {\n                console.log(e);\n            }\n        }\n\n        var v, nusers = 1;\n        for (v in me.Collab)\n            nusers++;\n        jquery_default()("#chat").text("Chat (" + nusers + " connected)");\n    },\n    /**\n     * @function sendChatMessage\n     */\n    sendChatMessage: function sendChatMessage() {\n        var me = AtlasMakerWidget;\n        var l = me.traceLog(sendChatMessage, 0, "#aca"); if (l) console.log.apply(undefined, l);\n\n        if (me.flagConnected == 0)\n            return;\n        var msg = DOMPurify.sanitize(jquery_default()(\'input#msg\')[0].value);\n        try {\n            me.socket.send(JSON.stringify({ "type": "chat", "msg": msg, "username": me.User.username }));\n            var msg = "<b>me: </b>" + msg + "<br />";\n            jquery_default()("#log").append(msg);\n            jquery_default()("#log").scrollTop(jquery_default()("#log")[0].scrollHeight);\n            jquery_default()(\'input#msg\').val("");\n        } catch (ex) {\n            console.log("ERROR: Unable to sendChatMessage", ex);\n        }\n    },\n    /**\n     * @function receiveChatMessage\n     */\n    receiveChatMessage: function receiveChatMessage(data) {\n        var me = AtlasMakerWidget;\n        var l = me.traceLog(receiveChatMessage, 0, "#aca"); if (l) console.log.apply(undefined, l);\n        console.log(data);\n\n        var theSource = me.Collab[data.uid].source;\n        var theView = me.Collab[data.uid].view;\n        var theSlice = me.Collab[data.uid].slice;\n        var link = me.hostname + "/mri?url=" + theSource + "&view=" + theView + "&slice=" + theSlice;\n        var theUsername = (data.username === "Anonymous")?data.uid:data.username;\n        var msg = "<a href=\'" +link+"\'><b>"+theUsername+":</b></a> "+data.msg+"<br />"\n        jquery_default()("#log").append(msg);\n        jquery_default()("#log").scrollTop(jquery_default()("#log")[0].scrollHeight);\n    },\n    /**\n     * @function sendPaintMessage\n     * @desc On user painting, this function broadcasts the painting event to all other connected users\n     * @param {Object} msg Painting event object: {"c":c,"x":x,"y":y}, where "c" is the command (l,e,lf,ef) and x and y are the coordinates in slice space\n     */\n    sendPaintMessage: function sendPaintMessage(msg) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(sendPaintMessage,1,"#aca");if(l)console.log.apply(undefined,l);\n\n        if(me.flagConnected==0)\n            return;\n        try {\n            me.socket.send(JSON.stringify({type:"paint",data:msg}));\n        } catch (ex) {\n            console.log("ERROR: Unable to sendPaintMessage",ex);\n        }\n    },\n    /**\n     * @function receivePaintMessage\n     * @desc Receive paint events from other connected users\n     */\n    receivePaintMessage: function receivePaintMessage(data) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(receivePaintMessage,3,"#aca");if(l)console.log.apply(undefined,l);\n\n        var    msg=data.data;\n        var u=data.uid;    // user\n        var c=msg.c;    // command\n        var x=parseInt(msg.x);    // x coordinate\n        var y=parseInt(msg.y);    // y coordinate\n\n        if(me.Collab[u])\n            me.paintxy(u,c,x,y,me.Collab[u]);\n    },\n    /**\n     * @function sendShowMessage\n     * @desc On user showing, this function broadcasts the showing event to all other connected users\n     * @param {Object} msg Showing event object: {"x":x,"y":y}, where x and y are the coordinates in slice space\n     */\n    sendShowMessage: function sendShowMessage(msg) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(sendShowMessage,1,"#aca");if(l)console.log.apply(undefined,l);\n\n        if(me.flagConnected==0)\n            return;\n        try {\n            me.socket.send(JSON.stringify({type:"show",data:msg}));\n        } catch (ex) {\n            console.log("ERROR: Unable to sendShowMessage",ex);\n        }\n    },\n    /**\n     * @function receiveShowMessage\n     * @desc Receive show events from other connected users\n     */\n    receiveShowMessage: function receiveShowMessage(data) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(receiveShowMessage,3,"#aca");if(l)console.log.apply(undefined,l);\n\n        var    msg=data.data;\n        var u=data.uid;    // user\n        var c=msg.c;    // command\n        var x=parseInt(msg.x);    // x coordinate\n        var y=parseInt(msg.y);    // y coordinate\n\n        if(me.Collab[u])\n            me.showxy(u,c,x,y,me.Collab[u]);\n    },\n    /**\n     * @function receivePaintVolumeMessage\n     */\n    receivePaintVolumeMessage: function receivePaintVolumeMessage(data) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(receivePaintVolumeMessage,0,"#aca");if(l)console.log.apply(undefined,l);\n\n        var    i,ind,val,voxels;\n\n        voxels=data.data;\n        me.paintvol(voxels.data);\n\n        /*\n            TEST\n        */\n        me.sendRequestSliceMessage();\n    },\n     /**\n     * @function sendUndoMessage\n     */\n    sendUndoMessage: function sendUndoMessage() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(sendUndoMessage,0,"#aca");if(l)console.log.apply(undefined,l);\n\n        if(me.flagConnected==0)\n            return;\n        try {\n            me.socket.send(JSON.stringify({type:"paint",data:{c:"u"}}));\n        } catch (ex) {\n            console.log("ERROR: Unable to sendUndoMessage",ex);\n        }\n    },\n     /**\n     * @function sendSaveMessage\n     */\n    sendSaveMessage: function sendSaveMessage() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(sendSaveMessage,0,"#aca");if(l)console.log.apply(undefined,l);\n\n        if(me.flagConnected==0)\n            return;\n        try {\n            me.socket.send(JSON.stringify({type:"save"}));\n        } catch (ex) {\n            console.log("ERROR: Unable to sendSaveMessage",ex);\n        }\n    },\n    /**\n     * @function sendRequestMRIMessage\n     */\n    sendRequestMRIMessage: function sendRequestMRIMessage(source) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(sendRequestMRIMessage,1,"#aca");if(l)console.log.apply(undefined,l);\n\n        if(me.flagConnected==0)\n            return;\n\n        try {\n            me.socket.send(JSON.stringify({\n                type:"requestMRI",\n                source:"sendRequestMRIMessage"\n            }));\n        } catch (ex) {\n            console.log("ERROR: Unable to sendRequestMRIMessage",ex);\n        }\n    },\n    /**\n     * @function sendRequestSliceMessage\n     */\n    sendRequestSliceMessage: function sendRequestSliceMessage() {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(sendRequestSliceMessage,1,"#aca");if(l)console.log.apply(undefined,l);\n\n        if(me.flagConnected==0)\n            return;\n        if(me.flagLoadingImg.loading==true)\n            return;\n        try {\n            me.socket.send(JSON.stringify({\n\n                type:"requestSlice",\n                /*\n                    TEST\n                */\n                //type:"requestSlice2",\n\n                view:me.User.view,\n                slice:me.User.slice\n            }));\n            me.flagLoadingImg.loading=true;\n            me.flagLoadingImg.view=me.User.view;\n            me.flagLoadingImg.slice=me.User.slice;\n\n        } catch (ex) {\n            console.log("ERROR: Unable to sendRequestSliceMessage",ex);\n        }\n    },\n    /**\n     * @todo This is really not the place for some of this code. The receiveMetadata\n     *       function is ok, but the direct references to projectInfo -- a structure\n     *       exclusively used by project.mustache -- should go to that file. Now, the\n     *       mechanism for uncoupling the 2 pieces of code is not clear. It could be\n     *       a subscription, for example.\n     */\n    receiveMetadata: function receiveMetadata(data) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(receiveMetadata,1,"#aca");if(l)console.log.apply(undefined,l);\n        var projShortname = projectInfo.shortname;\n        for (var i in projectInfo.files.list) {\n            if (projectInfo.files.list[i].source == data.metadata.source) {\n                for (var key in projectInfo.files.list[i].mri.annotations[projShortname]) {\n                    info_proxy["files.list." + i + ".mri.annotations." + projShortname + "." + key] = data.metadata.mri.annotations[projShortname][key];\n                }\n                info_proxy["files.list." + i + ".name"] = data.metadata.name;\n                break;\n            }\n        }\n    },\n    /**\n     * @function sendSaveMetadataMessage\n     */\n    sendSaveMetadataMessage: function sendSaveMetadataMessage(info, method, patch) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(sendSaveMetadataMessage,1,"#aca");if(l)console.log.apply(undefined,l);\n\n        return new Promise(function(resolve, reject) {\n            if(me.flagConnected==0) {\n                console.log("WARNING: Not connected: will not save metadata");\n                return reject();\n            }\n\n            try {\n                var rnd = Math.random().toString(36).slice(20);\n                var met = method || "append";\n                if(method == "patch") {\n                    me.socket.send(JSON.stringify({\n                        type:"saveMetadata",\n                        metadata: info,\n                        method: met,\n                        patch: patch,\n                        rnd: rnd\n                    }));\n                } else {\n                    me.socket.send(JSON.stringify({\n                        type:"saveMetadata",\n                        metadata: info,\n                        method: met,\n                        rnd: rnd\n                    }));\n                }\n                if(me.debug>1) {\n                    console.log(rnd);\n                    console.log(info);\n                }\n                resolve();\n\n            } catch (ex) {\n                console.log("ERROR: Unable to sendSaveMetadataMessage",ex);\n                reject();\n            }\n        });\n    },\n    /**\n     * @function receiveDisconnectMessage\n     */\n    receiveDisconnectMessage: function receiveDisconnectMessage(data) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(receiveDisconnectMessage,0,"#aca");if(l)console.log.apply(undefined,l);\n\n        var u=data.uid;    // user\n        if(me.Collab[u]) {\n            var    msg;\n            if(me.Collab[u].username === undefined || me.Collab[u].username === "Anonymous")\n                msg = "<b>"+me.Collab[u].uid+"</b> left<br />";\n            else\n                msg = "<b>"+me.Collab[u].username+"</b> left<br />";\n        }\n        else\n            var    msg="<b>"+u+"</b> left<br />";\n        delete me.Collab[u];\n        var    v,nusers=1; for(v in me.Collab) nusers++;\n        jquery_default()("#chat").text("Chat ("+nusers+" connected)");\n        jquery_default()("#log").append(msg);\n        jquery_default()("#log").scrollTop(jquery_default()("#log")[0].scrollHeight);\n    },\n    /**\n     * @function receiveServerMessage\n     */\n    receiveServerMessage: function receiveServerMessage(data) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(receiveServerMessage,0,"#aca");if(l)console.log.apply(undefined,l);\n\n        var msg=data.msg;\n        var prevMsg=jquery_default()("#chat").text();\n        jquery_default()("#chat").text(msg);\n        setTimeout(function(){jquery_default()("#chat").text(prevMsg)},5000);\n    },\n    /**\n     * @function replayWSTraffic\n     * @desc Replays websocket traffic recorded at the served. Used for debugging\n     * @param Array recorded An array of websocket messages recorded in the server\n     */\n    replayWSTraffic: function replayWSTraffic(recorded) {\n        var me=AtlasMakerWidget;\n        var l=me.traceLog(replayWSTraffic,0,"#aca");if(l)console.log.apply(undefined,l);\n        var i;\n        for(i=0;i<recorded.length;i++) {\n            me.socket.send(JSON.stringify(recorded[i]));\n        }\n    },\n    //==========\n    // Database\n    //==========\n    /**\n     * @function logToDatabase\n     */\n    logToDatabase: function logToDatabase(key,value) {\n        return new Promise(function(resolve, reject) {\n            var me=AtlasMakerWidget;\n            var l=me.traceLog(logToDatabase,1,"#bbd");if(l)console.log.apply(undefined,l);\n            jquery_default.a.ajax({\n                url: me.hostname + "/api/log",\n                type: "POST",\n                data: {\n                    username: me.User.username,\n                    key: key,\n                    value: value\n            }})\n            .done(function(data) {\n                resolve(data);\n            })\n            .fail(function() {\n                reject("Error");\n            });\n        });\n    }\n}\n// CONCATENATED MODULE: ./view/dist/atlasMaker-resources.js\nvar AtlasMakerResources = {\n  "html": {\n    "adjust": "<div id=\'adjust\' style=\'width:calc(100% - 20px );position:absolute;bottom:0;left:0;padding:10px;\'>\\n    \\n    \x3c!-- Transparency --\x3e\\n    <div>\\n        <img src=\'/img/alpha.svg\' style=\'width:20px;vertical-align:middle\'/>\\n        <div id=\'alphaLevel\' class=\'slider\' data-max=100 data-val=0 style=\'display:inline-block;position:relative;margin-left:10px;width:calc(100% - 30px - 20px);height:100%;vertical-align:middle\'>\\n            <div class=\'track\'\\n                 style=\'position:absolute;left:0;top:50%;width:100%;border-top:1px solid #fff;display:inline-block\'></div>\\n            <div class=\'thumb\'\\n                 style=\'transform:translate(-10px,-10px);border-radius:10px;position:absolute;left:0;top:50%;width:20px;height:20px;background-color:#fff;display:inline-block\'></div>\\n        </div>\\n    </div>\\n\\n    \x3c!-- Brightness --\x3e\\n    <div>\\n        <img src=\'/img/sun-o.svg\' style=\'width:20px;vertical-align:middle\'/>\\n        <div id=\'minLevel\' class=\'slider\' data-max=100 data-val=0 style=\'display:inline-block;position:relative;margin-left:10px;width:calc(100% - 30px - 20px);height:100%;vertical-align:middle\'>\\n            <div class=\'track\'\\n                 style=\'position:absolute;left:0;top:50%;width:100%;border-top:1px solid #fff;display:inline-block\'></div>\\n            <div class=\'thumb\'\\n                 style=\'transform:translate(-10px,-10px);border-radius:10px;position:absolute;left:0;top:50%;width:20px;height:20px;background-color:#fff;display:inline-block\'></div>\\n        </div>\\n    </div>\\n    \\n    \x3c!-- Contrast --\x3e\\n    <div>\\n        <img src=\'/img/adjust.svg\' style=\'width:20px;vertical-align:middle\'/>\\n        <div id=\'maxLevel\' class=\'slider\' data-max=100 data-val=0 style=\'display:inline-block;position:relative;margin-left:10px;width:calc(100% - 30px - 20px);height:100%;vertical-align:middle\'>\\n            <div class=\'track\'\\n                 style=\'position:absolute;left:0;top:50%;width:100%;border-top:1px solid #fff;display:inline-block\'></div>\\n            <div class=\'thumb\'\\n                 style=\'transform:translate(-10px,-10px);border-radius:10px;position:absolute;left:0;top:50%;width:20px;height:20px;background-color:#fff;display:inline-block\'></div>\\n        </div>\\n    </div>\\n\\n    <script>\\n        // Transparency\\n        AtlasMakerWidget.slider($(\'.slider#alphaLevel\'),function(x) {\\n            $(\'#alphaLevel\').data(\'val\',x);\\n            $(\'#alphaLevel .thumb\')[0].style.left=x+\'%\';\\n            AtlasMakerWidget.alphaLevel=x/100;\\n            AtlasMakerWidget.drawImages();\\n        });\\n        $(\'.slider#alphaLevel\').data({max:100,val:50});\\n        $(\'#alphaLevel .thumb\')[0].style.left=(AtlasMakerWidget.alphaLevel*100)+\'%\';\\n\\n        // Brightness\\n        AtlasMakerWidget.slider($(\'.slider#minLevel\'),function(x) {\\n            $(\'#minLevel\').data(\'val\',x);\\n            $(\'#minLevel .thumb\')[0].style.left=x+\'%\';\\n        \\n            var b=(2*x/100);\\n            var c=(2*$(\'#maxLevel\').data(\'val\')/100);\\n            $(\'#canvas\').css({\\n                \'webkit-filter\':\'brightness(\'+b+\') contrast(\'+c+\')\',\\n                \'filter\':\'brightness(\'+b+\') contrast(\'+c+\')\'\\n            });\\n        });\\n        $(\'.slider#minLevel\').data({max:100,val:50});\\n        $(\'#minLevel .thumb\')[0].style.left=\'50%\';\\n\\n        // Contrast\\n        AtlasMakerWidget.slider($(\'.slider#maxLevel\'),function(x) {\\n            $(\'#maxLevel\').data(\'val\',x);\\n            $(\'#maxLevel .thumb\')[0].style.left=x+\'%\';\\n            \\n            var b=(2*$(\'#minLevel\').data(\'val\')/100);\\n            var c=(2*x/100);\\n            $(\'#canvas\').css({\\n                \'webkit-filter\':\'brightness(\'+b+\') contrast(\'+c+\')\',\\n                \'filter\':\'brightness(\'+b+\') contrast(\'+c+\')\'\\n            });\\n        });\\n        $(\'.slider#maxLevel\').data({max:100,val:50});\\n        $(\'#maxLevel .thumb\')[0].style.left=\'50%\';\\n\\n        var observer = new MutationObserver(function(mutations) {\\n            mutations.forEach(function(mutation) {\\n                if (mutation.attributeName === \'class\') {\\n                    console.log(\'mutation\',mutation);\\n                    var attributeValue = $(mutation.target).prop(mutation.attributeName);\\n                    if(attributeValue==\'a\')\\n                        $(\'#adjust\').remove();\\n                        observer.disconnect();\\n                        delete observer;\\n                }\\n            });\\n        });\\n        observer.observe($(\'#paintTool [title=\\"Adjust\\"]\')[0], {\\n            attributes: true\\n        });\\n    <\/script>\\n</div>\\n",\n    "toolsFull": "<div id=\'tools-side\' style=\'display:block\'>\\n    <div id=\'tools-minimized\'>\\n        <div>\\n            <img style=\'width:28px;position:absolute;top:10px;left:10px\' src=\'/img/bars.svg\' />\\n        </div>\\n    </div>\\n\\n    <div id=\'tools-maximized\' style=\'display:flex;flex-direction:column;height:100%\'>\\n\\n        \x3c!-- tools hide/show, display left/right --\x3e\\n        <div id=\'headerBlock\' style=\'flex:0 1 28px;background:#333\'>\\n            <div style=\'display:flex\'>\\n                <div style=\'flex:0 0 28px\'><div id=\'display-minimize\' title=\'Minimize toolbar\' class=\'a push noBorder\'><img class=\'icon\' src=\'/img/times-circle.svg\' /></div></div>\\n                <div style=\'flex:1 1 auto\'></div>\\n                <div style=\'flex:0 0 28px\'><div id=\'display-left\' title=\'Display to the left\' class=\'a push noBorder\'><img class=\'icon\' src=\'/img/caret-square-o-left.svg\' /></div></div>\\n                <div style=\'flex:0 0 28px\'><div id=\'display-right\' title=\'Display to the right\' class=\'a push noBorder\'><img class=\'icon\' src=\'/img/caret-square-o-right.svg\' /></div></div>\\n            </div>\\n        </div>\\n\\n        \x3c!-- slider --\x3e\\n        <div id=\'sliderBlock\' style=\'flex:0 0 28px\'>\\n            <div style=\'display:flex\'>\\n                <div style=\'flex:0 0 28px\'>\\n                    <div id=\'prev\' class=\'a push\'>-</div>\\n                </div>\\n                <div style=\'flex:1 0 28px;display:flex\'>\\n                    <div style=\'flex:1;position:relative\'>\\n                        <div id=\'slice\' class=\'slider\' data-max=100 data-val=0 style=\'position:absolute;height:100%;margin-left:10px;width:calc(100% - 20px)\'>\\n                            <div class=\'track\' style=\'position:absolute;left:0;top:50%;width:100%;border-top:1px solid #fff;padding:0;display:inline-block\'></div>\\n                            <div class=\'thumb\' style=\'position:absolute;left:0;top:50%;transform:translate(-10px,-10px);border-radius:10px;padding:0;width:20px;height:20px;background:#fff;display:inline-block\'></div>\\n                        </div>\\n                    </div>\\n                </div>\\n                <div style=\'flex:0 0 28px\'>\\n                    <div id=\'next\' class=\'a push\'>+</div>\\n                </div>\\n            </div>\\n        </div>\\n\\n        \x3c!-- buttons --\x3e\\n        <div id=\'buttonsBlock\' style=\'flex:0 0 auto\'>\\n            <div style=\'display:flex;flex-wrap:wrap\'>\\n\\n                <div style=\'flex:1 0 250px;width:50px\'>\\n                    <div id=\'plane\' style=\'display:flex\' class=\'chose\'>\\n                        <div style=\'flex:1\'><div title=\'sag\' class=\'a pressed\'>Sag</div></div>\\n                        <div style=\'flex:1\'><div title=\'cor\' class=\'a\'>Cor</div></div>\\n                        <div style=\'flex:1\'><div title=\'axi\' class=\'a\'>Axi</div></div>\\n                    </div>\\n                    <div style=\'display:flex\'>\\n                        <div style=\'flex:1\'><div id=\'fullscreen\' title=\'Full screen\' class=\'a toggle\'><img class=\'icon\' src=\'/img/fullscreen.svg\' /></div></div>\\n                        <div style=\'flex:1\'><div id=\'3drender\' title=\'3D render\' class=\'a push\'><img class=\'icon\' src=\'/img/3drender.svg\' /></div></div>\\n                        <div style=\'flex:1\'><div id=\'link\' title=\'Link\' class=\'a push\'><img class=\'icon\' src=\'/img/link.svg\' /></div></div>\\n                        <div style=\'flex:1\'><div id=\'bubble\' title=\'Chat\' class=\'a toggle pressed\'><img class=\'icon\' src=\'/img/chat.svg\' /></div></div>\\n                        <div style=\'flex:1\'><div id=\'upload\' title=\'Upload\' class=\'a push\'><img class=\'icon\' src=\'/img/upload.svg\' /></div></div>\\n                        <div style=\'flex:1\'><div id=\'download\' title=\'Download\' class=\'a push\'><img class=\'icon\' src=\'/img/download.svg\' /></div></div>\\n                        <div style=\'flex:1\'><div id=\'precise\' title=\'Precise cursor\' class=\'a toggle\'><img class=\'icon\' src=\'/img/preciseCursor.svg\' /></div></div>\\n                    </div>\\n                </div>\\n\\n                <div style=\'flex:1 0 250px;width:50px\'>\\n                    <div id=\'paintTool\' style=\'display:flex\' class=\'chose\'>\\n                        <div style=\'flex:1\'><div title=\'Show\' class=\'a pressed\'><img class=\'icon\' src=\'/img/show.svg\' /></div></div>\\n                        <div style=\'flex:1\'><div title=\'Paint\' class=\'a\'><img class=\'icon\' src=\'/img/paint.svg\' /></div></div>\\n                        <div style=\'flex:1\'><div title=\'Erase\' class=\'a\'><img class=\'icon\' src=\'/img/erase.svg\' /></div></div>\\n                        <div style=\'flex:1\'><div title=\'Measure\' class=\'a\'><img class=\'icon\' src=\'/img/ruler.svg\' /></div></div>\\n                        <div style=\'flex:1\'><div title=\'Adjust\' class=\'a\'><img class=\'icon\' src=\'/img/adjust.svg\' /></div></div>\\n                        <div style=\'flex:1\'><div title=\'Eyedrop\' class=\'a\'><img class=\'icon\' src=\'/img/eyedropper.svg\' /></div></div>\\n                    </div>\\n                    <div style=\'display:flex\'>\\n                        <div style=\'flex:1\'><div id=\'color\'><div id=\'color\' title=\'Color\' style=\'height:24px;background:#f00\' class=\'a push\'></div></div></div>\\n                        <div style=\'flex:1\'><div id=\'fill\' class=\'a toggle\'><img class=\'icon\' src=\'/img/fill.svg\' /></div></div>\\n                        <div style=\'flex:1\'><div id=\'undo\' title=\'Undo\' class=\'a push\'><img class=\'icon\' src=\'/img/undo.svg\' /></div></div>\\n                        <div style=\'flex:1\'><div id=\'save\' title=\'Save\' class=\'a push\'><img class=\'icon\' src=\'/img/floppy.svg\' /></div></div>\\n                    </div>\\n                </div>\\n\\n            </div>\\n        </div>\\n\\n        \x3c!-- pen size --\x3e\\n        <div id=\'penSizeBlock\' style=\'flex:0 0 28px\'>\\n            <div style=\'display:flex\' class=\'chose\' id=\'penSize\'>\\n                <div style=\'flex:1\'><div title=\'1\' class=\'a pressed\'>1</div></div>\\n                <div style=\'flex:1\'><div title=\'2\' class=\'a\'>2</div></div>\\n                <div style=\'flex:1\'><div title=\'3\' class=\'a\'>3</div></div>\\n                <div style=\'flex:1\'><div title=\'5\' class=\'a\'>5</div></div>\\n                <div style=\'flex:1\'><div title=\'10\' class=\'a\'>10</div></div>\\n                <div style=\'flex:1\'><div title=\'15\' class=\'a\'>15</div></div>\\n            </div>\\n        </div>\\n\\n        \x3c!-- chat --\x3e\\n        <div id=\'chatBlock\' style=\'flex:1 1 auto;position:relative;display:flex\'>\\n            <div id=\'chatBlockContent\' style=\'flex:1;display:flex;flex-direction:column\'>\\n                <div style=\'flex:0 0 28px\'><div id=\'chat\' class=\'label\'>Chat (disconnected)</div></div>\\n                <div style=\'flex:1 1 58px;display:flex\'><div id=\'log\' class=\'a\' style=\'flex:1;height:auto\'></div></div>\\n                <div style=\'flex:0 0 28px\'><input id=\'msg\' type=\'text\' style=\'width:100%\'></div>\\n            </div>\\n        </div>\\n    </div>\\n\\n</div>\\n\\n\x3c!-- Loading indicator --\x3e\\n<div id=\'loadingIndicator\'>\\n    <p>Loading...</p>\\n    <div class=\'disc\'></div>\\n</div>\\n\x3c!-- End Loading indicator --\x3e\\n\\n\x3c!-- Labels --\x3e\\n<div id=\'labelset\'>\\n    <div style=\'z-index:23;text-align:right\'>\\n        <img id=\'labels-close\' class=\'button\' src=\'/img/times-circle.svg\'/>\\n    </div>\\n\\n    <ul style=\'padding-left:1rem\'>\\n        <li>\\n            <b>Label Set</b><br/>\\n            <span id=\'labels-name\'></span>\\n        </li>\\n        <li>\\n            <b>Labels</b><br/>\\n            <div id=\'label-list\'>\\n            </div>\\n            <div id=\'label-template\'>\\n                <div class=\'label-color\'></div>\\n                <span class=\'label-name\'>Label Name</name>\\n            </div>\\n        </li>\\n    </ul>\\n</div>\\n\x3c!-- End Labels --\x3e\\n",\n    "toolsLight": "<div id=\'tools-side\' style=\'display:block\'>\\n    <div id=\'tools-minimized\'>\\n        <div>\\n            <img style=\'width:28px;position:absolute;top:10px;left:10px\' src=\'/img/bars.svg\' />\\n        </div>\\n    </div>\\n    \\n    <div id=\'tools-maximized\' style=\'display:flex;flex-direction:column;height:100%\'>\\n        \x3c!-- tools hide/show, display left/right --\x3e\\n        <div id=\'headerBlock\' style=\'flex:0 1 28px;background:#333\'>\\n\\n            <div style=\'display:flex\'>\\n                <div style=\'flex:0 0 28px\'><div id=\'display-minimize\' title=\'Minimize toolbar\' class=\'a push noBorder\'><img class=\'icon\' src=\'/img/times-circle.svg\' /></div></div>\\n                <div style=\'flex:1 1 auto\'></div>\\n                <div style=\'flex:0 0 28px\'><div id=\'display-left\' title=\'Display to the left\' class=\'a push noBorder\'><img class=\'icon\' src=\'/img/caret-square-o-left.svg\' /></div></div>\\n                <div style=\'flex:0 0 28px\'><div id=\'display-right\' title=\'Display to the right\' class=\'a push noBorder\'><img class=\'icon\' src=\'/img/caret-square-o-right.svg\' /></div></div>\\n            </div>\\n\\n        </div>\\n\\n        \x3c!-- slider --\x3e\\n        <div id=\'sliderBlock\' style=\'flex:0 0 28px\'>\\n            <div style=\'display:flex\'>\\n                <div style=\'flex:0 0 28px\'>\\n                    <div id=\'prev\' class=\'a push\'>-</div>\\n                </div>\\n                <div style=\'flex:1 0 28px;display:flex\'>\\n                    <div style=\'flex:1;position:relative\'>\\n                        <div id=\'slice\' class=\'slider\' data-max=100 data-val=0 style=\'position:absolute;height:100%;margin-left:10px;width:calc(100% - 20px)\'>\\n                            <div class=\'track\' style=\'position:absolute;left:0;top:50%;width:100%;border-top:1px solid #fff;padding:0;display:inline-block\'></div>\\n                            <div class=\'thumb\' style=\'position:absolute;left:0;top:50%;transform:translate(-10px,-10px);border-radius:10px;padding:0;width:20px;height:20px;background:#fff;display:inline-block\'></div>\\n                        </div>\\n                    </div>\\n                </div>\\n                <div style=\'flex:0 0 28px\'>\\n                    <div id=\'next\' class=\'a push\'>+</div>\\n                </div>\\n            </div>\\n        </div>\\n\\n        \x3c!-- buttons --\x3e\\n        <div id=\'buttonsBlock\' style=\'flex:0 0 auto\'>\\n            <div style=\'display:flex;flex-wrap:wrap\'>\\n\\n                <div style=\'flex:1 0 150px;width:50px\'>\\n                    <div id=\'plane\' style=\'display:flex\' class=\'chose\'>\\n                        <div style=\'flex:1\'><div title=\'sag\' class=\'a pressed\'>Sag</div></div>\\n                        <div style=\'flex:1\'><div title=\'cor\' class=\'a\'>Cor</div></div>\\n                        <div style=\'flex:1\'><div title=\'axi\' class=\'a\'>Axi</div></div>\\n                    </div>\\n                </div>\\n\\n                <div style=\'flex:1 0 150px;width:50px\'>\\n                    <div style=\'display:flex\'>\\n                        <div style=\'flex:1\'><div id=\'fullscreen\' title=\'Full screen\' class=\'a toggle\'><img class=\'icon\' src=\'/img/fullscreen.svg\' /></div></div>\\n                        <div style=\'flex:1\'><div id=\'3drender\' title=\'3D render\' class=\'a push\'><img class=\'icon\' src=\'/img/3drender.svg\' /></div></div>\\n                        <div style=\'flex:1\'><div id=\'link\' title=\'Link\' class=\'a push\'><img class=\'icon\' src=\'/img/link.svg\' /></div></div>\\n                    </div>\\n                </div>\\n\\n                <div style=\'flex:1 0 150px;width:50px\'>\\n                    <div id=\'paintTool\' style=\'display:flex\' class=\'chose\'>\\n                        <div style=\'flex:1\'><div title=\'Show\' class=\'a pressed\'><img class=\'icon\' src=\'/img/show.svg\' /></div></div>\\n                        <div style=\'flex:1\'><div title=\'Adjust\' class=\'a\'><img class=\'icon\' src=\'/img/adjust.svg\' /></div></div>\\n                        <div style=\'flex:1\'><div title=\'Eyedrop\' class=\'a\'><img class=\'icon\' src=\'/img/eyedropper.svg\' /></div></div>\\n                    </div>\\n                </div>\\n\\n            </div>\\n        </div>\\n    </div>\\n\\n</div>\\n\\n\x3c!-- Loading indicator --\x3e\\n<div id=\'loadingIndicator\'>\\n    <p>Loading...</p>\\n    <div class=\'disc\'></div>\\n</div>\\n\x3c!-- End Loading indicator --\x3e\\n"\n  },\n  "css": {\n    "atlasMaker": "/* atlasMaker\\n-----------------------------------------------------------------------------*/\\n#atlasMaker {\\n    position: relative;\\n    background-color:#222;\\n    color:white;\\n    height:100%;\\n    margin:0px;\\n    font: 14px \\"Lucida Grande\\", \\"Lucida Sans Unicode\\", Helvetica, Arial, Verdana, sans-serif;\\n    -webkit-font-smoothing: antialiased;\\n    -moz-font-smoothing: antialiased;\\n}\\n#resizable {\\n    position: relative;\\n}\\n#text-layer {\\n    position: absolute;\\n    bottom:0px;\\n    right:0px;\\n    width:100%;\\n    height:100%;\\n    z-index:11;\\n    box-sizing: border-box;\\n    padding: 5px;\\n    pointer-events: none;\\n}\\n#vector-layer {\\n    position: absolute;\\n    bottom:0px;\\n    right:0px;\\n    width:100%;\\n    height:100%;\\n    z-index:11;\\n    pointer-events: none;\\n}\\n#canvas {\\n    width:100%;\\n    height:100%;\\n    background-color:black;\\n    cursor:none;\\n\\n    image-rendering:optimizeSpeed;             /* Legal fallback */\\n    image-rendering:-moz-crisp-edges;          /* Firefox        */\\n    image-rendering:-o-crisp-edges;            /* Opera          */\\n    image-rendering:-webkit-optimize-contrast; /* Safari         */\\n    image-rendering:optimize-contrast;         /* CSS3 Proposed  */\\n    image-rendering:crisp-edges;               /* CSS4 Proposed  */\\n    image-rendering:pixelated;                 /* CSS4 Proposed  */\\n    -ms-interpolation-mode:nearest-neighbor;   /* IE8+           */\\n}\\n#tools-side {\\n    width:100%;\\n    position:relative;\\n    pointer-events:none;\\n}\\n#tools-side #tools-minimized,\\n#tools-side #tools-maximized {\\n    pointer-events: all;\\n}\\n.atlasMaker-fullscreen #atlasMaker {\\n    position:fixed;\\n    top:0px;\\n    left:0px;\\n    /*width: calc( 100% - 240px );*/\\t/* width of tools */\\n    width: 100%;\\n    height:100%;\\n    z-index:10;\\n}\\n.atlasMaker-fullscreen #tools-side {\\n    position:fixed;\\n    top:0px;\\n    width:250px;\\n    height:100%;\\n    z-index:11;\\n}\\n.atlasMaker-fullscreen[data-toolbarDisplay=left] #tools-side {\\n    left: 0;\\n}\\n.atlasMaker-fullscreen[data-toolbarDisplay=right] #tools-side {\\n    right: 0;\\n}\\n.atlasMaker-fullscreen[data-toolbarDisplay=left] #text-layer {\\n    text-align: right;\\n}\\n.atlasMaker-fullscreen[data-toolbarDisplay=right] #text-layer {\\n    text-align: left;\\n}\\n\\n#tools-side #tools-minimized div {\\n    display:inline-block;\\n    width:48px;\\n    height:48px;\\n    border: thin solid #777;\\n    border-radius:48px;\\n    background-color:#333;\\n    position:fixed;\\n    margin: 10px;\\n    cursor: pointer;\\n}\\n.atlasMaker-fullscreen[data-toolbarDisplay=left] #tools-minimized div {\\n    top: 0;\\n    left: 0;\\n}\\n.atlasMaker-fullscreen[data-toolbarDisplay=right] #tools-minimized div {\\n    top: 0;\\n    right: 0;\\n}\\n\\n#headerBlock {\\n    display: none;\\n}\\n.atlasMaker-fullscreen #headerBlock {\\n    display: block;\\n}\\n\\n#log {\\n    -webkit-user-select:all;\\n    -moz-user-select:all;\\n    user-select:all;\\n}\\n#headerBlock {\\n    margin-bottom:5px;\\n}\\n#headerBlock .a {\\n    border:none;\\n}\\n\\n/* cursor\\n------------------------------- */\\n#atlasMaker .drawingcursor {\\n    border: 1px solid #F00;\\n    position: absolute;\\n    pointer-events:none;\\n}\\n#atlasMaker .hidepaintcursor {\\n    display: none;\\n}\\n\\n#cursor {\\n    pointer-events: none;\\n    position:absolute;\\n    top:200px;\\n    left:200px;\\n    border:thin solid white;\\n    color:red;\\n    z-index:20;\\n}\\n#finger {\\n    display:none;\\n}\\n.display-mode #finger {\\n    display:none;\\n}\\n.edit-mode #finger.touchDevice {\\n    position:absolute;\\n    top:200px;\\n    left:250px;\\n    width:40px;\\n    height:40px;\\n    border-style:solid;\\n    border-width:4px;\\n    border-radius:50%;\\n    display:inline;\\n}\\n#finger.move {\\n    border-color:yellow;\\n}\\n#finger.draw {\\n    border-color:green;\\n}\\n#finger.configure {\\n    border-color:orange;\\n}\\n\\n/* chat log\\n----------------------- */\\n#log {\\n    text-align:left;\\n    overflow: auto;\\n    background:#333;\\n}\\n#msg {\\n    color: black;\\n}\\n\\n/* Label set\\n------------------------ */\\n#labelset {\\n    display:none;\\n    overflow:scroll;\\n    position:fixed;\\n    top:0px;\\n    left:0px;\\n    width:100%;\\n    height:100%;\\n    text-align:left;\\n    background-color:#333;\\n    z-index:21;\\n}\\n.label-color {\\n    vertical-align:middle;\\n    margin:6px;\\n    display:inline-block;\\n    width:40px;\\n    height:30px;\\n    background-color:rgb(0,0,0);\\n}\\n#label-template {\\n    display:none;\\n}\\n#label-list {\\n    display:flex;\\n    flex-wrap:wrap;\\n     text-align:left;\\n }",\n    "loading-style": "/* Loading indicator */\\n@-webkit-keyframes loading {\\n    0% {left: 40%;}\\n    50% {left: 60%;}\\n    100% {left: 40%;}\\n}\\n#loadingIndicator {\\n    display:none;\\n    position:absolute;\\n    left:0;\\n    top:0;\\n    width:100%;\\n    height:100%;\\n    background:rgba(0,0,0,0.5);\\n}\\n#loadingIndicator .disc {\\n    position:absolute;\\n    left:50%;\\n    transform:translate( -50% , 0 );\\n    width:8px;\\n    height:8px;\\n    border-radius:8px;\\n    background:white;\\n    -webkit-animation-name: loading;\\n    -webkit-animation-duration: 1s;\\n    -webkit-animation-iteration-count: infinite;\\n    -webkit-animation-timing-function: ease-in-out;\\n    animation-name: loading;\\n    animation-duration: 1s;\\n    animation-iteration-count: infinite;\\n    animation-timing-function: ease-in-out;\\n}\\n",\n    "ui": "/* User interface widgets: buttons, sliders\\n-----------------------------------------------------------------------------*/\\n\\n* {\\n    box-sizing: border-box;\\n}\\n.a {\\n    border:thin solid #777;\\n    border-radius:3px;\\n    margin:1px;\\n    text-align:center;\\n    height: 24px;\\n    position: relative;\\n    color: white;\\n    user-select: none;\\n}\\n.a:hover {\\n    opacity:0.5;\\n    -webkit-user-select:none;\\n    -moz-user-select:none;\\n    user-select:none;\\n}\\n.label {\\n    color: white;\\n    user-select: none;\\n}\\n.pressed {\\n    background-color:#555 !important;\\n}\\n.icon {\\n    width:16px;\\n    vertical-align:middle;\\n    user-select: none;\\n}\\n\\n/* svg buttons\\n----------------------- */\\n.pushButton {\\n    border:1px solid #ddd;\\n    border-radius:6px;\\n    color:#ddd;\\n    text-align:center;\\n    -webkit-appearance:none;\\n    cursor: pointer;\\n}\\n.chose {\\n    border-radius:3px;\\n    background:#777;\\n    margin:2px;\\n}\\n.chose .a {\\n    border: none;\\n    border-radius:0px;\\n    height:22px;\\n    background: #222;\\n}\\nimg.button {\\n    width:0.9rem;\\n    height:0.9rem;\\n    margin:8px 2px;\\n    vertical-align:middle;\\n    cursor:pointer;\\n}\\nimg.button:hover {\\n    opacity:0.5;\\n}\\nimg.icon {\\n    width:1rem;\\n    height:1rem;\\n    position: absolute;\\n    top:50%;\\n    left:50%;\\n    transform:translate(-50%, -50%);\\n    cursor:pointer;\\n}\\n\\n.noBorder {\\n    border: none;\\n}\\n\\n.mui-select {\\n    border:none;\\n    background:none; /* no color, no decoration */\\n    color:white;\\n    -webkit-appearance: none;\\n    -moz-appearance: none;\\n    appearance: none;\\n    outline: none;\\n    cursor: pointer;\\n}\\n"\n  },\n  "svg": {\n    "3drender": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" standalone=\\"no\\"?>\\n<svg\\n   xmlns:dc=\\"http://purl.org/dc/elements/1.1/\\"\\n   xmlns:cc=\\"http://creativecommons.org/ns#\\"\\n   xmlns:rdf=\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\"\\n   xmlns:svg=\\"http://www.w3.org/2000/svg\\"\\n   xmlns=\\"http://www.w3.org/2000/svg\\"\\n   xmlns:sodipodi=\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\"\\n   xmlns:inkscape=\\"http://www.inkscape.org/namespaces/inkscape\\"\\n   id=\\"svg2\\"\\n   version=\\"1.1\\"\\n   inkscape:version=\\"0.91 r13725\\"\\n   sodipodi:docname=\\"3drender.svg\\"\\n   width=\\"1536\\"\\n   height=\\"1536\\">\\n  <metadata\\n     id=\\"metadata10\\">\\n    <rdf:RDF>\\n      <cc:Work\\n         rdf:about=\\"\\">\\n        <dc:format>image/svg+xml</dc:format>\\n        <dc:type\\n           rdf:resource=\\"http://purl.org/dc/dcmitype/StillImage\\" />\\n        <dc:title />\\n      </cc:Work>\\n    </rdf:RDF>\\n  </metadata>\\n  <defs\\n     id=\\"defs8\\" />\\n  <sodipodi:namedview\\n     pagecolor=\\"#ffffff\\"\\n     bordercolor=\\"#666666\\"\\n     borderopacity=\\"1\\"\\n     objecttolerance=\\"10\\"\\n     gridtolerance=\\"10\\"\\n     guidetolerance=\\"10\\"\\n     inkscape:pageopacity=\\"0\\"\\n     inkscape:pageshadow=\\"2\\"\\n     inkscape:window-width=\\"1672\\"\\n     inkscape:window-height=\\"1132\\"\\n     id=\\"namedview6\\"\\n     showgrid=\\"false\\"\\n     fit-margin-top=\\"0\\"\\n     fit-margin-left=\\"0\\"\\n     fit-margin-right=\\"0\\"\\n     fit-margin-bottom=\\"0\\"\\n     inkscape:zoom=\\"0.33312556\\"\\n     inkscape:cx=\\"674.23382\\"\\n     inkscape:cy=\\"852.37234\\"\\n     inkscape:window-x=\\"0\\"\\n     inkscape:window-y=\\"0\\"\\n     inkscape:window-maximized=\\"0\\"\\n     inkscape:current-layer=\\"svg2\\" />\\n  <path\\n     inkscape:connector-curvature=\\"0\\"\\n     id=\\"path4165\\"\\n     style=\\"fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none\\"\\n     d=\\"M 1415.7505,1148.2572 768.01905,1528.505 120.2443,1148.2572 l 0,-760.48132 647.77475,-380.290436 647.73145,380.290436 0,760.48132 z\\" />\\n  <path\\n     inkscape:connector-curvature=\\"0\\"\\n     id=\\"path4169\\"\\n     style=\\"fill:#000000;fill-opacity:0.69803898;fill-rule:nonzero;stroke:none\\"\\n     d=\\"m 1415.7505,1148.2572 0,-760.48132 -647.73145,380.24776 0,760.48136 647.73145,-380.2478 z\\" />\\n  <path\\n     inkscape:connector-curvature=\\"0\\"\\n     id=\\"path4171\\"\\n     style=\\"fill:#000000;fill-opacity:0.39607801;fill-rule:nonzero;stroke:none\\"\\n     d=\\"m 120.2443,1148.2572 0,-760.48132 647.77475,380.24776 0,760.48136 -647.77475,-380.2478 z\\" />\\n  <g\\n     transform=\\"matrix(14.227102,0,0,14.227102,-1349.2584,-231.09805)\\"\\n     id=\\"g4177\\">\\n    <path\\n       inkscape:connector-curvature=\\"0\\"\\n       id=\\"path4179\\"\\n       style=\\"fill:none;stroke:#ffffff;stroke-width:1.60000002;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\\"\\n       d=\\"M 194.348,43.5 148.82,70.227 103.289,43.5\\" />\\n  </g>\\n</svg>\\n",\n    "adjust": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" standalone=\\"no\\"?>\\n<svg\\n   xmlns:dc=\\"http://purl.org/dc/elements/1.1/\\"\\n   xmlns:cc=\\"http://creativecommons.org/ns#\\"\\n   xmlns:rdf=\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\"\\n   xmlns:svg=\\"http://www.w3.org/2000/svg\\"\\n   xmlns=\\"http://www.w3.org/2000/svg\\"\\n   xmlns:sodipodi=\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\"\\n   xmlns:inkscape=\\"http://www.inkscape.org/namespaces/inkscape\\"\\n   width=\\"1792\\"\\n   height=\\"1792\\"\\n   viewBox=\\"0 0 1792 1792\\"\\n   id=\\"svg2\\"\\n   version=\\"1.1\\"\\n   inkscape:version=\\"0.91 r13725\\"\\n   sodipodi:docname=\\"adjust_.svg\\">\\n  <metadata\\n     id=\\"metadata10\\">\\n    <rdf:RDF>\\n      <cc:Work\\n         rdf:about=\\"\\">\\n        <dc:format>image/svg+xml</dc:format>\\n        <dc:type\\n           rdf:resource=\\"http://purl.org/dc/dcmitype/StillImage\\" />\\n        <dc:title></dc:title>\\n      </cc:Work>\\n    </rdf:RDF>\\n  </metadata>\\n  <defs\\n     id=\\"defs8\\" />\\n  <sodipodi:namedview\\n     pagecolor=\\"#ffffff\\"\\n     bordercolor=\\"#666666\\"\\n     borderopacity=\\"1\\"\\n     objecttolerance=\\"10\\"\\n     gridtolerance=\\"10\\"\\n     guidetolerance=\\"10\\"\\n     inkscape:pageopacity=\\"0\\"\\n     inkscape:pageshadow=\\"2\\"\\n     inkscape:window-width=\\"1309\\"\\n     inkscape:window-height=\\"880\\"\\n     id=\\"namedview6\\"\\n     showgrid=\\"false\\"\\n     inkscape:zoom=\\"0.12695344\\"\\n     inkscape:cx=\\"411.42635\\"\\n     inkscape:cy=\\"896\\"\\n     inkscape:window-x=\\"71\\"\\n     inkscape:window-y=\\"108\\"\\n     inkscape:window-maximized=\\"0\\"\\n     inkscape:current-layer=\\"svg2\\" />\\n  <g\\n     id=\\"g4154\\">\\n    <path\\n       style=\\"fill:#ffffff;fill-opacity:1\\"\\n       id=\\"path4\\"\\n       d=\\"m 904.35472,1528.2773 -7.8769,-1261.09396 c -148.79498,0 -227.67351,27.02518 -324.00196,83.18399 -95.00724,55.38855 -174.26188,142.18467 -228.83188,237.66442 -47.07633,82.36826 -74.06588,179.31169 -76.46065,274.15354 -2.84006,112.47682 21.26033,229.98731 74.15355,329.29191 53.09547,99.6843 135.9322,188.0924 232.77034,246.217 97.87177,58.745 231.58083,90.5831 330.2475,90.5831 z M 1664,896 c 0,139.3333 -34.3333,267.8333 -103,385.5 -68.6667,117.6667 -161.8333,210.8333 -279.5,279.5 -117.6667,68.6667 -246.1667,103 -385.5,103 -139.33333,0 -267.83333,-34.3333 -385.5,-103 C 392.83333,1492.3333 299.66667,1399.1667 231,1281.5 162.33333,1163.8333 128,1035.3333 128,896 128,756.66667 162.33333,628.16667 231,510.5 299.66667,392.83333 392.83333,299.66667 510.5,231 628.16667,162.33333 756.66667,128 896,128 c 139.3333,0 267.8333,34.33333 385.5,103 117.6667,68.66667 210.8333,161.83333 279.5,279.5 68.6667,117.66667 103,246.16667 103,385.5 z\\"\\n       inkscape:connector-curvature=\\"0\\"\\n       sodipodi:nodetypes=\\"ccaaaaacsssssssssssss\\" />\\n  </g>\\n</svg>\\n",\n    "alpha": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" standalone=\\"no\\"?>\\n<svg\\n   xmlns:dc=\\"http://purl.org/dc/elements/1.1/\\"\\n   xmlns:cc=\\"http://creativecommons.org/ns#\\"\\n   xmlns:rdf=\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\"\\n   xmlns:svg=\\"http://www.w3.org/2000/svg\\"\\n   xmlns=\\"http://www.w3.org/2000/svg\\"\\n   xmlns:xlink=\\"http://www.w3.org/1999/xlink\\"\\n   xmlns:sodipodi=\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\"\\n   xmlns:inkscape=\\"http://www.inkscape.org/namespaces/inkscape\\"\\n   id=\\"svg2\\"\\n   version=\\"1.1\\"\\n   inkscape:version=\\"0.91 r13725\\"\\n   sodipodi:docname=\\"alpha3.svg\\"\\n   width=\\"1536\\"\\n   height=\\"1536\\">\\n  <metadata\\n     id=\\"metadata10\\">\\n    <rdf:RDF>\\n      <cc:Work\\n         rdf:about=\\"\\">\\n        <dc:format>image/svg+xml</dc:format>\\n        <dc:type\\n           rdf:resource=\\"http://purl.org/dc/dcmitype/StillImage\\" />\\n        <dc:title />\\n      </cc:Work>\\n    </rdf:RDF>\\n  </metadata>\\n  <defs\\n     id=\\"defs8\\">\\n    <linearGradient\\n       inkscape:collect=\\"always\\"\\n       id=\\"linearGradient4170\\">\\n      <stop\\n         style=\\"stop-color:#ffffff;stop-opacity:1;\\"\\n         offset=\\"0\\"\\n         id=\\"stop4172\\" />\\n      <stop\\n         style=\\"stop-color:#ffffff;stop-opacity:0;\\"\\n         offset=\\"1\\"\\n         id=\\"stop4174\\" />\\n    </linearGradient>\\n    <linearGradient\\n       inkscape:collect=\\"always\\"\\n       xlink:href=\\"#linearGradient4170\\"\\n       id=\\"linearGradient4176\\"\\n       x1=\\"-599.44781\\"\\n       y1=\\"757.00183\\"\\n       x2=\\"1171.5452\\"\\n       y2=\\"762.83765\\"\\n       gradientUnits=\\"userSpaceOnUse\\"\\n       gradientTransform=\\"matrix(0.8707121,0,0,0.87421598,-1443.0979,-1443.9413)\\" />\\n  </defs>\\n  <sodipodi:namedview\\n     pagecolor=\\"#ffffff\\"\\n     bordercolor=\\"#666666\\"\\n     borderopacity=\\"1\\"\\n     objecttolerance=\\"10\\"\\n     gridtolerance=\\"10\\"\\n     guidetolerance=\\"10\\"\\n     inkscape:pageopacity=\\"0\\"\\n     inkscape:pageshadow=\\"2\\"\\n     inkscape:window-width=\\"1672\\"\\n     inkscape:window-height=\\"1132\\"\\n     id=\\"namedview6\\"\\n     showgrid=\\"false\\"\\n     fit-margin-top=\\"0\\"\\n     fit-margin-left=\\"0\\"\\n     fit-margin-right=\\"0\\"\\n     fit-margin-bottom=\\"0\\"\\n     inkscape:zoom=\\"0.16656278\\"\\n     inkscape:cx=\\"-473.21243\\"\\n     inkscape:cy=\\"852.37234\\"\\n     inkscape:window-x=\\"149\\"\\n     inkscape:window-y=\\"209\\"\\n     inkscape:window-maximized=\\"0\\"\\n     inkscape:current-layer=\\"svg2\\" />\\n  <ellipse\\n     style=\\"opacity:1;fill:url(#linearGradient4176);fill-opacity:1;fill-rule:nonzero;stroke:#ffffff;stroke-width:90.748;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:3.27590013;stroke-opacity:1\\"\\n     id=\\"path4158\\"\\n     cy=\\"-769.0257\\"\\n     cx=\\"-772.66711\\"\\n     transform=\\"scale(-1,-1)\\"\\n     rx=\\"654.74829\\"\\n     ry=\\"657.38306\\" />\\n</svg>\\n",\n    "bars": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" standalone=\\"no\\"?>\\n<svg\\n   xmlns:dc=\\"http://purl.org/dc/elements/1.1/\\"\\n   xmlns:cc=\\"http://creativecommons.org/ns#\\"\\n   xmlns:rdf=\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\"\\n   xmlns:svg=\\"http://www.w3.org/2000/svg\\"\\n   xmlns=\\"http://www.w3.org/2000/svg\\"\\n   xmlns:sodipodi=\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\"\\n   xmlns:inkscape=\\"http://www.inkscape.org/namespaces/inkscape\\"\\n   width=\\"1792\\"\\n   height=\\"1792\\"\\n   viewBox=\\"0 0 1792 1792\\"\\n   id=\\"svg2\\"\\n   version=\\"1.1\\"\\n   inkscape:version=\\"0.91 r13725\\"\\n   sodipodi:docname=\\"bars.svg\\">\\n  <metadata\\n     id=\\"metadata10\\">\\n    <rdf:RDF>\\n      <cc:Work\\n         rdf:about=\\"\\">\\n        <dc:format>image/svg+xml</dc:format>\\n        <dc:type\\n           rdf:resource=\\"http://purl.org/dc/dcmitype/StillImage\\" />\\n        <dc:title />\\n      </cc:Work>\\n    </rdf:RDF>\\n  </metadata>\\n  <defs\\n     id=\\"defs8\\" />\\n  <sodipodi:namedview\\n     pagecolor=\\"#ffffff\\"\\n     bordercolor=\\"#666666\\"\\n     borderopacity=\\"1\\"\\n     objecttolerance=\\"10\\"\\n     gridtolerance=\\"10\\"\\n     guidetolerance=\\"10\\"\\n     inkscape:pageopacity=\\"0\\"\\n     inkscape:pageshadow=\\"2\\"\\n     inkscape:window-width=\\"1367\\"\\n     inkscape:window-height=\\"912\\"\\n     id=\\"namedview6\\"\\n     showgrid=\\"false\\"\\n     inkscape:zoom=\\"0.2655473\\"\\n     inkscape:cx=\\"203.46991\\"\\n     inkscape:cy=\\"896\\"\\n     inkscape:window-x=\\"4\\"\\n     inkscape:window-y=\\"23\\"\\n     inkscape:window-maximized=\\"0\\"\\n     inkscape:current-layer=\\"svg2\\" />\\n  <path\\n     style=\\"fill:#ffffff;fill-opacity:1\\"\\n     d=\\"m 257.82663,514.45448 q 0,-11.49079 27.06538,-19.8879 27.06538,-8.39711 64.10223,-8.39711 l 1094.01156,0 q 37.0368,0 64.1022,8.3971 27.0654,8.39711 27.0654,19.8879 l 0,56.57001 q 0,11.49079 -27.0654,19.8879 -27.0654,8.39711 -64.1022,8.39711 l -1094.01156,0 q -37.03685,0 -64.10223,-8.39711 -27.06538,-8.39711 -27.06538,-19.8879 l 0,-56.57001 z\\"\\n     id=\\"path4-5\\"\\n     inkscape:connector-curvature=\\"0\\" />\\n  <path\\n     style=\\"fill:#ffffff;fill-opacity:1\\"\\n     d=\\"m 257.82663,1228.5074 q 0,-11.4908 27.06538,-19.8879 27.06538,-8.3971 64.10223,-8.3971 l 1094.01156,0 q 37.0368,0 64.1022,8.3971 27.0654,8.3971 27.0654,19.8879 l 0,56.57 q 0,11.4908 -27.0654,19.8879 -27.0654,8.3971 -64.1022,8.3971 l -1094.01155,0 q -37.03684,0 -64.10223,-8.3971 -27.06538,-8.3971 -27.06538,-19.8879 l 0,-56.57 z\\"\\n     id=\\"path4-5-8\\"\\n     inkscape:connector-curvature=\\"0\\" />\\n  <path\\n     style=\\"fill:#ffffff;fill-opacity:1\\"\\n     d=\\"m 257.82666,871.48099 q 0,-11.49079 27.06538,-19.88789 27.0654,-8.39712 64.10223,-8.39712 l 1094.01143,0 q 37.0367,0 64.1022,8.39711 27.0654,8.39711 27.0654,19.88789 l 0,56.57002 q 0,11.4908 -27.0654,19.8879 -27.0655,8.3971 -64.1022,8.3971 l -1094.01142,0 q -37.03684,0 -64.10224,-8.3971 -27.06538,-8.3971 -27.06538,-19.8879 l 0,-56.57002 z\\"\\n     id=\\"path4-5-7\\"\\n     inkscape:connector-curvature=\\"0\\" />\\n</svg>\\n",\n    "caret-square-o-left": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" standalone=\\"no\\"?>\\n<svg\\n   xmlns:dc=\\"http://purl.org/dc/elements/1.1/\\"\\n   xmlns:cc=\\"http://creativecommons.org/ns#\\"\\n   xmlns:rdf=\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\"\\n   xmlns:svg=\\"http://www.w3.org/2000/svg\\"\\n   xmlns=\\"http://www.w3.org/2000/svg\\"\\n   xmlns:sodipodi=\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\"\\n   xmlns:inkscape=\\"http://www.inkscape.org/namespaces/inkscape\\"\\n   width=\\"1792\\"\\n   height=\\"1792\\"\\n   viewBox=\\"0 0 1792 1792\\"\\n   id=\\"svg2\\"\\n   version=\\"1.1\\"\\n   inkscape:version=\\"0.91 r13725\\"\\n   sodipodi:docname=\\"caret-square-o-left.svg\\">\\n  <metadata\\n     id=\\"metadata10\\">\\n    <rdf:RDF>\\n      <cc:Work\\n         rdf:about=\\"\\">\\n        <dc:format>image/svg+xml</dc:format>\\n        <dc:type\\n           rdf:resource=\\"http://purl.org/dc/dcmitype/StillImage\\" />\\n        <dc:title></dc:title>\\n      </cc:Work>\\n    </rdf:RDF>\\n  </metadata>\\n  <defs\\n     id=\\"defs8\\" />\\n  <sodipodi:namedview\\n     pagecolor=\\"#ffffff\\"\\n     bordercolor=\\"#666666\\"\\n     borderopacity=\\"1\\"\\n     objecttolerance=\\"10\\"\\n     gridtolerance=\\"10\\"\\n     guidetolerance=\\"10\\"\\n     inkscape:pageopacity=\\"0\\"\\n     inkscape:pageshadow=\\"2\\"\\n     inkscape:window-width=\\"1785\\"\\n     inkscape:window-height=\\"1082\\"\\n     id=\\"namedview6\\"\\n     showgrid=\\"false\\"\\n     inkscape:zoom=\\"0.37811279\\"\\n     inkscape:cx=\\"1211.0835\\"\\n     inkscape:cy=\\"922.19364\\"\\n     inkscape:window-x=\\"4\\"\\n     inkscape:window-y=\\"46\\"\\n     inkscape:window-maximized=\\"0\\"\\n     inkscape:current-layer=\\"svg2\\" />\\n  <g\\n     id=\\"g4210\\"\\n     transform=\\"matrix(0.93801453,0,0,0.87258542,55.538981,114.16346)\\">\\n    <path\\n       sodipodi:nodetypes=\\"ssssssssssssssssssssssssss\\"\\n       inkscape:connector-curvature=\\"0\\"\\n       style=\\"fill:#ffffff;fill-opacity:1\\"\\n       id=\\"path4\\"\\n       d=\\"m 1521.4994,1516.4129 -3.8342,-1245.79429 c -0.027,-8.66663 -3.1667,-16.16667 -9.5,-22.5 -6.3333,-6.33333 -13.8334,-9.47618 -22.5,-9.5 l -802.92142,-2.20708 c -8.66663,-0.0238 -18.05957,1.72753 -24.3929,8.06086 -6.33333,6.33333 -7.58076,4.20013 -7.6071,23.93914 l -1.666,1248.77587 c -0.0116,8.6668 3.16667,16.1667 9.5,22.5 6.33333,6.3333 13.83332,9.5083 22.5,9.5 l 808.42162,-0.7745 c 8.6666,-0.01 16.1667,-3.1667 22.5,-9.5 6.3333,-6.3333 9.5267,-13.8334 9.5,-22.5 z M 1664,416 l 0,960 c 0,79.3333 -28.1667,147.1667 -84.5,203.5 -56.3333,56.3333 -124.1667,84.5 -203.5,84.5 l -960,0 c -79.33333,0 -147.16667,-28.1667 -203.5,-84.5 C 156.16667,1523.1667 128,1455.3333 128,1376 l 0,-960 C 128,336.66667 156.16667,268.83333 212.5,212.5 268.83333,156.16667 336.66667,128 416,128 l 960,0 c 79.3333,0 147.1667,28.16667 203.5,84.5 56.3333,56.33333 84.5,124.16667 84.5,203.5 z\\" />\\n  </g>\\n</svg>\\n",\n    "caret-square-o-right": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" standalone=\\"no\\"?>\\n<svg\\n   xmlns:dc=\\"http://purl.org/dc/elements/1.1/\\"\\n   xmlns:cc=\\"http://creativecommons.org/ns#\\"\\n   xmlns:rdf=\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\"\\n   xmlns:svg=\\"http://www.w3.org/2000/svg\\"\\n   xmlns=\\"http://www.w3.org/2000/svg\\"\\n   xmlns:sodipodi=\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\"\\n   xmlns:inkscape=\\"http://www.inkscape.org/namespaces/inkscape\\"\\n   width=\\"1792\\"\\n   height=\\"1792\\"\\n   viewBox=\\"0 0 1792 1792\\"\\n   id=\\"svg2\\"\\n   version=\\"1.1\\"\\n   inkscape:version=\\"0.91 r13725\\"\\n   sodipodi:docname=\\"caret-square-o-right.svg\\">\\n  <metadata\\n     id=\\"metadata10\\">\\n    <rdf:RDF>\\n      <cc:Work\\n         rdf:about=\\"\\">\\n        <dc:format>image/svg+xml</dc:format>\\n        <dc:type\\n           rdf:resource=\\"http://purl.org/dc/dcmitype/StillImage\\" />\\n        <dc:title></dc:title>\\n      </cc:Work>\\n    </rdf:RDF>\\n  </metadata>\\n  <defs\\n     id=\\"defs8\\" />\\n  <sodipodi:namedview\\n     pagecolor=\\"#ffffff\\"\\n     bordercolor=\\"#666666\\"\\n     borderopacity=\\"1\\"\\n     objecttolerance=\\"10\\"\\n     gridtolerance=\\"10\\"\\n     guidetolerance=\\"10\\"\\n     inkscape:pageopacity=\\"0\\"\\n     inkscape:pageshadow=\\"2\\"\\n     inkscape:window-width=\\"1785\\"\\n     inkscape:window-height=\\"1082\\"\\n     id=\\"namedview6\\"\\n     showgrid=\\"false\\"\\n     inkscape:zoom=\\"0.37811279\\"\\n     inkscape:cx=\\"1211.0835\\"\\n     inkscape:cy=\\"922.19364\\"\\n     inkscape:window-x=\\"4\\"\\n     inkscape:window-y=\\"46\\"\\n     inkscape:window-maximized=\\"0\\"\\n     inkscape:current-layer=\\"svg2\\" />\\n  <g\\n     id=\\"g4210\\"\\n     transform=\\"matrix(-0.93801453,0,0,-0.87258542,1736.461,1677.8365)\\">\\n    <path\\n       sodipodi:nodetypes=\\"ssssssssssssssssssssssssss\\"\\n       inkscape:connector-curvature=\\"0\\"\\n       style=\\"fill:#ffffff;fill-opacity:1\\"\\n       id=\\"path4\\"\\n       d=\\"m 1521.4994,1516.4129 -3.8342,-1245.79429 c -0.027,-8.66663 -3.1667,-16.16667 -9.5,-22.5 -6.3333,-6.33333 -13.8334,-9.47618 -22.5,-9.5 l -802.92142,-2.20708 c -8.66663,-0.0238 -18.05957,1.72753 -24.3929,8.06086 -6.33333,6.33333 -7.58076,4.20013 -7.6071,23.93914 l -1.666,1248.77587 c -0.0116,8.6668 3.16667,16.1667 9.5,22.5 6.33333,6.3333 13.83332,9.5083 22.5,9.5 l 808.42162,-0.7745 c 8.6666,-0.01 16.1667,-3.1667 22.5,-9.5 6.3333,-6.3333 9.5267,-13.8334 9.5,-22.5 z M 1664,416 l 0,960 c 0,79.3333 -28.1667,147.1667 -84.5,203.5 -56.3333,56.3333 -124.1667,84.5 -203.5,84.5 l -960,0 c -79.33333,0 -147.16667,-28.1667 -203.5,-84.5 C 156.16667,1523.1667 128,1455.3333 128,1376 l 0,-960 C 128,336.66667 156.16667,268.83333 212.5,212.5 268.83333,156.16667 336.66667,128 416,128 l 960,0 c 79.3333,0 147.1667,28.16667 203.5,84.5 56.3333,56.33333 84.5,124.16667 84.5,203.5 z\\" />\\n  </g>\\n</svg>\\n",\n    "chat": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" standalone=\\"no\\"?>\\n\x3c!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  --\x3e\\n\\n<svg\\n   xmlns:dc=\\"http://purl.org/dc/elements/1.1/\\"\\n   xmlns:cc=\\"http://creativecommons.org/ns#\\"\\n   xmlns:rdf=\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\"\\n   xmlns:svg=\\"http://www.w3.org/2000/svg\\"\\n   xmlns=\\"http://www.w3.org/2000/svg\\"\\n   xmlns:sodipodi=\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\"\\n   xmlns:inkscape=\\"http://www.inkscape.org/namespaces/inkscape\\"\\n   version=\\"1.1\\"\\n   id=\\"Capa_1\\"\\n   x=\\"0px\\"\\n   y=\\"0px\\"\\n   width=\\"511.626px\\"\\n   height=\\"511.626px\\"\\n   viewBox=\\"0 0 511.626 511.626\\"\\n   style=\\"enable-background:new 0 0 511.626 511.626;\\"\\n   xml:space=\\"preserve\\"\\n   inkscape:version=\\"0.91 r13725\\"\\n   sodipodi:docname=\\"chat.svg\\"><metadata\\n     id=\\"metadata45\\"><rdf:RDF><cc:Work\\n         rdf:about=\\"\\"><dc:format>image/svg+xml</dc:format><dc:type\\n           rdf:resource=\\"http://purl.org/dc/dcmitype/StillImage\\" /></cc:Work></rdf:RDF></metadata><defs\\n     id=\\"defs43\\" /><sodipodi:namedview\\n     pagecolor=\\"#ffffff\\"\\n     bordercolor=\\"#666666\\"\\n     borderopacity=\\"1\\"\\n     objecttolerance=\\"10\\"\\n     gridtolerance=\\"10\\"\\n     guidetolerance=\\"10\\"\\n     inkscape:pageopacity=\\"0\\"\\n     inkscape:pageshadow=\\"2\\"\\n     inkscape:window-width=\\"1315\\"\\n     inkscape:window-height=\\"852\\"\\n     id=\\"namedview41\\"\\n     showgrid=\\"false\\"\\n     inkscape:zoom=\\"0.46127444\\"\\n     inkscape:cx=\\"255.813\\"\\n     inkscape:cy=\\"255.813\\"\\n     inkscape:window-x=\\"0\\"\\n     inkscape:window-y=\\"0\\"\\n     inkscape:window-maximized=\\"0\\"\\n     inkscape:current-layer=\\"Capa_1\\" /><g\\n     id=\\"g3\\"\\n     style=\\"fill:#ffffff;fill-opacity:1\\"><g\\n       id=\\"g5\\"\\n       style=\\"fill:#ffffff;fill-opacity:1\\"><path\\n         d=\\"M301.927,327.605c30.926-13.038,55.34-30.785,73.23-53.248c17.888-22.458,26.833-46.915,26.833-73.372    c0-26.458-8.945-50.917-26.84-73.376c-17.888-22.459-42.298-40.208-73.228-53.249c-30.93-13.039-64.571-19.556-100.928-19.556    c-36.354,0-69.995,6.521-100.927,19.556c-30.929,13.04-55.34,30.789-73.229,53.249C8.947,150.072,0,174.527,0,200.986    c0,22.648,6.767,43.975,20.28,63.96c13.512,19.981,32.071,36.829,55.671,50.531c-1.902,4.572-3.853,8.754-5.852,12.566    c-2,3.806-4.377,7.467-7.139,10.991c-2.76,3.525-4.899,6.283-6.423,8.275c-1.523,1.998-3.997,4.812-7.425,8.422    c-3.427,3.617-5.617,5.996-6.567,7.135c0-0.191-0.381,0.24-1.143,1.287c-0.763,1.047-1.191,1.52-1.285,1.431    c-0.096-0.103-0.477,0.373-1.143,1.42c-0.666,1.048-1,1.571-1,1.571l-0.715,1.423c-0.282,0.575-0.476,1.137-0.57,1.712    c-0.096,0.567-0.144,1.19-0.144,1.854s0.094,1.28,0.288,1.854c0.381,2.471,1.475,4.466,3.283,5.996    c1.807,1.52,3.756,2.279,5.852,2.279h0.857c9.515-1.332,17.701-2.854,24.552-4.569c29.312-7.61,55.771-19.797,79.372-36.545    c17.129,3.046,33.879,4.568,50.247,4.568C237.353,347.16,270.998,340.645,301.927,327.605z\\"\\n         id=\\"path7\\"\\n         style=\\"fill:#ffffff;fill-opacity:1\\" /><path\\n         d=\\"M491.354,338.166c13.518-19.889,20.272-41.247,20.272-64.09c0-23.414-7.146-45.316-21.416-65.68    c-14.277-20.362-33.694-37.305-58.245-50.819c4.374,14.274,6.563,28.739,6.563,43.398c0,25.503-6.368,49.676-19.129,72.519    c-12.752,22.836-31.025,43.01-54.816,60.524c-22.08,15.988-47.205,28.261-75.377,36.829    c-28.164,8.562-57.573,12.848-88.218,12.848c-5.708,0-14.084-0.377-25.122-1.137c38.256,25.119,83.177,37.685,134.756,37.685    c16.371,0,33.119-1.526,50.251-4.571c23.6,16.755,50.06,28.931,79.37,36.549c6.852,1.718,15.037,3.237,24.554,4.568    c2.283,0.191,4.381-0.476,6.283-1.999c1.903-1.522,3.142-3.61,3.71-6.272c-0.089-1.143,0-1.77,0.287-1.861    c0.281-0.09,0.233-0.712-0.144-1.852c-0.376-1.144-0.568-1.715-0.568-1.715l-0.712-1.424c-0.198-0.376-0.52-0.903-0.999-1.567    c-0.476-0.66-0.855-1.143-1.143-1.427c-0.28-0.284-0.705-0.763-1.28-1.424c-0.568-0.66-0.951-1.092-1.143-1.283    c-0.951-1.143-3.139-3.521-6.564-7.139c-3.429-3.613-5.899-6.42-7.422-8.418c-1.523-1.999-3.665-4.757-6.424-8.282    c-2.758-3.518-5.14-7.183-7.139-10.991c-1.998-3.806-3.949-7.995-5.852-12.56C459.289,374.859,477.843,358.062,491.354,338.166z\\"\\n         id=\\"path9\\"\\n         style=\\"fill:#ffffff;fill-opacity:1\\" /></g></g><g\\n     id=\\"g11\\" /><g\\n     id=\\"g13\\" /><g\\n     id=\\"g15\\" /><g\\n     id=\\"g17\\" /><g\\n     id=\\"g19\\" /><g\\n     id=\\"g21\\" /><g\\n     id=\\"g23\\" /><g\\n     id=\\"g25\\" /><g\\n     id=\\"g27\\" /><g\\n     id=\\"g29\\" /><g\\n     id=\\"g31\\" /><g\\n     id=\\"g33\\" /><g\\n     id=\\"g35\\" /><g\\n     id=\\"g37\\" /><g\\n     id=\\"g39\\" /></svg>",\n    "download": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" standalone=\\"no\\"?>\\n\x3c!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  --\x3e\\n\\n<svg\\n   xmlns:dc=\\"http://purl.org/dc/elements/1.1/\\"\\n   xmlns:cc=\\"http://creativecommons.org/ns#\\"\\n   xmlns:rdf=\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\"\\n   xmlns:svg=\\"http://www.w3.org/2000/svg\\"\\n   xmlns=\\"http://www.w3.org/2000/svg\\"\\n   xmlns:sodipodi=\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\"\\n   xmlns:inkscape=\\"http://www.inkscape.org/namespaces/inkscape\\"\\n   version=\\"1.1\\"\\n   id=\\"Capa_1\\"\\n   x=\\"0px\\"\\n   y=\\"0px\\"\\n   width=\\"438.533px\\"\\n   height=\\"438.533px\\"\\n   viewBox=\\"0 0 438.533 438.533\\"\\n   style=\\"enable-background:new 0 0 438.533 438.533;\\"\\n   xml:space=\\"preserve\\"\\n   inkscape:version=\\"0.91 r13725\\"\\n   sodipodi:docname=\\"download.svg\\"><metadata\\n     id=\\"metadata45\\"><rdf:RDF><cc:Work\\n         rdf:about=\\"\\"><dc:format>image/svg+xml</dc:format><dc:type\\n           rdf:resource=\\"http://purl.org/dc/dcmitype/StillImage\\" /><dc:title /></cc:Work></rdf:RDF></metadata><defs\\n     id=\\"defs43\\" /><sodipodi:namedview\\n     pagecolor=\\"#ffffff\\"\\n     bordercolor=\\"#666666\\"\\n     borderopacity=\\"1\\"\\n     objecttolerance=\\"10\\"\\n     gridtolerance=\\"10\\"\\n     guidetolerance=\\"10\\"\\n     inkscape:pageopacity=\\"0\\"\\n     inkscape:pageshadow=\\"2\\"\\n     inkscape:window-width=\\"1520\\"\\n     inkscape:window-height=\\"931\\"\\n     id=\\"namedview41\\"\\n     showgrid=\\"false\\"\\n     inkscape:zoom=\\"0.38053511\\"\\n     inkscape:cx=\\"19.143651\\"\\n     inkscape:cy=\\"-201.19405\\"\\n     inkscape:window-x=\\"0\\"\\n     inkscape:window-y=\\"0\\"\\n     inkscape:window-maximized=\\"0\\"\\n     inkscape:current-layer=\\"Capa_1\\" /><g\\n     id=\\"g11\\" /><g\\n     id=\\"g13\\" /><g\\n     id=\\"g15\\" /><g\\n     id=\\"g17\\" /><g\\n     id=\\"g19\\" /><g\\n     id=\\"g21\\" /><g\\n     id=\\"g23\\" /><g\\n     id=\\"g25\\" /><g\\n     id=\\"g27\\" /><g\\n     id=\\"g29\\" /><g\\n     id=\\"g31\\" /><g\\n     id=\\"g33\\" /><g\\n     id=\\"g35\\" /><g\\n     id=\\"g37\\" /><g\\n     id=\\"g39\\" /><path\\n     d=\\"m 312.24353,148.5142 -55.71476,0 0,-105.614341 c 0,-2.80155 -0.87617,-5.09976 -2.61533,-6.90091 -1.73202,-1.7959 -3.95908,-2.69858 -6.66486,-2.69858 l -55.7249,0 c -2.70783,0 -4.93385,0.90268 -6.67504,2.69858 -1.74219,1.8022 -2.61227,4.09936 -2.61227,6.90091 l 0,105.610141 -55.72084,0 c -4.25487,0 -7.15784,2.00186 -8.70692,5.99928 -1.54907,3.80512 -0.86805,7.30024 2.03188,10.50427 L 212.70653,261.02 c 2.13046,1.798 4.35345,2.69753 6.67502,2.69753 2.31854,0 4.54456,-0.89953 6.67706,-2.69753 l 92.57534,-95.70381 c 1.93329,-2.39908 2.8979,-4.80867 2.8979,-7.2004 0,-2.79736 -0.86907,-5.09976 -2.61534,-6.90407 -1.73711,-1.79905 -3.96313,-2.69752 -6.67298,-2.69752 z\\"\\n     id=\\"path9\\"\\n     inkscape:connector-curvature=\\"0\\"\\n     style=\\"fill:#ffffff;fill-opacity:1\\" /><path\\n     style=\\"opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:35;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:3.27590013;stroke-opacity:1\\"\\n     d=\\"m 36.23525,305.81445 0,98.48438 366.0625,0 0,-98.48438 -42.73828,0 0,55.7461 -280.58594,0 0,-55.7461 z\\"\\n     id=\\"rect4150\\"\\n     inkscape:connector-curvature=\\"0\\"\\n     sodipodi:nodetypes=\\"ccccccccc\\" /></svg>",\n    "erase": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" standalone=\\"no\\"?>\\n<svg\\n   xmlns:dc=\\"http://purl.org/dc/elements/1.1/\\"\\n   xmlns:cc=\\"http://creativecommons.org/ns#\\"\\n   xmlns:rdf=\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\"\\n   xmlns:svg=\\"http://www.w3.org/2000/svg\\"\\n   xmlns=\\"http://www.w3.org/2000/svg\\"\\n   xmlns:sodipodi=\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\"\\n   xmlns:inkscape=\\"http://www.inkscape.org/namespaces/inkscape\\"\\n   id=\\"svg2\\"\\n   version=\\"1.1\\"\\n   inkscape:version=\\"0.91 r13725\\"\\n   sodipodi:docname=\\"fa-erase.svg\\"\\n   width=\\"1919.9512\\"\\n   height=\\"1919.9512\\">\\n  <metadata\\n     id=\\"metadata10\\">\\n    <rdf:RDF>\\n      <cc:Work\\n         rdf:about=\\"\\">\\n        <dc:format>image/svg+xml</dc:format>\\n        <dc:type\\n           rdf:resource=\\"http://purl.org/dc/dcmitype/StillImage\\" />\\n        <dc:title></dc:title>\\n      </cc:Work>\\n    </rdf:RDF>\\n  </metadata>\\n  <defs\\n     id=\\"defs8\\" />\\n  <sodipodi:namedview\\n     pagecolor=\\"#ffffff\\"\\n     bordercolor=\\"#666666\\"\\n     borderopacity=\\"1\\"\\n     objecttolerance=\\"10\\"\\n     gridtolerance=\\"10\\"\\n     guidetolerance=\\"10\\"\\n     inkscape:pageopacity=\\"0\\"\\n     inkscape:pageshadow=\\"2\\"\\n     inkscape:window-width=\\"1513\\"\\n     inkscape:window-height=\\"810\\"\\n     id=\\"namedview6\\"\\n     showgrid=\\"false\\"\\n     fit-margin-top=\\"0\\"\\n     fit-margin-left=\\"0\\"\\n     fit-margin-right=\\"0\\"\\n     fit-margin-bottom=\\"0\\"\\n     inkscape:zoom=\\"0.10429825\\"\\n     inkscape:cx=\\"49.97561\\"\\n     inkscape:cy=\\"1230\\"\\n     inkscape:window-x=\\"0\\"\\n     inkscape:window-y=\\"0\\"\\n     inkscape:window-maximized=\\"0\\"\\n     inkscape:current-layer=\\"svg2\\" />\\n  <path\\n     d=\\"m 895.97559,1471.9756 336.00001,-384 -768.00001,0 -336,384 768,0 z M 1908.9756,394.97557 q 15,34 9.5,71.5 -5.5,37.5 -30.5,65.5 L 991.97559,1555.9756 q -38,44 -96,44 l -768,0 q -37.999999,0 -69.499999,-20.5 -31.5,-20.5 -47.5,-54.5 -15.0000002,-34 -9.5000002,-71.5 5.5,-37.5 30.5000002,-65.5 L 927.97559,363.97557 q 38,-44 96.00001,-44 l 768,0 q 38,0 69.5,20.5 31.5,20.5 47.5,54.5 z\\"\\n     id=\\"path4\\"\\n     inkscape:connector-curvature=\\"0\\"\\n     style=\\"fill:#ffffff;fill-opacity:1\\" />\\n</svg>\\n",\n    "eyedropper": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" standalone=\\"no\\"?>\\n<svg\\n   xmlns:dc=\\"http://purl.org/dc/elements/1.1/\\"\\n   xmlns:cc=\\"http://creativecommons.org/ns#\\"\\n   xmlns:rdf=\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\"\\n   xmlns:svg=\\"http://www.w3.org/2000/svg\\"\\n   xmlns=\\"http://www.w3.org/2000/svg\\"\\n   xmlns:sodipodi=\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\"\\n   xmlns:inkscape=\\"http://www.inkscape.org/namespaces/inkscape\\"\\n   id=\\"svg2\\"\\n   version=\\"1.1\\"\\n   inkscape:version=\\"0.91 r13725\\"\\n   sodipodi:docname=\\"eyedropper.svg\\"\\n   width=\\"1536\\"\\n   height=\\"1536\\">\\n  <metadata\\n     id=\\"metadata10\\">\\n    <rdf:RDF>\\n      <cc:Work\\n         rdf:about=\\"\\">\\n        <dc:format>image/svg+xml</dc:format>\\n        <dc:type\\n           rdf:resource=\\"http://purl.org/dc/dcmitype/StillImage\\" />\\n        <dc:title></dc:title>\\n      </cc:Work>\\n    </rdf:RDF>\\n  </metadata>\\n  <defs\\n     id=\\"defs8\\" />\\n  <sodipodi:namedview\\n     pagecolor=\\"#ffffff\\"\\n     bordercolor=\\"#666666\\"\\n     borderopacity=\\"1\\"\\n     objecttolerance=\\"10\\"\\n     gridtolerance=\\"10\\"\\n     guidetolerance=\\"10\\"\\n     inkscape:pageopacity=\\"0\\"\\n     inkscape:pageshadow=\\"2\\"\\n     inkscape:window-width=\\"1387\\"\\n     inkscape:window-height=\\"1017\\"\\n     id=\\"namedview6\\"\\n     showgrid=\\"false\\"\\n     fit-margin-top=\\"0\\"\\n     fit-margin-left=\\"0\\"\\n     fit-margin-right=\\"0\\"\\n     fit-margin-bottom=\\"0\\"\\n     inkscape:zoom=\\"0.32\\"\\n     inkscape:cx=\\"602.19687\\"\\n     inkscape:cy=\\"714.48337\\"\\n     inkscape:window-x=\\"262\\"\\n     inkscape:window-y=\\"94\\"\\n     inkscape:window-maximized=\\"0\\"\\n     inkscape:current-layer=\\"svg2\\" />\\n  <path\\n     style=\\"fill:#ffffff\\"\\n     d=\\"m -482.71786,1264.7964 c 47.30973,124.8869 112.44893,107.4729 112.68455,180.62 0.14228,44.1772 -49.9678,80.0544 -111.84205,80.156 -61.87176,0.1016 -112.20992,-35.6125 -112.35223,-79.7897 -0.25437,-78.9652 64.18518,-53.7188 111.51473,-180.9881 z\\"\\n     id=\\"path6\\"\\n     inkscape:connector-curvature=\\"0\\" />\\n  <g\\n     id=\\"g4345\\"\\n     transform=\\"translate(9.5904525,28.241584)\\">\\n    <ellipse\\n       transform=\\"matrix(0.69676716,0.71729738,-0.7086439,0.70556631,0,0)\\"\\n       ry=\\"298.82251\\"\\n       rx=\\"220.37535\\"\\n       cy=\\"-686.12292\\"\\n       cx=\\"1076.8032\\"\\n       id=\\"path4221\\"\\n       style=\\"opacity:1;fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:90.7480011;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:3.27590013;stroke-opacity:1\\" />\\n    <path\\n       inkscape:connector-curvature=\\"0\\"\\n       id=\\"rect4242\\"\\n       d=\\"m 886.8516,158.66406 c -0.6886,-0.005 -1.3805,0.25382 -1.9121,0.77735 L 772.39844,270.25586 c -1.06336,1.04705 -1.07635,2.74719 -0.0293,3.81055 l 404.17776,410.47265 c 0.4976,0.50542 1.1429,0.76705 1.7969,0.79688 l 64.2031,65.20312 c 1.047,1.06336 2.7472,1.07635 3.8105,0.0293 l 112.541,-110.81445 c 1.0634,-1.04705 1.0764,-2.74524 0.029,-3.8086 L 954.75,225.4707 c -0.4972,-0.50491 -1.1416,-0.76465 -1.7949,-0.79492 L 888.75,159.4707 c -0.5235,-0.53168 -1.2099,-0.80132 -1.8984,-0.80664 z\\"\\n       style=\\"opacity:1;fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:90.7480011;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:3.27590013;stroke-opacity:1\\" />\\n    <path\\n       sodipodi:nodetypes=\\"cccssscc\\"\\n       inkscape:connector-curvature=\\"0\\"\\n       id=\\"path4323\\"\\n       d=\\"m 800,464.125 93.75,93.75 -875,878.125 c 0,0 17.648209,-85.5337 28.125,-109.375 18.61452,-42.3597 78.72725,-122.1817 106.25,-159.375 29.84314,-40.329 58.54891,-64.9235 81.25,-112.5 7.83415,-16.4187 43.75,-125 43.75,-125 z\\"\\n       style=\\"fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\\" />\\n    <path\\n       sodipodi:nodetypes=\\"ccsssssccc\\"\\n       inkscape:connector-curvature=\\"0\\"\\n       id=\\"path4325\\"\\n       d=\\"M 956.25,623.5 40.625,1454.75 c 0,0 66.80141,-6.6189 103.125,-18.75 44.5948,-14.8935 74.04104,-32.1969 93.75,-43.75 30.19522,-17.7001 78.81364,-50.1428 106.25,-71.875 27.81048,-22.0286 28.68428,-29.0772 59.375,-46.875 21.09446,-12.2328 66.443,-43.7367 90.625,-46.875 11.4099,-1.4807 59.375,-18.75 59.375,-18.75 L 1050,711 Z\\"\\n       style=\\"fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\\" />\\n  </g>\\n</svg>\\n",\n    "fill": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" standalone=\\"no\\"?>\\n\x3c!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  --\x3e\\n\\n<svg\\n   xmlns:dc=\\"http://purl.org/dc/elements/1.1/\\"\\n   xmlns:cc=\\"http://creativecommons.org/ns#\\"\\n   xmlns:rdf=\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\"\\n   xmlns:svg=\\"http://www.w3.org/2000/svg\\"\\n   xmlns=\\"http://www.w3.org/2000/svg\\"\\n   xmlns:sodipodi=\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\"\\n   xmlns:inkscape=\\"http://www.inkscape.org/namespaces/inkscape\\"\\n   version=\\"1.1\\"\\n   id=\\"Capa_1\\"\\n   x=\\"0px\\"\\n   y=\\"0px\\"\\n   width=\\"438.536px\\"\\n   height=\\"438.536px\\"\\n   viewBox=\\"0 0 438.536 438.536\\"\\n   style=\\"enable-background:new 0 0 438.536 438.536;\\"\\n   xml:space=\\"preserve\\"\\n   inkscape:version=\\"0.91 r13725\\"\\n   sodipodi:docname=\\"fill.svg\\"><metadata\\n     id=\\"metadata41\\"><rdf:RDF><cc:Work\\n         rdf:about=\\"\\"><dc:format>image/svg+xml</dc:format><dc:type\\n           rdf:resource=\\"http://purl.org/dc/dcmitype/StillImage\\" /><dc:title /></cc:Work></rdf:RDF></metadata><defs\\n     id=\\"defs39\\" /><sodipodi:namedview\\n     pagecolor=\\"#ffffff\\"\\n     bordercolor=\\"#666666\\"\\n     borderopacity=\\"1\\"\\n     objecttolerance=\\"10\\"\\n     gridtolerance=\\"10\\"\\n     guidetolerance=\\"10\\"\\n     inkscape:pageopacity=\\"0\\"\\n     inkscape:pageshadow=\\"2\\"\\n     inkscape:window-width=\\"1496\\"\\n     inkscape:window-height=\\"880\\"\\n     id=\\"namedview37\\"\\n     showgrid=\\"false\\"\\n     inkscape:zoom=\\"1.0375456\\"\\n     inkscape:cx=\\"242.57781\\"\\n     inkscape:cy=\\"214.68798\\"\\n     inkscape:window-x=\\"24\\"\\n     inkscape:window-y=\\"43\\"\\n     inkscape:window-maximized=\\"0\\"\\n     inkscape:current-layer=\\"Capa_1\\"><inkscape:grid\\n       type=\\"xygrid\\"\\n       id=\\"grid4267\\" /></sodipodi:namedview><path\\n     style=\\"fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:#ffffff;stroke-width:1.06286144px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\\"\\n     d=\\"m 245.25184,47.054688 153.0625,153.556642 c 0,0 1.52555,28.59311 -1.60156,46.03906 -3.14673,17.55545 -13.99429,39.48505 -27.81445,55.92188 -14.06355,16.72628 -31.8086,30.85937 -31.8086,30.85937 -11.62468,8.56254 -21.2119,13.66338 -34.89062,18.93164 -20.92292,7.17692 -36.68939,8.61603 -58.0625,10.56641 l -111.46094,-105.53516 1.97461,-46.41406 c 20.56398,-14.3572 37.90458,-23.98141 55.63281,-37.23242 15.2493,-13.03418 31.87879,-29.55696 43.20899,-47.80469 5.55683,-8.94948 9.91374,-17.2689 11.61523,-29.390626 1.02053,-7.270398 0.26938,-12.293627 -3.80664,-15.921875 -4.32709,-3.851744 -11.37437,-2.916701 -17.25586,-2.05664 -15.96158,2.334087 -34.96827,11.998246 -47.48633,23.261721 -9.08676,7.50325 -15.22282,14.0503 -20.7246,21.16015 l -12.29493,16.88477 -30.61328,1.48047 c -1.32945,1.32946 1.98711,-7.16142 12.83789,-22.71289 9.28011,-13.30038 12.23863,-16.84013 27.94141,-30.244143 6.59185,-5.626853 11.72626,-9.333009 30.20898,-19.623047 13.55679,-7.547585 30.41102,-14.037575 45.71094,-17.841797 l 15.62695,-3.884765 z M 164.54677,160.44141 c 17.78054,-0.37749 -12.69607,6.5244 -20.07032,9.93164 -11.04472,5.10318 -17.06318,9.47708 -20.16992,11.91015 -7.40299,5.79771 -11.51519,12.33458 -13.1875,20.62891 -1.2782,6.33957 -1.56543,9.52759 -2.14453,15.96875 -2.90586,32.32117 -2.88219,64.17803 -2.38281,96.42578 0.11225,7.24833 0.25957,15.07702 2.15429,22.07422 1.74208,6.43347 3.60472,13.04246 9.11719,16.78906 8.32899,5.66087 19.36265,6.5987 29.45117,6.27344 23.31246,-0.75159 39.55588,-12.8877 45.10743,9.4375 1.05367,4.23728 -3.91797,8.23437 -3.91797,8.23437 -4.91505,4.33235 -12.50439,3.16763 -20.67578,4.11329 -10.90474,1.26198 -19.98027,2.82163 -29.48829,4.67382 -11.50198,2.24061 -19.32695,3.04354 -28.37695,3.80469 -9.84032,0.82763 -19.81579,1.13849 -29.625,0 -5.71035,-0.66276 -11.25665,-2.38032 -16.78711,-3.94922 -4.00563,-1.13632 -8.46104,-2.66556 -11.85156,-3.95117 -4.80776,-1.823 -11.61661,-4.7385 -11.84961,-9.875 -0.10548,-2.32518 2.67769,-4.37996 4.9375,-4.9375 3.55514,-0.87712 10.19385,-1.60088 13.82617,-4.9375 4.01269,-3.68603 6.12297,-11.8091 7.08594,-17.43164 7.68763,-44.88606 -0.80073,-105.42932 -0.17383,-129.41797 0.43073,-16.48251 3.48841,-29.04393 17.77539,-40.48633 5.34084,-4.27746 15.71077,-11.61474 77.02539,-15.10351 1.63547,-0.0931 3.03534,-0.15062 4.22071,-0.17578 z\\"\\n     id=\\"path4261\\"\\n     inkscape:connector-curvature=\\"0\\" /></svg>",\n    "floppy": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" standalone=\\"no\\"?>\\n<svg\\n   xmlns:dc=\\"http://purl.org/dc/elements/1.1/\\"\\n   xmlns:cc=\\"http://creativecommons.org/ns#\\"\\n   xmlns:rdf=\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\"\\n   xmlns:svg=\\"http://www.w3.org/2000/svg\\"\\n   xmlns=\\"http://www.w3.org/2000/svg\\"\\n   xmlns:sodipodi=\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\"\\n   xmlns:inkscape=\\"http://www.inkscape.org/namespaces/inkscape\\"\\n   id=\\"svg2\\"\\n   version=\\"1.1\\"\\n   inkscape:version=\\"0.91 r13725\\"\\n   sodipodi:docname=\\"floppy.svg\\"\\n   width=\\"1536\\"\\n   height=\\"1536\\">\\n  <metadata\\n     id=\\"metadata10\\">\\n    <rdf:RDF>\\n      <cc:Work\\n         rdf:about=\\"\\">\\n        <dc:format>image/svg+xml</dc:format>\\n        <dc:type\\n           rdf:resource=\\"http://purl.org/dc/dcmitype/StillImage\\" />\\n        <dc:title></dc:title>\\n      </cc:Work>\\n    </rdf:RDF>\\n  </metadata>\\n  <defs\\n     id=\\"defs8\\" />\\n  <sodipodi:namedview\\n     pagecolor=\\"#ffffff\\"\\n     bordercolor=\\"#666666\\"\\n     borderopacity=\\"1\\"\\n     objecttolerance=\\"10\\"\\n     gridtolerance=\\"10\\"\\n     guidetolerance=\\"10\\"\\n     inkscape:pageopacity=\\"0\\"\\n     inkscape:pageshadow=\\"2\\"\\n     inkscape:window-width=\\"1143\\"\\n     inkscape:window-height=\\"915\\"\\n     id=\\"namedview6\\"\\n     showgrid=\\"false\\"\\n     fit-margin-top=\\"0\\"\\n     fit-margin-left=\\"0\\"\\n     fit-margin-right=\\"0\\"\\n     fit-margin-bottom=\\"0\\"\\n     inkscape:zoom=\\"0.12792832\\"\\n     inkscape:cx=\\"50\\"\\n     inkscape:cy=\\"1358\\"\\n     inkscape:window-x=\\"0\\"\\n     inkscape:window-y=\\"0\\"\\n     inkscape:window-maximized=\\"0\\"\\n     inkscape:current-layer=\\"svg2\\" />\\n  <path\\n     d=\\"m 384,1408 768,0 0,-384 -768,0 0,384 z m 896,0 128,0 0,-896 q 0,-14 -10,-38.5 Q 1388,449 1378,439 L 1097,158 q -10,-10 -34,-20 -24,-10 -39,-10 l 0,416 q 0,40 -28,68 -28,28 -68,28 l -576,0 q -40,0 -68,-28 -28,-28 -28,-68 l 0,-416 -128,0 0,1280 128,0 0,-416 q 0,-40 28,-68 28,-28 68,-28 l 832,0 q 40,0 68,28 28,28 28,68 l 0,416 z M 896,480 896,160 q 0,-13 -9.5,-22.5 Q 877,128 864,128 l -192,0 q -13,0 -22.5,9.5 Q 640,147 640,160 l 0,320 q 0,13 9.5,22.5 9.5,9.5 22.5,9.5 l 192,0 q 13,0 22.5,-9.5 Q 896,493 896,480 Z m 640,32 0,928 q 0,40 -28,68 -28,28 -68,28 L 96,1536 Q 56,1536 28,1508 0,1480 0,1440 L 0,96 Q 0,56 28,28 56,0 96,0 l 928,0 q 40,0 88,20 48,20 76,48 l 280,280 q 28,28 48,76 20,48 20,88 z\\"\\n     id=\\"path4\\"\\n     inkscape:connector-curvature=\\"0\\"\\n     style=\\"fill:#ffffff;fill-opacity:1\\" />\\n</svg>\\n",\n    "fullscreen": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" standalone=\\"no\\"?>\\n<svg\\n   xmlns:dc=\\"http://purl.org/dc/elements/1.1/\\"\\n   xmlns:cc=\\"http://creativecommons.org/ns#\\"\\n   xmlns:rdf=\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\"\\n   xmlns:svg=\\"http://www.w3.org/2000/svg\\"\\n   xmlns=\\"http://www.w3.org/2000/svg\\"\\n   xmlns:sodipodi=\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\"\\n   xmlns:inkscape=\\"http://www.inkscape.org/namespaces/inkscape\\"\\n   id=\\"svg2\\"\\n   version=\\"1.1\\"\\n   inkscape:version=\\"0.91 r13725\\"\\n   sodipodi:docname=\\"fullscreen.svg\\"\\n   width=\\"1536\\"\\n   height=\\"1536\\">\\n  <metadata\\n     id=\\"metadata10\\">\\n    <rdf:RDF>\\n      <cc:Work\\n         rdf:about=\\"\\">\\n        <dc:format>image/svg+xml</dc:format>\\n        <dc:type\\n           rdf:resource=\\"http://purl.org/dc/dcmitype/StillImage\\" />\\n        <dc:title />\\n      </cc:Work>\\n    </rdf:RDF>\\n  </metadata>\\n  <defs\\n     id=\\"defs8\\" />\\n  <sodipodi:namedview\\n     pagecolor=\\"#ffffff\\"\\n     bordercolor=\\"#666666\\"\\n     borderopacity=\\"1\\"\\n     objecttolerance=\\"10\\"\\n     gridtolerance=\\"10\\"\\n     guidetolerance=\\"10\\"\\n     inkscape:pageopacity=\\"0\\"\\n     inkscape:pageshadow=\\"2\\"\\n     inkscape:window-width=\\"1672\\"\\n     inkscape:window-height=\\"1132\\"\\n     id=\\"namedview6\\"\\n     showgrid=\\"false\\"\\n     fit-margin-top=\\"0\\"\\n     fit-margin-left=\\"0\\"\\n     fit-margin-right=\\"0\\"\\n     fit-margin-bottom=\\"0\\"\\n     inkscape:zoom=\\"0.35907429\\"\\n     inkscape:cx=\\"1237.7765\\"\\n     inkscape:cy=\\"689.61464\\"\\n     inkscape:window-x=\\"0\\"\\n     inkscape:window-y=\\"0\\"\\n     inkscape:window-maximized=\\"0\\"\\n     inkscape:current-layer=\\"svg2\\" />\\n  <path\\n     d=\\"M 1213.9023,1075.3696 906.53277,768.00001 1213.9023,460.63044 1338.5819,585.30993 q 25.109,26.84072 60.6081,12.12161 33.7673,-14.7191 33.7673,-51.08395 l 0,-387.89173 q 0,-22.51158 -16.4509,-38.96234 -16.4507,-16.45077 -38.9623,-16.45077 l -387.89167,0 q -36.36485,0 -51.08396,34.63319 -14.71911,33.76736 12.12162,59.74225 L 1075.3696,322.09768 768.00001,629.46724 460.63044,322.09768 585.30993,197.41819 q 26.84072,-25.97489 12.12161,-59.74225 -14.7191,-34.63319 -51.08395,-34.63319 l -387.89174,0 q -22.51157,0 -38.96234,16.45077 -16.45076,16.45076 -16.45076,38.96234 l 0,387.89173 q 0,36.36485 34.63319,51.08395 33.76736,14.71911 59.74225,-12.12161 L 322.09768,460.63044 629.46724,768.00001 322.09768,1075.3696 197.41819,950.69009 q -16.45076,-16.45077 -38.96234,-16.45077 -10.38995,0 -20.77991,4.32915 -34.63319,14.71911 -34.63319,51.08396 l 0,387.89177 q 0,22.5116 16.45076,38.9623 16.45077,16.4508 38.96234,16.4508 l 387.89174,0 q 36.36485,0 51.08395,-34.6332 14.71911,-33.7673 -12.12161,-59.7422 L 460.63044,1213.9024 768.00001,906.53277 1075.3696,1213.9024 950.69009,1338.5819 q -26.84073,25.9749 -12.12162,59.7422 14.71911,34.6332 51.08396,34.6332 l 387.89177,0 q 22.5116,0 38.9622,-16.4509 16.4509,-16.4507 16.4509,-38.9622 l 0,-387.89177 q 0,-36.36485 -33.7673,-51.08396 -11.2558,-4.32915 -21.6458,-4.32915 -22.5116,0 -38.9623,16.45077 z\\"\\n     id=\\"path4\\"\\n     inkscape:connector-curvature=\\"0\\"\\n     style=\\"fill:#ffffff;fill-opacity:1\\" />\\n</svg>\\n",\n    "link": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" standalone=\\"no\\"?>\\n<svg\\n   xmlns:dc=\\"http://purl.org/dc/elements/1.1/\\"\\n   xmlns:cc=\\"http://creativecommons.org/ns#\\"\\n   xmlns:rdf=\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\"\\n   xmlns:svg=\\"http://www.w3.org/2000/svg\\"\\n   xmlns=\\"http://www.w3.org/2000/svg\\"\\n   xmlns:sodipodi=\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\"\\n   xmlns:inkscape=\\"http://www.inkscape.org/namespaces/inkscape\\"\\n   id=\\"svg2\\"\\n   version=\\"1.1\\"\\n   inkscape:version=\\"0.91 r13725\\"\\n   sodipodi:docname=\\"link.svg\\"\\n   width=\\"1536\\"\\n   height=\\"1536\\">\\n  <metadata\\n     id=\\"metadata10\\">\\n    <rdf:RDF>\\n      <cc:Work\\n         rdf:about=\\"\\">\\n        <dc:format>image/svg+xml</dc:format>\\n        <dc:type\\n           rdf:resource=\\"http://purl.org/dc/dcmitype/StillImage\\" />\\n        <dc:title></dc:title>\\n      </cc:Work>\\n    </rdf:RDF>\\n  </metadata>\\n  <defs\\n     id=\\"defs8\\" />\\n  <sodipodi:namedview\\n     pagecolor=\\"#ffffff\\"\\n     bordercolor=\\"#666666\\"\\n     borderopacity=\\"1\\"\\n     objecttolerance=\\"10\\"\\n     gridtolerance=\\"10\\"\\n     guidetolerance=\\"10\\"\\n     inkscape:pageopacity=\\"0\\"\\n     inkscape:pageshadow=\\"2\\"\\n     inkscape:window-width=\\"1672\\"\\n     inkscape:window-height=\\"1132\\"\\n     id=\\"namedview6\\"\\n     showgrid=\\"false\\"\\n     fit-margin-top=\\"0\\"\\n     fit-margin-left=\\"0\\"\\n     fit-margin-right=\\"0\\"\\n     fit-margin-bottom=\\"0\\"\\n     inkscape:zoom=\\"0.083281391\\"\\n     inkscape:cx=\\"494.12155\\"\\n     inkscape:cy=\\"912.40976\\"\\n     inkscape:window-x=\\"58\\"\\n     inkscape:window-y=\\"0\\"\\n     inkscape:window-maximized=\\"0\\"\\n     inkscape:current-layer=\\"svg2\\" />\\n  <path\\n     inkscape:connector-curvature=\\"0\\"\\n     unicode=\\"\\"\\n     horiz-adv-x=\\"1664\\"\\n     d=\\"m 1349.5324,410.13387 q 0,37.27772 -26.0944,63.37212 L 1129.5939,667.3501 q -26.0944,26.0944 -63.3722,26.0944 -39.1416,0 -67.09984,-29.82217 2.79584,-2.79583 17.70694,-17.24094 14.911,-14.44512 20.0367,-20.03677 5.1257,-5.59166 13.9792,-17.70692 8.8534,-12.11526 12.1152,-23.76454 3.2618,-11.64929 3.2618,-25.62843 0,-37.27771 -26.0944,-63.37212 -26.0943,-26.0944 -63.37209,-26.0944 -13.97914,0 -25.62843,3.2618 -11.64929,3.2618 -23.76454,12.11526 -12.11526,8.85346 -17.70692,13.97914 -5.59166,5.12569 -20.03677,20.03678 -14.44511,14.91108 -17.24094,17.70691 -30.75412,-28.89023 -30.75412,-68.03183 0,-37.27771 26.0944,-63.37211 L 1059.6981,212.56198 q 25.1625,-25.16246 63.3722,-25.16246 37.2777,0 63.3721,24.23052 L 1323.438,347.6937 q 26.0944,26.0944 26.0944,62.44017 z M 694.37653,1067.1537 q 0,37.2777 -26.0944,63.3721 L 476.3019,1323.438 q -26.0944,26.0944 -63.37212,26.0944 -36.34577,0 -63.37212,-25.1625 l -136.9956,-136.0636 q -26.0944,-26.0944 -26.0944,-62.4402 0,-37.2777 26.0944,-63.3721 L 406.40618,868.6498 q 25.16246,-25.16246 63.37212,-25.16246 39.1416,0 67.09988,28.89023 -2.79583,2.79583 -17.70691,17.24095 -14.91109,14.44511 -20.03677,20.03677 -5.12569,5.59165 -13.97915,17.70691 -8.85345,12.11526 -12.11525,23.7645 -3.2618,11.6493 -3.2618,25.6285 0,37.2777 26.0944,63.3721 26.0944,26.0944 63.37211,26.0944 13.97914,0 25.62843,-3.2618 11.64929,-3.2618 23.76454,-12.1152 12.11526,-8.8535 17.70692,-13.9792 5.59165,-5.1257 20.03677,-20.0367 14.44511,-14.9111 17.24094,-17.707 30.75412,28.8903 30.75412,68.0319 z M 1528.4654,410.13387 q 0,-111.83314 -79.2151,-189.1844 L 1312.2547,84.885861 Q 1234.9034,7.534599 1123.0703,7.534599 q -112.7651,0 -190.11641,79.215142 L 740.97366,279.66187 q -77.35125,77.35126 -77.35125,189.1844 0,114.62897 82.01097,194.77606 l -82.01097,82.01097 q -80.14708,-82.01097 -193.84411,-82.01097 -111.83315,0 -190.11635,78.2832 L 85.817843,935.74969 Q 7.5346375,1014.0329 7.5346375,1125.8661 q 0,111.8331 79.2151455,189.1844 l 136.995597,136.0636 q 77.35126,77.3513 189.1844,77.3513 112.76509,0 190.11635,-79.2151 l 191.98022,-192.9122 q 77.35126,-77.3513 77.35126,-189.1844 0,-114.629 -82.01098,-194.77613 l 82.01098,-82.01101 q 80.14708,82.01101 193.84409,82.01101 111.8332,0 190.1164,-78.2832 l 193.8441,-193.84415 q 78.2832,-78.2832 78.2832,-190.11635 z\\"\\n     id=\\"path4-4\\"\\n     style=\\"fill:#ffffff;fill-opacity:1\\" />\\n</svg>\\n",\n    "paint": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" standalone=\\"no\\"?>\\n\x3c!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  --\x3e\\n\\n<svg\\n   xmlns:dc=\\"http://purl.org/dc/elements/1.1/\\"\\n   xmlns:cc=\\"http://creativecommons.org/ns#\\"\\n   xmlns:rdf=\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\"\\n   xmlns:svg=\\"http://www.w3.org/2000/svg\\"\\n   xmlns=\\"http://www.w3.org/2000/svg\\"\\n   xmlns:sodipodi=\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\"\\n   xmlns:inkscape=\\"http://www.inkscape.org/namespaces/inkscape\\"\\n   version=\\"1.1\\"\\n   id=\\"Capa_1\\"\\n   x=\\"0px\\"\\n   y=\\"0px\\"\\n   width=\\"432.544px\\"\\n   height=\\"432.544px\\"\\n   viewBox=\\"0 0 432.544 432.544\\"\\n   style=\\"enable-background:new 0 0 432.544 432.544;\\"\\n   xml:space=\\"preserve\\"\\n   inkscape:version=\\"0.91 r13725\\"\\n   sodipodi:docname=\\"pencil.svg\\"><metadata\\n     id=\\"metadata45\\"><rdf:RDF><cc:Work\\n         rdf:about=\\"\\"><dc:format>image/svg+xml</dc:format><dc:type\\n           rdf:resource=\\"http://purl.org/dc/dcmitype/StillImage\\" /></cc:Work></rdf:RDF></metadata><defs\\n     id=\\"defs43\\" /><sodipodi:namedview\\n     pagecolor=\\"#ffffff\\"\\n     bordercolor=\\"#666666\\"\\n     borderopacity=\\"1\\"\\n     objecttolerance=\\"10\\"\\n     gridtolerance=\\"10\\"\\n     guidetolerance=\\"10\\"\\n     inkscape:pageopacity=\\"0\\"\\n     inkscape:pageshadow=\\"2\\"\\n     inkscape:window-width=\\"1442\\"\\n     inkscape:window-height=\\"854\\"\\n     id=\\"namedview41\\"\\n     showgrid=\\"false\\"\\n     inkscape:zoom=\\"0.77160797\\"\\n     inkscape:cx=\\"199.63062\\"\\n     inkscape:cy=\\"217.34564\\"\\n     inkscape:window-x=\\"0\\"\\n     inkscape:window-y=\\"0\\"\\n     inkscape:window-maximized=\\"0\\"\\n     inkscape:current-layer=\\"Capa_1\\" /><path\\n     d=\\"m 0,313.775 0,118.77 118.771,0 L 356.312,195.004 237.539,76.232 0,313.775 Z m 103.638,82.224 0,0 -30.55,0.004 0,-36.546 -36.543,0 0,-30.553 25.981,-25.981 67.093,67.092 -25.981,25.984 z M 246.683,124.77 c 4.182,0 6.276,2.095 6.276,6.28 0,1.906 -0.664,3.521 -1.999,4.856 L 96.214,290.651 c -1.333,1.328 -2.952,1.995 -4.854,1.995 -4.184,0 -6.279,-2.098 -6.279,-6.279 0,-1.906 0.666,-3.521 1.997,-4.856 L 241.825,126.768 c 1.329,-1.332 2.948,-1.998 4.858,-1.998 z\\"\\n     id=\\"path7\\"\\n     inkscape:connector-curvature=\\"0\\"\\n     style=\\"fill:#ffffff;fill-opacity:1\\" /><path\\n     d=\\"M 421.976,77.654 354.885,10.848 C 347.653,3.619 338.992,0 328.903,0 318.62,0 310.061,3.619 303.21,10.848 l -47.394,47.109 118.773,118.77 47.394,-47.392 c 7.042,-7.043 10.561,-15.608 10.561,-25.697 -0.004,-9.895 -3.522,-18.558 -10.568,-25.984 z\\"\\n     id=\\"path9\\"\\n     inkscape:connector-curvature=\\"0\\"\\n     style=\\"fill:#ffffff;fill-opacity:1\\" /><g\\n     id=\\"g11\\" /><g\\n     id=\\"g13\\" /><g\\n     id=\\"g15\\" /><g\\n     id=\\"g17\\" /><g\\n     id=\\"g19\\" /><g\\n     id=\\"g21\\" /><g\\n     id=\\"g23\\" /><g\\n     id=\\"g25\\" /><g\\n     id=\\"g27\\" /><g\\n     id=\\"g29\\" /><g\\n     id=\\"g31\\" /><g\\n     id=\\"g33\\" /><g\\n     id=\\"g35\\" /><g\\n     id=\\"g37\\" /><g\\n     id=\\"g39\\" /></svg>",\n    "preciseCursor": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" standalone=\\"no\\"?>\\n\x3c!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  --\x3e\\n\\n<svg\\n   xmlns:dc=\\"http://purl.org/dc/elements/1.1/\\"\\n   xmlns:cc=\\"http://creativecommons.org/ns#\\"\\n   xmlns:rdf=\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\"\\n   xmlns:svg=\\"http://www.w3.org/2000/svg\\"\\n   xmlns=\\"http://www.w3.org/2000/svg\\"\\n   xmlns:sodipodi=\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\"\\n   xmlns:inkscape=\\"http://www.inkscape.org/namespaces/inkscape\\"\\n   version=\\"1.1\\"\\n   id=\\"Capa_1\\"\\n   x=\\"0px\\"\\n   y=\\"0px\\"\\n   width=\\"438.533px\\"\\n   height=\\"438.533px\\"\\n   viewBox=\\"0 0 438.533 438.533\\"\\n   style=\\"enable-background:new 0 0 438.533 438.533;\\"\\n   xml:space=\\"preserve\\"\\n   inkscape:version=\\"0.91 r13725\\"\\n   sodipodi:docname=\\"preciseCursor.svg\\"><metadata\\n     id=\\"metadata45\\"><rdf:RDF><cc:Work\\n         rdf:about=\\"\\"><dc:format>image/svg+xml</dc:format><dc:type\\n           rdf:resource=\\"http://purl.org/dc/dcmitype/StillImage\\" /><dc:title /></cc:Work></rdf:RDF></metadata><defs\\n     id=\\"defs43\\" /><sodipodi:namedview\\n     pagecolor=\\"#ffffff\\"\\n     bordercolor=\\"#666666\\"\\n     borderopacity=\\"1\\"\\n     objecttolerance=\\"10\\"\\n     gridtolerance=\\"10\\"\\n     guidetolerance=\\"10\\"\\n     inkscape:pageopacity=\\"0\\"\\n     inkscape:pageshadow=\\"2\\"\\n     inkscape:window-width=\\"1422\\"\\n     inkscape:window-height=\\"869\\"\\n     id=\\"namedview41\\"\\n     showgrid=\\"false\\"\\n     inkscape:zoom=\\"0.38053511\\"\\n     inkscape:cx=\\"-402.22675\\"\\n     inkscape:cy=\\"219.26649\\"\\n     inkscape:window-x=\\"0\\"\\n     inkscape:window-y=\\"0\\"\\n     inkscape:window-maximized=\\"0\\"\\n     inkscape:current-layer=\\"Capa_1\\" /><g\\n     id=\\"g11\\" /><g\\n     id=\\"g13\\" /><g\\n     id=\\"g15\\" /><g\\n     id=\\"g17\\" /><g\\n     id=\\"g19\\" /><g\\n     id=\\"g21\\" /><g\\n     id=\\"g23\\" /><g\\n     id=\\"g25\\" /><g\\n     id=\\"g27\\" /><g\\n     id=\\"g29\\" /><g\\n     id=\\"g31\\" /><g\\n     id=\\"g33\\" /><g\\n     id=\\"g35\\" /><g\\n     id=\\"g37\\" /><g\\n     id=\\"g39\\" /><circle\\n     style=\\"opacity:1;fill:none;fill-opacity:1;stroke:#ffffff;stroke-width:45;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:3.27590013;stroke-opacity:1\\"\\n     id=\\"path4218\\"\\n     cx=\\"266.93713\\"\\n     cy=\\"266.42563\\"\\n     r=\\"151.44254\\" /><rect\\n     style=\\"opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:35;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:3.27590013;stroke-opacity:1\\"\\n     id=\\"rect4821\\"\\n     width=\\"99.859383\\"\\n     height=\\"99.859383\\"\\n     x=\\"2.3951492\\"\\n     y=\\"0.7003231\\" /></svg>",\n    "ruler": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" standalone=\\"no\\"?>\\n<svg\\n   xmlns:dc=\\"http://purl.org/dc/elements/1.1/\\"\\n   xmlns:cc=\\"http://creativecommons.org/ns#\\"\\n   xmlns:rdf=\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\"\\n   xmlns:svg=\\"http://www.w3.org/2000/svg\\"\\n   xmlns=\\"http://www.w3.org/2000/svg\\"\\n   xmlns:sodipodi=\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\"\\n   xmlns:inkscape=\\"http://www.inkscape.org/namespaces/inkscape\\"\\n   id=\\"svg2\\"\\n   version=\\"1.1\\"\\n   inkscape:version=\\"0.91 r13725\\"\\n   sodipodi:docname=\\"ruler.svg\\"\\n   width=\\"1536\\"\\n   height=\\"1536\\">\\n  <metadata\\n     id=\\"metadata10\\">\\n    <rdf:RDF>\\n      <cc:Work\\n         rdf:about=\\"\\">\\n        <dc:format>image/svg+xml</dc:format>\\n        <dc:type\\n           rdf:resource=\\"http://purl.org/dc/dcmitype/StillImage\\" />\\n        <dc:title />\\n      </cc:Work>\\n    </rdf:RDF>\\n  </metadata>\\n  <defs\\n     id=\\"defs8\\" />\\n  <sodipodi:namedview\\n     pagecolor=\\"#ffffff\\"\\n     bordercolor=\\"#666666\\"\\n     borderopacity=\\"1\\"\\n     objecttolerance=\\"10\\"\\n     gridtolerance=\\"10\\"\\n     guidetolerance=\\"10\\"\\n     inkscape:pageopacity=\\"0\\"\\n     inkscape:pageshadow=\\"2\\"\\n     inkscape:window-width=\\"1672\\"\\n     inkscape:window-height=\\"1132\\"\\n     id=\\"namedview6\\"\\n     showgrid=\\"false\\"\\n     fit-margin-top=\\"0\\"\\n     fit-margin-left=\\"0\\"\\n     fit-margin-right=\\"0\\"\\n     fit-margin-bottom=\\"0\\"\\n     inkscape:zoom=\\"0.43706558\\"\\n     inkscape:cx=\\"865.05289\\"\\n     inkscape:cy=\\"1003.9292\\"\\n     inkscape:window-x=\\"58\\"\\n     inkscape:window-y=\\"0\\"\\n     inkscape:window-maximized=\\"0\\"\\n     inkscape:current-layer=\\"svg2\\" />\\n  <path\\n     style=\\"color:#000000;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:#ffffff;stroke-width:0.95860869;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:5.75165231, 5.75165231;stroke-dashoffset:0;stroke-opacity:1;marker:none;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate\\"\\n     d=\\"M 2.7402858,1161.1464 374.85356,1533.2597 1533.2597,374.85358 1161.1465,2.7403069 1044.5562,119.33061 1261.9849,336.75943 1213.5238,385.22065 996.09492,167.79183 863.1845,300.70224 992.10584,429.62357 943.62249,478.10687 814.70119,349.18555 681.80112,482.08561 810.72244,611.00693 762.23917,659.49022 633.31784,530.5689 500.40741,663.47932 717.83623,880.90814 669.37508,929.36929 451.94626,711.94048 319.03581,844.85093 447.95713,973.77222 399.47251,1022.2569 270.55119,893.33555 137.65377,1026.2329 266.5751,1155.1543 218.09048,1203.6389 89.169162,1074.7176 2.7402858,1161.1464 Z\\"\\n     id=\\"rect4137\\"\\n     inkscape:connector-curvature=\\"0\\" />\\n</svg>\\n",\n    "show": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" standalone=\\"no\\"?>\\n<svg\\n   xmlns:dc=\\"http://purl.org/dc/elements/1.1/\\"\\n   xmlns:cc=\\"http://creativecommons.org/ns#\\"\\n   xmlns:rdf=\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\"\\n   xmlns:svg=\\"http://www.w3.org/2000/svg\\"\\n   xmlns=\\"http://www.w3.org/2000/svg\\"\\n   xmlns:sodipodi=\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\"\\n   xmlns:inkscape=\\"http://www.inkscape.org/namespaces/inkscape\\"\\n   id=\\"svg2\\"\\n   version=\\"1.1\\"\\n   inkscape:version=\\"0.91 r13725\\"\\n   sodipodi:docname=\\"show.svg\\"\\n   width=\\"1536\\"\\n   height=\\"1536\\">\\n  <metadata\\n     id=\\"metadata10\\">\\n    <rdf:RDF>\\n      <cc:Work\\n         rdf:about=\\"\\">\\n        <dc:format>image/svg+xml</dc:format>\\n        <dc:type\\n           rdf:resource=\\"http://purl.org/dc/dcmitype/StillImage\\" />\\n        <dc:title></dc:title>\\n      </cc:Work>\\n    </rdf:RDF>\\n  </metadata>\\n  <defs\\n     id=\\"defs8\\" />\\n  <sodipodi:namedview\\n     pagecolor=\\"#ffffff\\"\\n     bordercolor=\\"#666666\\"\\n     borderopacity=\\"1\\"\\n     objecttolerance=\\"10\\"\\n     gridtolerance=\\"10\\"\\n     guidetolerance=\\"10\\"\\n     inkscape:pageopacity=\\"0\\"\\n     inkscape:pageshadow=\\"2\\"\\n     inkscape:window-width=\\"1672\\"\\n     inkscape:window-height=\\"1132\\"\\n     id=\\"namedview6\\"\\n     showgrid=\\"false\\"\\n     fit-margin-top=\\"0\\"\\n     fit-margin-left=\\"0\\"\\n     fit-margin-right=\\"0\\"\\n     fit-margin-bottom=\\"0\\"\\n     inkscape:zoom=\\"0.23555534\\"\\n     inkscape:cx=\\"643.48363\\"\\n     inkscape:cy=\\"372.07296\\"\\n     inkscape:window-x=\\"20\\"\\n     inkscape:window-y=\\"25\\"\\n     inkscape:window-maximized=\\"0\\"\\n     inkscape:current-layer=\\"svg2\\" />\\n  <ellipse\\n     style=\\"opacity:1;fill:none;fill-opacity:1;fill-rule:nonzero;stroke:#ffffff;stroke-width:90.748;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:3.27590013;stroke-opacity:1\\"\\n     id=\\"path4158\\"\\n     cy=\\"-769.0257\\"\\n     cx=\\"-772.66711\\"\\n     transform=\\"scale(-1,-1)\\"\\n     rx=\\"654.74829\\"\\n     ry=\\"657.38306\\" />\\n  <rect\\n     style=\\"opacity:1;fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:90.7480011;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:3.27590013;stroke-opacity:1\\"\\n     id=\\"rect4158\\"\\n     width=\\"97.641602\\"\\n     height=\\"407.54755\\"\\n     x=\\"719.1792\\"\\n     y=\\"-9.7749958\\"\\n     ry=\\"2.4023087\\" />\\n  <rect\\n     style=\\"opacity:1;fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:90.7480011;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:3.27590013;stroke-opacity:1\\"\\n     id=\\"rect4158-5\\"\\n     width=\\"97.641602\\"\\n     height=\\"407.54755\\"\\n     x=\\"719.1792\\"\\n     y=\\"1141.4336\\"\\n     ry=\\"2.4023087\\" />\\n  <rect\\n     style=\\"opacity:1;fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:90.7480011;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:3.27590013;stroke-opacity:1\\"\\n     id=\\"rect4158-0\\"\\n     width=\\"97.641602\\"\\n     height=\\"407.54755\\"\\n     x=\\"719.1792\\"\\n     y=\\"-1541.0392\\"\\n     ry=\\"2.4023087\\"\\n     transform=\\"matrix(0,1,-1,0,0,0)\\" />\\n  <rect\\n     style=\\"opacity:1;fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:90.7480011;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:3.27590013;stroke-opacity:1\\"\\n     id=\\"rect4158-0-5\\"\\n     width=\\"97.641602\\"\\n     height=\\"407.54755\\"\\n     x=\\"719.1792\\"\\n     y=\\"-407.54755\\"\\n     ry=\\"2.4023087\\"\\n     transform=\\"matrix(0,1,-1,0,0,0)\\" />\\n</svg>\\n",\n    "sun-o": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" standalone=\\"no\\"?>\\n<svg\\n   xmlns:dc=\\"http://purl.org/dc/elements/1.1/\\"\\n   xmlns:cc=\\"http://creativecommons.org/ns#\\"\\n   xmlns:rdf=\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\"\\n   xmlns:svg=\\"http://www.w3.org/2000/svg\\"\\n   xmlns=\\"http://www.w3.org/2000/svg\\"\\n   xmlns:sodipodi=\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\"\\n   xmlns:inkscape=\\"http://www.inkscape.org/namespaces/inkscape\\"\\n   width=\\"1792\\"\\n   height=\\"1792\\"\\n   viewBox=\\"0 0 1792 1792\\"\\n   id=\\"svg2\\"\\n   version=\\"1.1\\"\\n   inkscape:version=\\"0.91 r13725\\"\\n   sodipodi:docname=\\"sun-o.svg\\">\\n  <metadata\\n     id=\\"metadata10\\">\\n    <rdf:RDF>\\n      <cc:Work\\n         rdf:about=\\"\\">\\n        <dc:format>image/svg+xml</dc:format>\\n        <dc:type\\n           rdf:resource=\\"http://purl.org/dc/dcmitype/StillImage\\" />\\n      </cc:Work>\\n    </rdf:RDF>\\n  </metadata>\\n  <defs\\n     id=\\"defs8\\" />\\n  <sodipodi:namedview\\n     pagecolor=\\"#ffffff\\"\\n     bordercolor=\\"#666666\\"\\n     borderopacity=\\"1\\"\\n     objecttolerance=\\"10\\"\\n     gridtolerance=\\"10\\"\\n     guidetolerance=\\"10\\"\\n     inkscape:pageopacity=\\"0\\"\\n     inkscape:pageshadow=\\"2\\"\\n     inkscape:window-width=\\"771\\"\\n     inkscape:window-height=\\"480\\"\\n     id=\\"namedview6\\"\\n     showgrid=\\"false\\"\\n     inkscape:zoom=\\"0.13169643\\"\\n     inkscape:cx=\\"896\\"\\n     inkscape:cy=\\"896\\"\\n     inkscape:window-x=\\"0\\"\\n     inkscape:window-y=\\"0\\"\\n     inkscape:window-maximized=\\"0\\"\\n     inkscape:current-layer=\\"svg2\\" />\\n  <path\\n     d=\\"M1472 896q0-117-45.5-223.5t-123-184-184-123-223.5-45.5-223.5 45.5-184 123-123 184-45.5 223.5 45.5 223.5 123 184 184 123 223.5 45.5 223.5-45.5 184-123 123-184 45.5-223.5zm276 277q-4 15-20 20l-292 96v306q0 16-13 26-15 10-29 4l-292-94-180 248q-10 13-26 13t-26-13l-180-248-292 94q-14 6-29-4-13-10-13-26v-306l-292-96q-16-5-20-20-5-17 4-29l180-248-180-248q-9-13-4-29 4-15 20-20l292-96v-306q0-16 13-26 15-10 29-4l292 94 180-248q9-12 26-12t26 12l180 248 292-94q14-6 29 4 13 10 13 26v306l292 96q16 5 20 20 5 16-4 29l-180 248 180 248q9 12 4 29z\\"\\n     id=\\"path4\\"\\n     style=\\"fill:#ffffff;fill-opacity:1\\" />\\n</svg>\\n",\n    "times-circle": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" standalone=\\"no\\"?>\\n<svg\\n   xmlns:dc=\\"http://purl.org/dc/elements/1.1/\\"\\n   xmlns:cc=\\"http://creativecommons.org/ns#\\"\\n   xmlns:rdf=\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\"\\n   xmlns:svg=\\"http://www.w3.org/2000/svg\\"\\n   xmlns=\\"http://www.w3.org/2000/svg\\"\\n   xmlns:sodipodi=\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\"\\n   xmlns:inkscape=\\"http://www.inkscape.org/namespaces/inkscape\\"\\n   id=\\"svg2\\"\\n   version=\\"1.1\\"\\n   inkscape:version=\\"0.91 r13725\\"\\n   sodipodi:docname=\\"times-circle.svg\\"\\n   width=\\"1536\\"\\n   height=\\"1536\\">\\n  <metadata\\n     id=\\"metadata10\\">\\n    <rdf:RDF>\\n      <cc:Work\\n         rdf:about=\\"\\">\\n        <dc:format>image/svg+xml</dc:format>\\n        <dc:type\\n           rdf:resource=\\"http://purl.org/dc/dcmitype/StillImage\\" />\\n        <dc:title></dc:title>\\n      </cc:Work>\\n    </rdf:RDF>\\n  </metadata>\\n  <defs\\n     id=\\"defs8\\" />\\n  <sodipodi:namedview\\n     pagecolor=\\"#ffffff\\"\\n     bordercolor=\\"#666666\\"\\n     borderopacity=\\"1\\"\\n     objecttolerance=\\"10\\"\\n     gridtolerance=\\"10\\"\\n     guidetolerance=\\"10\\"\\n     inkscape:pageopacity=\\"0\\"\\n     inkscape:pageshadow=\\"2\\"\\n     inkscape:window-width=\\"1421\\"\\n     inkscape:window-height=\\"927\\"\\n     id=\\"namedview6\\"\\n     showgrid=\\"false\\"\\n     fit-margin-top=\\"0\\"\\n     fit-margin-left=\\"0\\"\\n     fit-margin-right=\\"0\\"\\n     fit-margin-bottom=\\"0\\"\\n     inkscape:zoom=\\"0.24983578\\"\\n     inkscape:cx=\\"603.69966\\"\\n     inkscape:cy=\\"717.57932\\"\\n     inkscape:window-x=\\"3\\"\\n     inkscape:window-y=\\"94\\"\\n     inkscape:window-maximized=\\"0\\"\\n     inkscape:current-layer=\\"svg2\\" />\\n  <circle\\n     style=\\"opacity:1;fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:#000000;stroke-width:49.2240715;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:3.27590013;stroke-opacity:0\\"\\n     id=\\"path4163\\"\\n     cx=\\"771.36877\\"\\n     cy=\\"769.58008\\"\\n     r=\\"741.44299\\" />\\n  <path\\n     style=\\"fill:#000000;fill-opacity:1\\"\\n     d=\\"m 476.54792,425.97171 q 10.06623,-10.03115 30.83387,-3.90314 20.76765,6.128 39.12031,24.54484 l 542.1094,544.00499 q 18.3526,18.4168 24.4081,39.2057 6.0555,20.7889 -4.0107,30.8201 l -49.5568,49.3841 q -10.0662,10.0311 -30.8339,3.9031 -20.7676,-6.128 -39.1203,-24.5448 L 447.38854,545.3816 q -18.35266,-18.41684 -24.40814,-39.20574 -6.05548,-20.78891 4.01075,-30.82006 l 49.55678,-49.3841 z\\"\\n     id=\\"path4\\"\\n     inkscape:connector-curvature=\\"0\\" />\\n  <path\\n     style=\\"fill:#000000;fill-opacity:1\\"\\n     d=\\"m 1110.0283,476.54791 q 10.0311,10.06622 3.9031,30.83387 -6.128,20.76765 -24.5448,39.12031 L 545.38159,1088.6115 q -18.41683,18.3526 -39.20574,24.4081 -20.7889,6.0555 -30.82005,-4.0107 l -49.38409,-49.5568 q -10.03115,-10.0662 -3.90316,-30.8339 6.12802,-20.7676 24.54485,-39.1203 L 990.61841,447.38853 q 18.41679,-18.35266 39.20569,-24.40815 20.789,-6.05547 30.8201,4.01076 l 49.3841,49.55678 z\\"\\n     id=\\"path4-6\\"\\n     inkscape:connector-curvature=\\"0\\" />\\n</svg>\\n",\n    "undo": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" standalone=\\"no\\"?>\\n\x3c!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  --\x3e\\n\\n<svg\\n   xmlns:dc=\\"http://purl.org/dc/elements/1.1/\\"\\n   xmlns:cc=\\"http://creativecommons.org/ns#\\"\\n   xmlns:rdf=\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\"\\n   xmlns:svg=\\"http://www.w3.org/2000/svg\\"\\n   xmlns=\\"http://www.w3.org/2000/svg\\"\\n   xmlns:sodipodi=\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\"\\n   xmlns:inkscape=\\"http://www.inkscape.org/namespaces/inkscape\\"\\n   version=\\"1.1\\"\\n   id=\\"Capa_1\\"\\n   x=\\"0px\\"\\n   y=\\"0px\\"\\n   width=\\"438.536px\\"\\n   height=\\"438.536px\\"\\n   viewBox=\\"0 0 438.536 438.536\\"\\n   style=\\"enable-background:new 0 0 438.536 438.536;\\"\\n   xml:space=\\"preserve\\"\\n   inkscape:version=\\"0.91 r13725\\"\\n   sodipodi:docname=\\"undo.svg\\"><metadata\\n     id=\\"metadata41\\"><rdf:RDF><cc:Work\\n         rdf:about=\\"\\"><dc:format>image/svg+xml</dc:format><dc:type\\n           rdf:resource=\\"http://purl.org/dc/dcmitype/StillImage\\" /><dc:title /></cc:Work></rdf:RDF></metadata><defs\\n     id=\\"defs39\\" /><sodipodi:namedview\\n     pagecolor=\\"#ffffff\\"\\n     bordercolor=\\"#666666\\"\\n     borderopacity=\\"1\\"\\n     objecttolerance=\\"10\\"\\n     gridtolerance=\\"10\\"\\n     guidetolerance=\\"10\\"\\n     inkscape:pageopacity=\\"0\\"\\n     inkscape:pageshadow=\\"2\\"\\n     inkscape:window-width=\\"1253\\"\\n     inkscape:window-height=\\"789\\"\\n     id=\\"namedview37\\"\\n     showgrid=\\"false\\"\\n     inkscape:zoom=\\"0.76106498\\"\\n     inkscape:cx=\\"239.298\\"\\n     inkscape:cy=\\"223.77677\\"\\n     inkscape:window-x=\\"0\\"\\n     inkscape:window-y=\\"0\\"\\n     inkscape:window-maximized=\\"0\\"\\n     inkscape:current-layer=\\"Capa_1\\" /><g\\n     id=\\"g3\\"\\n     style=\\"fill:#ffffff;fill-opacity:1\\"\\n     transform=\\"matrix(0.77966051,0,0,0.77966051,48.313794,48.312625)\\"><path\\n       d=\\"M 388.54414,147.92304 C 378.80973,125.25582 365.7201,105.70231 349.28197,89.264182 332.84048,72.825202 313.28781,59.738096 290.61975,49.999496 c -22.66553,-9.7386 -46.44473,-14.604127 -71.34596,-14.604127 -23.4622,0 -46.16631,4.425264 -68.11653,13.285856 -21.94518,8.858915 -41.45845,21.348107 -58.538103,37.470927 L 61.490517,55.262517 C 56.701303,50.313969 51.196767,49.1978 44.969363,51.908976 38.583464,54.626023 35.390934,59.33641 35.390934,66.039302 l 0,107.262128 c 0,4.14937 1.517018,7.74107 4.550215,10.77343 3.034874,3.03319 6.626575,4.55021 10.775942,4.55021 l 107.262139,0 c 6.7054,0 11.41327,-3.19253 14.12696,-9.57759 2.71202,-6.22489 1.59585,-11.73026 -3.35354,-16.52115 l -32.80163,-33.03896 c 11.17679,-10.53526 23.9444,-18.63525 38.30952,-24.30247 14.36597,-5.666388 29.36843,-8.501678 45.01158,-8.501678 16.5983,0 32.44271,3.2353 47.52651,9.696668 15.08632,6.46557 28.12982,15.20456 39.14477,26.21867 11.0141,11.01158 19.75309,24.05928 26.21866,39.14476 6.45969,15.0838 9.69415,30.92318 9.69415,47.52652 0,16.6025 -3.23362,32.44187 -9.69415,47.52484 -6.46557,15.0838 -15.20456,28.12982 -26.21866,39.14476 -11.01495,11.0141 -24.06348,19.75561 -39.14477,26.21866 -15.0838,6.46305 -30.92821,9.695 -47.52651,9.695 -18.99501,0 -36.95184,-4.15021 -53.87217,-12.44726 -16.91781,-8.29706 -31.20327,-20.02816 -42.85554,-35.19834 -1.11617,-1.59501 -2.95269,-2.55436 -5.50705,-2.87554 -2.39503,0 -4.39088,0.717 -5.98673,2.15183 L 78.249837,326.5261 c -1.27551,1.28305 -1.95393,2.91663 -2.03444,4.9083 -0.0788,2.00004 0.44194,3.7938 1.55811,5.38964 17.40001,21.0697 38.467183,37.39043 63.207403,48.95884 24.74022,11.57093 50.83981,17.35975 78.29288,17.35975 24.90123,0 48.68043,-4.87056 71.34596,-14.60497 22.66806,-9.73356 42.21486,-22.82654 58.65887,-39.26384 16.44065,-16.444 29.52775,-35.99332 39.26468,-58.65886 9.73692,-22.66554 14.60077,-46.45144 14.60077,-71.34764 8.4e-4,-24.90458 -4.86637,-48.67791 -14.59993,-71.34428 z\\"\\n       id=\\"path5\\"\\n       style=\\"fill:#ffffff;fill-opacity:1\\"\\n       inkscape:connector-curvature=\\"0\\" /></g><g\\n     id=\\"g7\\" /><g\\n     id=\\"g9\\" /><g\\n     id=\\"g11\\" /><g\\n     id=\\"g13\\" /><g\\n     id=\\"g15\\" /><g\\n     id=\\"g17\\" /><g\\n     id=\\"g19\\" /><g\\n     id=\\"g21\\" /><g\\n     id=\\"g23\\" /><g\\n     id=\\"g25\\" /><g\\n     id=\\"g27\\" /><g\\n     id=\\"g29\\" /><g\\n     id=\\"g31\\" /><g\\n     id=\\"g33\\" /><g\\n     id=\\"g35\\" /></svg>",\n    "upload": "<?xml version=\\"1.0\\" encoding=\\"UTF-8\\" standalone=\\"no\\"?>\\n\x3c!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  --\x3e\\n\\n<svg\\n   xmlns:dc=\\"http://purl.org/dc/elements/1.1/\\"\\n   xmlns:cc=\\"http://creativecommons.org/ns#\\"\\n   xmlns:rdf=\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\"\\n   xmlns:svg=\\"http://www.w3.org/2000/svg\\"\\n   xmlns=\\"http://www.w3.org/2000/svg\\"\\n   xmlns:sodipodi=\\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\\"\\n   xmlns:inkscape=\\"http://www.inkscape.org/namespaces/inkscape\\"\\n   version=\\"1.1\\"\\n   id=\\"Capa_1\\"\\n   x=\\"0px\\"\\n   y=\\"0px\\"\\n   width=\\"438.533px\\"\\n   height=\\"438.533px\\"\\n   viewBox=\\"0 0 438.533 438.533\\"\\n   style=\\"enable-background:new 0 0 438.533 438.533;\\"\\n   xml:space=\\"preserve\\"\\n   inkscape:version=\\"0.91 r13725\\"\\n   sodipodi:docname=\\"upload.svg\\"><metadata\\n     id=\\"metadata45\\"><rdf:RDF><cc:Work\\n         rdf:about=\\"\\"><dc:format>image/svg+xml</dc:format><dc:type\\n           rdf:resource=\\"http://purl.org/dc/dcmitype/StillImage\\" /><dc:title /></cc:Work></rdf:RDF></metadata><defs\\n     id=\\"defs43\\" /><sodipodi:namedview\\n     pagecolor=\\"#ffffff\\"\\n     bordercolor=\\"#666666\\"\\n     borderopacity=\\"1\\"\\n     objecttolerance=\\"10\\"\\n     gridtolerance=\\"10\\"\\n     guidetolerance=\\"10\\"\\n     inkscape:pageopacity=\\"0\\"\\n     inkscape:pageshadow=\\"2\\"\\n     inkscape:window-width=\\"1520\\"\\n     inkscape:window-height=\\"931\\"\\n     id=\\"namedview41\\"\\n     showgrid=\\"false\\"\\n     inkscape:zoom=\\"0.13453948\\"\\n     inkscape:cx=\\"-435.17349\\"\\n     inkscape:cy=\\"-969.97552\\"\\n     inkscape:window-x=\\"0\\"\\n     inkscape:window-y=\\"0\\"\\n     inkscape:window-maximized=\\"0\\"\\n     inkscape:current-layer=\\"Capa_1\\" /><path\\n     d=\\"m 126.28945,148.5037 55.71476,0 0,105.61434 c 0,2.80155 0.87617,5.09976 2.61533,6.90091 1.73202,1.7959 3.95908,2.69858 6.66486,2.69858 l 55.7249,0 c 2.70783,0 4.93385,-0.90268 6.67504,-2.69858 1.74219,-1.8022 2.61227,-4.09936 2.61227,-6.90091 l 0,-105.61014 55.72084,0 c 4.25487,0 7.15784,-2.00186 8.70692,-5.99928 1.54907,-3.80512 0.86805,-7.30024 -2.03188,-10.50427 L 225.82645,35.997905 c -2.13046,-1.798 -4.35345,-2.69753 -6.67502,-2.69753 -2.31854,0 -4.54456,0.89953 -6.67706,2.69753 l -92.57534,95.703805 c -1.93329,2.39908 -2.8979,4.80867 -2.8979,7.2004 0,2.79736 0.86907,5.09976 2.61534,6.90407 1.73711,1.79905 3.96313,2.69752 6.67298,2.69752 z\\"\\n     id=\\"path9\\"\\n     inkscape:connector-curvature=\\"0\\"\\n     style=\\"fill:#ffffff;fill-opacity:1\\" /><g\\n     id=\\"g11\\" /><g\\n     id=\\"g13\\" /><g\\n     id=\\"g15\\" /><g\\n     id=\\"g17\\" /><g\\n     id=\\"g19\\" /><g\\n     id=\\"g21\\" /><g\\n     id=\\"g23\\" /><g\\n     id=\\"g25\\" /><g\\n     id=\\"g27\\" /><g\\n     id=\\"g29\\" /><g\\n     id=\\"g31\\" /><g\\n     id=\\"g33\\" /><g\\n     id=\\"g35\\" /><g\\n     id=\\"g37\\" /><g\\n     id=\\"g39\\" /><path\\n     style=\\"opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:35;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:3.27590013;stroke-opacity:1\\"\\n     d=\\"m 36.235244,305.81445 0,98.48438 366.062506,0 0,-98.48438 -42.73828,0 0,55.7461 -280.585945,0 0,-55.7461 z\\"\\n     id=\\"rect4150\\"\\n     inkscape:connector-curvature=\\"0\\"\\n     sodipodi:nodetypes=\\"ccccccccc\\" /></svg>"\n  }\n};\n\n// CONCATENATED MODULE: ./view/atlasMaker/src/atlasmaker.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AtlasMakerWidget", function() { return atlasmaker_AtlasMakerWidget; });\n/*! AtlasMaker */\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @page AtlasMaker\n */\nvar atlasmaker_AtlasMakerWidget = {\n    //========================================================================================\n    // Globals\n    //========================================================================================\n    debug:            1,\n    hostname: \'http://localhost:3001\', // \'\', // \'http://brainbox.pasteur.fr\',\n    wshostname: \'ws://localhost:8080\', // \'ws://brainbox.pasteur.fr:8080\',\n    container:        null,    // Element where atlasMaker lives\n    brain_offcn:    null,\n    brain_offtx:    null,\n    canvas:            null,\n    context:        null,\n    brain_px:        null,\n    brain_W:        null,\n    brain_H:        null,\n    brain_D:        null,\n    brain_Wdim:        null,\n    brain_Hdim:        null,\n    max:            0,\n    /*\n        {FIX: TRY TO KEEP ALL 3D STUFF INSIDE Users\n    */\n    brain_dim:        new Array(3),\n    brain_pixdim:    new Array(3),\n    brain_datatype:    null,\n    /*\n        }\n    */\n    brain_img:      {     img: null,\n                         view: null,\n                        slice: null\n                    },\n    brain:            0,\n    alphaLevel:        0.5,\n    annotationLength:0,\n    measureLength:    null,\n    User:            {  view:null,\n                       tool:\'show\',\n                      slice:null,\n                    penSize:1,\n                   penValue:1,\n                     doFill:false,\n                mouseIsDown:false,\n                         x0:-1,\n                         y0:-1,\n                        mri:new Object()\n            },\n    Collab:                 [],\n    atlas:                 null,\n    atlas_offcn:         null,\n    atlas_offtx:         null,    \n    atlas_px:             null,\n    name:                 null,\n    url:                 null,\n    atlasFilename:         null,\n    socket:                 null,\n    receiveFunctions:    [],\n    sendFunctions:       [],\n    flagConnected:         0,\n    reconnectionTimeout: 5, // reconnection timeout starts at 5 seconds\n    flagLoadingImg:      {loading:false},\n    flagUsePreciseCursor: false,\n    msg:                 null,\n    msg0:                 "",\n    prevData:             0,\n    Crsr:            { x:undefined,            // cursor x coord\n                       y:undefined,            // cursor y coord\n                       fx:undefined,        // finger x coord\n                       fy:undefined,        // finger y coord\n                       x0:undefined,        // previous finger x coord\n                       y0:undefined,        // previous finger y coord\n                       cachedX:undefined,    // finger x coord at touch start\n                       cachedY:undefined,    // finger y coord at touch start\n                       state:"move",        // cursor state: move, draw, configure\n                       prevState:undefined,    // state before configure\n                       touchStarted:false    // touch started flag\n                    },\n    editMode:        0,    // editMode=0 to prevent editing, editMode=1 to accept it\n    fullscreen:        false,    // fullscreen mode\n    info:{},    // information displayed over each brain slice\n    // undo stack\n    /* DEPRECATED Undo:[], */\n    version:    1, // version of the configuration file (slice number, plane, etc). Default=1\n\n    /**\n     * @function traceLog\n     */\n    traceLog: function traceLog(f,l,c) {\n    /*\n        var me=AtlasMakerWidget;\n        if(me.debug && (l==undefined || me.debug>l)) {\n            var str,arg=[];\n            // str="am> "+(f.name)+" "+(f.caller?(f.caller.name||"annonymous"):"root");\n            str="am> ";//+(f.name);\n            if(c) {\n                str="%c"+str;\n            }\n            arg.push(str);\n            if(c) {\n                arg.push("color:"+c);\n            }\n            return arg;\n        }\n    */\n    },\n    /**\n     * @function quit\n     */\n    quit: function quit() {\n        var me=atlasmaker_AtlasMakerWidget;\n        var l=me.traceLog(quit,0,"#bbd");if(l)console.log.apply(undefined,l);\n    \n        me.log("","Goodbye!");\n        me.socket.close();\n        me.socket = null;\n    },\n\n    //====================================================================================\n    // Configuration\n    //====================================================================================\n    /**\n     * @function initAtlasMaker\n     */\n    initAtlasMaker: function initAtlasMaker(elem) {\n        var me=atlasmaker_AtlasMakerWidget;\n        var l=me.traceLog(initAtlasMaker,0,"#bbd");if(l)console.log.apply(undefined,l);\n\n        jquery_default.a.extend(atlasmaker_AtlasMakerWidget,AtlasMakerDraw);\n        jquery_default.a.extend(atlasmaker_AtlasMakerWidget,AtlasMakerInteraction);\n        jquery_default.a.extend(atlasmaker_AtlasMakerWidget,AtlasMakerIO);\n        jquery_default.a.extend(atlasmaker_AtlasMakerWidget,AtlasMakerPaint);\n        jquery_default.a.extend(atlasmaker_AtlasMakerWidget,AtlasMakerUI);\n        jquery_default.a.extend(atlasmaker_AtlasMakerWidget,AtlasMakerWS);\n        jquery_default.a.extend(atlasmaker_AtlasMakerWidget,AtlasMakerResources);\n\n        // Add css\n        var css;\n        for(css in me.css) {\n            let node = document.createElement(\'style\');\n            node.innerHTML = me.css[css];\n            document.body.appendChild(node);\n        }\n\n        // check if user is loged in\n        jquery_default.a.get("/loggedIn",function(res) {\n            console.log(res);\n            if(res.loggedIn)\n                me.User.username=res.username\n            else\n                me.User.username=\'Anonymous\';\n        });\n\n        // Create offscreen canvas for mri and atlas\n        me.brain_offcn=document.createElement(\'canvas\');\n        me.brain_offtx=me.brain_offcn.getContext(\'2d\');\n        me.atlas_offcn=document.createElement(\'canvas\');\n        me.atlas_offtx=me.atlas_offcn.getContext(\'2d\');\n\n        // Set widget div (create one if none)\n        if(elem==undefined) {\n            me.container=jquery_default()("<div class=\'atlasMaker\'");\n            jquery_default()(document.body).append(me.container);\n        }\n        else {\n            me.container=elem;\n            if(me.debug) console.log("Container: ",me.container);\n        }\n        \n        // Init drawing canvas\n        me.container.append(\'<div id="resizable"><canvas id="canvas"></canvas></div>\');\n        me.canvas = me.container.find(\'canvas\')[0];\n        me.context = me.canvas.getContext(\'2d\');\n        \n        // Add div to display slice number\n        me.container.find("#resizable").append("<div id=\'text-layer\'></div>");\n\n        // Add div to display slice number\n        me.container.find("#resizable").append("<svg id=\'vector-layer\'></svg>");\n        \n        // Add cursor (a small div)\n        me.container.find("#resizable").append("<div id=\'cursor\'></div>");\n        \n        jquery_default()(\'body\').attr(\'data-toolbarDisplay\',\'right\');\n        \n        // Add precise cursor\n        var isTouchArr=[];//["iPad","iPod"];\n        var curDevice=navigator.userAgent.split(/[(;]/)[1];\n        if(jquery_default.a.inArray(curDevice,isTouchArr)>=0) {\n            me.flagUsePreciseCursor=true;\n            me.initCursor();\n        }\n\n        // Configure mouse events for desktop computers\n        me.canvas.onmousedown = me.mousedown;\n        me.canvas.onmousemove = me.mousemove;\n        me.canvas.onmouseup = me.mouseup;\n\n        // Connect event to respond to window resizing\n        jquery_default()(window).resize(function() {\n            me.resizeWindow();\n        });\n\n        // get pointer to progress div\n        me.progress=jquery_default()("a.download_MRI");\n\n        // Init the toolbar\n        // configure and append tools\n        let svg, tools;\n\n        if(typeof me.useFullTools === \'undefined\') {\n            me.useFullTools = true;\n        }\n        if(me.useFullTools) {\n            tools = me.html.toolsFull;\n        } else {\n            tools = me.html.toolsLight;\n        }\n\n        for(svg in me.svg) {\n            tools = tools.replace(\n                new RegExp(\'/img/\' + svg + \'.svg\', \'g\'),\n                \'data:image/svg+xml;utf8,\' + me.svg[svg]\n            );\n            console.log(svg);\n        }\n        me.container.append(tools);\n        // intercept keyboard events\n        jquery_default()(document).keydown(function(e){me.keyDown(e)});\n        // configure annotation tools\n        jquery_default()("#tools-minimized").click(function(){me.changeToolbarDisplay("maximize")});\n        me.push(jquery_default()(".push#display-minimize"),function(){me.changeToolbarDisplay("minimize")});\n        me.push(jquery_default()(".push#display-left"),function(){me.changeToolbarDisplay("left")});\n        me.push(jquery_default()(".push#display-right"),function(){me.changeToolbarDisplay("right")});\n        me.slider(jquery_default()(".slider#slice"),function(x){me.changeSlice(Math.round(x))});\n        me.chose(jquery_default()(".chose#plane"),me.changeView);\n        me.chose(jquery_default()(".chose#paintTool"),me.changeTool);\n        me.chose(jquery_default()(".chose#penSize"),me.changePenSize);\n        me.toggle(jquery_default()(".toggle#precise"),me.togglePreciseCursor);\n        me.toggle(jquery_default()(".toggle#fill"),me.toggleFill);\n        me.toggle(jquery_default()(".toggle#fullscreen"),me.toggleFullscreen);\n        me.toggle(jquery_default()(".toggle#bubble"),me.toggleChat);\n        me.push(jquery_default()(".push#3drender"),me.render3D);\n        me.push(jquery_default()(".push#link"),me.link);\n        me.push(jquery_default()(".push#upload"),me.upload);\n        me.push(jquery_default()(".push#download"),me.download);\n        me.push(jquery_default()(".push#color"),me.color);\n        me.push(jquery_default()(".push#undo"),me.sendUndoMessage);\n        me.push(jquery_default()(".push#save"),me.sendSaveMessage);\n        me.push(jquery_default()(".push#prev"),me.prevSlice);\n        me.push(jquery_default()(".push#next"),me.nextSlice);\n\n        // connect chat message input\n        jquery_default()("#msg").keypress(function keypress_fromInitAtlasMaker(e) {me.onkey(e)});\n\n        jquery_default()("#tools-minimized").hide();\n\n        let pr = new Promise(function(resolve, reject) {\n            me.initSocketConnection()\n            .then( () => {\n                resolve();\n            })\n            .catch( (err) => {\n                reject();\n                console.error("ERROR:",err);\n            });\n        });\n\n        return pr;\n    },\n    /**\n     * @function configureAtlasMaker\n     */\n    configureAtlasMaker: function configureAtlasMaker(info, index) {\n        var me=atlasmaker_AtlasMakerWidget;\n        var l=me.traceLog(configureAtlasMaker,0,"#bbd");if(l)console.log.apply(undefined,l);\n\n        var pr = new Promise(function(resolve, reject) {\n            me.configureMRI(info,index)\n            .then(info2 => {\n                var pr2 = new Promise(function(resolve2, reject2) {\n                    info = info2;\n                    jquery_default.a.getJSON(me.hostname + "/labels/"+info.mri.atlas[index].labels)\n                    .then(function(data) {\n                        resolve2(data);\n                    })\n                    .catch(err2 => {\n                        console.log("ERROR:",err2);\n                        reject2(err2);\n                    });\n                });\n                \n                return pr2;\n            })\n            .then(function from_configureAtlasMaker(data) {\n                me.configureOntology(data);\n                me.User.penValue=me.ontology.labels[0].value;\n\n                if(me.fullscreen==true) { // WARNING: HACK... would be better to implement enter/exit fullscreen\n                    me.fullscreen=false;\n                    me.toggleFullscreen();\n                }\n        \n                if(me.User.view!=null) {\n                    jquery_default()(".chose#plane .a").removeClass("pressed");\n                    var view=me.User.view.charAt(0).toUpperCase()+me.User.view.slice(1);\n                    jquery_default()(".chose#plane .a:contains(\'"+view+"\')").addClass("pressed");\n                }\n\n                me.sendUserDataMessage("allUserData");\n                me.sendUserDataMessage("sendAtlas");\n\n                me.changePenColor( 0 );\n                resolve(info);\n            })\n            .catch( (err) => {\n                console.log("ERROR:",err);\n                reject(err);\n            });\n        });\n\n        return pr;\n    },\n    /**\n     * @function configureOntology\n     */\n    configureOntology: function configureOntology(json) {\n        var me=atlasmaker_AtlasMakerWidget;\n        var l=me.traceLog(configureOntology,0,"#bbd");if(l)console.log.apply(undefined,l);\n\n        me.ontology=json\n        me.ontology.valueToIndex=[];\n        me.ontology.labels.forEach(function(o,i){me.ontology.valueToIndex[o.value]=i});\n        // to clear the region name being displayed on the info text-layer when having used eyedrop\n        delete me.info.region;\n    },\n    /**\n     * @function requestMRIInfo\n     * @desc Request to download an MRI, with polling to prevent hangouts on lengthy\n     *       downloads\n     */\n    requestMRIInfo: function requestMRIInfo(source) {\n        var me=atlasmaker_AtlasMakerWidget;\n        var l=me.traceLog(requestMRIInfo,0,"#bbd");if(l)console.log.apply(undefined,l);\n\n        jquery_default()("#loadingIndicator p").text("Loading... ");\n        var pr = new Promise(function(resolve, reject) {\n            var timer = setInterval( function () {\n                console.log("polling for data...");\n                jquery_default.a.post(me.hostname + "/mri/json",{url:source}, function(info) {\n                    if(info.success == true) {\n                        console.log(\'requestMRIInfo promise resolved\');\n                        clearInterval(timer);\n                        resolve(info);\n                    \n                        return;\n                    } else if(info.success == \'downloading\') {\n                        if(me.User.source != source) {\n                            clearInterval(timer);\n                            reject("ERROR: source changed. Probably no longer requested?");\n\n                            return;\n                        }\n                        jquery_default()("#loadingIndicator p").text("Loading... "+parseInt(info.cur/info.len*100,10)+"%");\n                    } else {\n                        console.log("ERROR: requestMRIInfo",info);\n                        clearInterval(timer);\n                        reject("ERROR: requestMRIInfo" + info);\n                    }\n                });\n            }, 2000);\n        });\n\n        return pr;\n    },\n    /**\n     * @function configureMRI\n     */\n    configureMRI: function configureMRI(info,index) {\n        var me=atlasmaker_AtlasMakerWidget;\n        var l=me.traceLog(configureMRI,0,"#bbd");if(l)console.log.apply(undefined,l);\n\n        return new Promise(function(resolve, reject) {\n            me.User.source = info.source;\n            me.requestMRIInfo(info.source)\n            .then((info2) => {\n                if(!info.dim) {\n                    // the mri object used to call this function does not have a \'dim\'\n                    // property, indicating that it had not been downloaded at the time of the\n                    // call. Here we merge the fields from info2 that are initialised upon\n                    // download of the mri server-side. The mri field in the original \'info\',\n                    // which contains the newly created text \'annotations\', is conserved\n                    jquery_default.a.extend(true, info, info2);\n                }\n                info2 = info;\n\n                // Get data from AtlasMaker object\n                me.name=info2.name||"Untitled";\n                me.url=info2.url;\n                me.atlasFilename=info2.mri.atlas[index].filename;\n                me.atlasName=info2.mri.atlas[index].name;\n\n                // get local file path from url\n                me.User.dirname=me.url; // TEMPORARY\n                me.User.mri=info2.mri.brain;\n                me.User.specimenName=me.name;\n                me.User.atlasFilename=info2.mri.atlas[index].filename;\n                me.User.isMRILoaded=false;\n\n                // TODO: it\'s silly to have to put vol dim twice...\n                // (first here, once again further down)\n                me.User.dim=info2.dim;\n                me.User.pixdim=info2.pixdim;\n\n                // compute space transformations\n                me.User.v2w=info2.voxel2world;\n                me.User.wori=info2.worldOrigin;\n                me.computeS2VTransformation();\n\n                //me.testS2VTransformation();\n\n                me.flagLoadingImg={loading:false};\n\n                me.brain_img.img=null;\n\n                // get volume dimensions\n                me.brain_dim=info2.dim;\n                if(info2.pixdim)\n                    me.brain_pixdim=info2.pixdim;\n                else\n                    me.brain_pixdim=[1, 1, 1];\n\n                resolve(info2);\n            })\n            .catch(function(err) {\n                console.log("ERROR: DOWNLOAD FAILED", err);\n                reject(err);\n            });\n        });\n    }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdGxhc01ha2VyV2lkZ2V0Ly4vdmlldy9hdGxhc01ha2VyL3NyYy9hdGxhc01ha2VyLWRyYXcuanM/M2NlYSIsIndlYnBhY2s6Ly9BdGxhc01ha2VyV2lkZ2V0Ly4vdmlldy9hdGxhc01ha2VyL3NyYy9hdGxhc01ha2VyLWludGVyYWN0aW9uLmpzP2FkMzAiLCJ3ZWJwYWNrOi8vQXRsYXNNYWtlcldpZGdldC8uL3ZpZXcvYXRsYXNNYWtlci9zcmMvYXRsYXNNYWtlci1pby5qcz8xNzE4Iiwid2VicGFjazovL0F0bGFzTWFrZXJXaWRnZXQvLi92aWV3L2F0bGFzTWFrZXIvc3JjL2F0bGFzTWFrZXItcGFpbnQuanM/ZTFjNCIsIndlYnBhY2s6Ly9BdGxhc01ha2VyV2lkZ2V0Ly4vdmlldy9hdGxhc01ha2VyL3NyYy9hdGxhc01ha2VyLXVpLmpzPzFkMTIiLCJ3ZWJwYWNrOi8vQXRsYXNNYWtlcldpZGdldC8uL3ZpZXcvYXRsYXNNYWtlci9zcmMvYXRsYXNNYWtlci13cy5qcz8wZTNmIiwid2VicGFjazovL0F0bGFzTWFrZXJXaWRnZXQvLi92aWV3L2Rpc3QvYXRsYXNNYWtlci1yZXNvdXJjZXMuanM/MGJlMSIsIndlYnBhY2s6Ly9BdGxhc01ha2VyV2lkZ2V0Ly4vdmlldy9hdGxhc01ha2VyL3NyYy9hdGxhc21ha2VyLmpzPzYyYjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3VCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBLG9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQUMsb0JBQW9CLDhDQUE4QztBQUNuRjtBQUNBLGdCQUFnQixnQkFBQyxvQkFBb0IsOENBQThDO0FBQ25GO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUNBQWlDLDhDQUE4Qzs7QUFFL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxREFBcUQ7QUFDMUY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRCx3QkFBd0Isd0JBQXdCLDhCQUE4Qiw4QkFBOEIsT0FBTztBQUNySyxrREFBa0Qsd0JBQXdCLHdCQUF3Qiw4QkFBOEIsOEJBQThCLE9BQU87QUFDckssa0RBQWtELHdCQUF3Qix3QkFBd0IsOEJBQThCLDhCQUE4QixPQUFPO0FBQ3JLOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBK0MsMENBQTBDOztBQUV6RjtBQUNBLFFBQVEsZ0JBQUMsd0JBQXdCLG1DQUFtQztBQUNwRSxXQUFXLGdCQUFDLHNCQUFzQixnQkFBQztBQUNuQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsZ0JBQUM7QUFDOUIsNkJBQTZCLGdCQUFDO0FBQzlCO0FBQ0EsNkJBQTZCLGdCQUFDO0FBQzlCLDZCQUE2QixnQkFBQztBQUM5QjtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEMsa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBLHFEQUFxRDtBQUNyRCxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyTkE7QUFDc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBLGdCQUFnQixnQkFBQztBQUNqQixnQkFBZ0IsZ0JBQUM7QUFDakI7QUFDQTtBQUNBLGdCQUFnQixnQkFBQztBQUNqQixnQkFBZ0IsZ0JBQUM7QUFDakI7QUFDQTtBQUNBLGdCQUFnQixnQkFBQztBQUNqQjtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFDO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvQkFBb0I7O0FBRW5FO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQUM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msb0JBQW9CO0FBQ25FO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0EsK0NBQStDLDBCQUEwQjtBQUN6RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQSxRQUFRLGdCQUFDLGdCQUFnQixrREFBa0Q7QUFDM0U7QUFDQSwrQ0FBK0MsNEJBQTRCO0FBQzNFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBLCtDQUErQyxzQkFBc0I7O0FBRXJFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7O0FBRTlDLGNBQWMsZ0JBQUM7QUFDZjtBQUNBO0FBQ0EsY0FBYyxnQkFBQztBQUNmLFlBQVksZ0JBQUM7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7O0FBRTlDLGdCQUFnQixnQkFBQztBQUNqQixjQUFjLGdCQUFDO0FBQ2Y7QUFDQTtBQUNBLGNBQWMsZ0JBQUM7QUFDZixZQUFZLGdCQUFDO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBLCtDQUErQyx3QkFBd0I7QUFDdkUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DLFFBQVEsZ0JBQUM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGdCQUFDO0FBQ3ZCLHVCQUF1QiwrRkFBK0Y7QUFDdEgsWUFBWSxnQkFBQzs7QUFFYjtBQUNBO0FBQ0EsWUFBWSxnQkFBQztBQUNiLFlBQVksZ0JBQUM7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGdCQUFDOztBQUViO0FBQ0EsWUFBWSxnQkFBQztBQUNiO0FBQ0EsWUFBWSxnQkFBQztBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQyxnQkFBZ0IsZ0JBQUM7QUFDakI7QUFDQSxRQUFRLGdCQUFDO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDLFFBQVEsZ0JBQUM7QUFDVCxRQUFRLGdCQUFDOztBQUVULGdCQUFnQixnQkFBQztBQUNqQixRQUFRLGdCQUFDO0FBQ1QsUUFBUSxnQkFBQztBQUNULG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQSxtQkFBbUIsZ0JBQUM7QUFDcEIscUJBQXFCLGVBQWU7QUFDcEMseUNBQXlDLG9FQUFvRTtBQUM3RztBQUNBO0FBQ0Esa0NBQWtDLGdCQUFDO0FBQ25DLGdCQUFnQixnQkFBQztBQUNqQixhQUFhO0FBQ2IsWUFBWSxnQkFBQztBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DLHlCQUF5QixnQkFBQztBQUMxQix5QkFBeUIsZ0JBQUM7QUFDMUIseUJBQXlCLGdCQUFDO0FBQzFCLHlCQUF5QixnQkFBQzs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxnQkFBQyxpQkFBaUIsZ0hBQWdIOztBQUUxSTtBQUNBLGVBQWUsZ0JBQUM7QUFDaEI7QUFDQSxnQkFBZ0IsZ0JBQUM7O0FBRWpCO0FBQ0EsZ0JBQWdCLGdCQUFDLHdDQUF3QyxpQkFBaUI7QUFDMUUsZ0JBQWdCLGdCQUFDLHNDQUFzQyxlQUFlO0FBQ3RFLGdCQUFnQixnQkFBQyx1Q0FBdUMsZ0JBQWdCOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxnQkFBQyxpQkFBaUIseUNBQXlDO0FBQ3ZFLFNBQVM7QUFDVDtBQUNBLFlBQVksZ0JBQUM7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRCxRQUFRLGdCQUFDO0FBQ1Q7QUFDQSx5QkFBeUIsZ0JBQUMsNkJBQTZCO0FBQ3ZELHlCQUF5QixnQkFBQyw2QkFBNkI7QUFDdkQsOEJBQThCLGdCQUFDLGtDQUFrQztBQUNqRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDOztBQUU5Qzs7QUFFQSx5QkFBeUIsZ0JBQUM7QUFDMUIseUJBQXlCLGdCQUFDO0FBQzFCLHlCQUF5QixnQkFBQztBQUMxQix5QkFBeUIsZ0JBQUM7QUFDMUIsY0FBYyxnQkFBQztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0EseUJBQXlCLGdCQUFDO0FBQzFCLHlCQUF5QixnQkFBQztBQUMxQix5QkFBeUIsZ0JBQUM7QUFDMUIseUJBQXlCLGdCQUFDO0FBQzFCLGNBQWMsZ0JBQUM7QUFDZjtBQUNBOztBQUVBLFFBQVEsZ0JBQUM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQzs7QUFFQSx5QkFBeUIsZ0JBQUM7QUFDMUIseUJBQXlCLGdCQUFDO0FBQzFCLHlCQUF5QixnQkFBQztBQUMxQix5QkFBeUIsZ0JBQUM7QUFDMUIsY0FBYyxnQkFBQztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBQztBQUN4Qix1QkFBdUIsZ0JBQUM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5QixnQkFBQztBQUMxQix5QkFBeUIsZ0JBQUM7QUFDMUIseUJBQXlCLGdCQUFDO0FBQzFCLHlCQUF5QixnQkFBQztBQUMxQixjQUFjLGdCQUFDO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQUMsaUJBQWlCLGtHQUFrRztBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBQyxvQkFBb0IsK0JBQStCOztBQUVoRTtBQUNBO0FBQ0EsU0FBUztBQUNULFlBQVksZ0JBQUM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsbUJBQW1CO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxtQkFBbUI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsbUJBQW1CO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLG9CQUFvQjs7QUFFbkU7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDOztBQUVBLDBCQUEwQixnQkFBQztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0Esb0JBQW9CLGdCQUFDO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMvMEJBO0FBQ3NCO0FBQzhCOztBQUVwRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsb0RBQW9EO0FBQ3BELG9EQUFvRDtBQUNwRCxvREFBb0Q7QUFDcEQsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsb0RBQW9EO0FBQ3BELG9EQUFvRDtBQUNwRCxvREFBb0Q7QUFDcEQsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBLHlCQUF5QjtBQUN6QiwrQkFBK0I7QUFDL0IsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQSxnQkFBZ0IsY0FBYztBQUM5Qjs7QUFFQSxzQkFBc0IsbUJBQVksRUFBRSxVQUFVO0FBQzlDOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7O0FBRUEsUUFBUSxnQkFBQztBQUNULFFBQVEsZ0JBQUM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkQ7QUFDQSw0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUyxvQkFBb0IsbUNBQW1DLFNBQVM7QUFDekYsZ0JBQWdCLFNBQVMsb0JBQW9CLG1DQUFtQyxTQUFTO0FBQ3pGLGdCQUFnQixTQUFTLG9CQUFvQixtQ0FBbUMsU0FBUztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEU7O0FDL2JBO0FBQ3NCOztBQUV0QjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFDO0FBQ3ZDLDhEQUE4RCxZQUFZLGtCQUFrQixpQkFBaUIsa0JBQWtCO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFDO0FBQ3pCO0FBQ0EscUNBQXFDLE9BQU8sZ0JBQUMsd0NBQXdDLGdCQUFDLG1DQUFtQztBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxrQ0FBa0MsZ0JBQUM7QUFDbkMsMERBQTBELFlBQVksa0JBQWtCLGlCQUFpQixrQkFBa0I7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQUM7QUFDckI7QUFDQSxpQ0FBaUMsT0FBTyxnQkFBQyx3Q0FBd0MsZ0JBQUMsbUNBQW1DO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7O0FBRTFEO0FBQ0E7O0FBRUEsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0Isc0NBQXNDO0FBQ3RELGdCQUFnQixzQ0FBc0M7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNDQUFzQztBQUMxRCxvQkFBb0Isc0NBQXNDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE1BQU0sbUJBQW1CLE1BQU07QUFDL0QsZ0NBQWdDLE1BQU0sbUJBQW1CLE1BQU07QUFDL0QsZ0NBQWdDLG1CQUFtQixNQUFNLE1BQU07QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsTUFBTSxtQkFBbUIsTUFBTTtBQUMvRCxnQ0FBZ0MsTUFBTSxtQkFBbUIsTUFBTTtBQUMvRCxnQ0FBZ0MsbUJBQW1CLE1BQU0sTUFBTTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUI7QUFDQTtBQUNBOzs7QUN0U0E7QUFDc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLGdCQUFDO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLGdCQUFnQixnQkFBQztBQUNqQixzQkFBc0IsZ0JBQUM7QUFDdkI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFDO0FBQ3JCLHNCQUFzQixnQkFBQztBQUN2Qiw0QkFBNEIsZ0JBQUM7QUFDN0Isb0JBQW9CLGdCQUFDO0FBQ3JCLG9CQUFvQixnQkFBQztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0JBQUMsbURBQW1ELHdCQUF3QjtBQUNwRixRQUFRLGdCQUFDLG1EQUFtRCxzREFBc0QsRTtBQUNsSCxRQUFRLGdCQUFDLHdEQUF3RCxnQkFBQyxhQUFhLFdBQVcsRUFBRTtBQUM1RixRQUFRLGdCQUFDLHdEQUF3RCxnQkFBQyxhQUFhLFVBQVUsRUFBRTtBQUMzRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQUM7QUFDaEI7QUFDQSxZQUFZLGdCQUFDO0FBQ2IsbUJBQW1CLGdCQUFDO0FBQ3BCLDZCQUE2QixnQkFBQztBQUM5QjtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFDLDhCQUE4QjtBQUNsRSxnQkFBZ0IsZ0JBQUM7QUFDakI7QUFDQSw2QkFBNkIsZ0JBQUM7QUFDOUIsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0JBQUM7QUFDVCxZQUFZLGdCQUFDLDJCQUEyQixnQkFBQyw4QkFBOEIsZ0JBQUM7QUFDeEU7QUFDQSx5QkFBeUIsZ0JBQUM7QUFDMUIsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBQztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxFOztBQy9FQTtBQUNzQjtBQUM4Qjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQ7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQUM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUVBQXVFO0FBQ3ZFLHdFQUF3RTs7QUFFeEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBQztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsNENBQTRDLGdCQUFDO0FBQzdDLHlDQUF5QztBQUN6QyxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCLGdDQUFnQyxnQkFBQztBQUNqQztBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7O0FBRUE7QUFDQSxxREFBcUQsR0FBRztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBQztBQUNqQjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLG1CQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGdCQUFDO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEOztBQUUvRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFDO0FBQ2pCLGdCQUFnQixnQkFBQyxtQkFBbUIsZ0JBQUM7QUFDckMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0JBQUM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBLHFDQUFxQyxnQkFBQztBQUN0QztBQUNBLDJDQUEyQywyREFBMkQ7QUFDdEc7QUFDQSxZQUFZLGdCQUFDO0FBQ2IsWUFBWSxnQkFBQyxtQkFBbUIsZ0JBQUM7QUFDakMsWUFBWSxnQkFBQztBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBQztBQUNULFFBQVEsZ0JBQUMsbUJBQW1CLGdCQUFDO0FBQzdCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU8sNkJBQTZCLGtCQUFrQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxzQkFBc0I7QUFDakUsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEOztBQUV4RDtBQUNBLHVCQUF1QjtBQUN2QixvQkFBb0I7QUFDcEIsOEJBQThCO0FBQzlCLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU8sNEJBQTRCLFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMscUJBQXFCO0FBQ2hFLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQSx1QkFBdUI7QUFDdkIsb0JBQW9CO0FBQ3BCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDs7QUFFOUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsbUJBQW1CLE9BQU87QUFDckUsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFlBQVk7QUFDdkQsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDs7QUFFMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0QsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLFFBQVEsZ0JBQUM7QUFDVCxRQUFRLGdCQUFDO0FBQ1QsUUFBUSxnQkFBQyxtQkFBbUIsZ0JBQUM7QUFDN0IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0Esb0JBQW9CLGdCQUFDO0FBQ3JCLFFBQVEsZ0JBQUM7QUFDVCw4QkFBOEIsZ0JBQUMsd0JBQXdCO0FBQ3ZELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsWUFBWSxnQkFBQztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsQzs7QUN4bkJPO0FBQ1A7QUFDQSxnRUFBZ0Usa0JBQWtCLFNBQVMsT0FBTyxhQUFhLG9HQUFvRywwSEFBMEgsa0JBQWtCLGlCQUFpQiwrQkFBK0IsWUFBWSxtR0FBbUcsT0FBTyxRQUFRLFdBQVcsMEJBQTBCLHVIQUF1SCxtQkFBbUIsa0JBQWtCLE9BQU8sUUFBUSxXQUFXLFlBQVksc0JBQXNCLG9KQUFvSix3SEFBd0gsa0JBQWtCLGlCQUFpQiwrQkFBK0IsWUFBWSxtR0FBbUcsT0FBTyxRQUFRLFdBQVcsMEJBQTBCLHVIQUF1SCxtQkFBbUIsa0JBQWtCLE9BQU8sUUFBUSxXQUFXLFlBQVksc0JBQXNCLHVKQUF1Six3SEFBd0gsa0JBQWtCLGlCQUFpQiwrQkFBK0IsWUFBWSxtR0FBbUcsT0FBTyxRQUFRLFdBQVcsMEJBQTBCLHVIQUF1SCxtQkFBbUIsa0JBQWtCLE9BQU8sUUFBUSxXQUFXLFlBQVksc0JBQXNCLHdLQUF3Syw2Q0FBNkMsMERBQTBELGdEQUFnRCw0Q0FBNEMsV0FBVyxFQUFFLHdDQUF3QyxlQUFlLEVBQUUsc0ZBQXNGLDhGQUE4RiwyQ0FBMkMsd0RBQXdELHdDQUF3Qyx1REFBdUQsZ0NBQWdDLG1KQUFtSixFQUFFLFdBQVcsRUFBRSxzQ0FBc0MsZUFBZSxFQUFFLG9EQUFvRCw0RkFBNEYsMkNBQTJDLHdEQUF3RCxxRUFBcUUsOEJBQThCLGdDQUFnQyxtSkFBbUosRUFBRSxXQUFXLEVBQUUsc0NBQXNDLGVBQWUsRUFBRSxvREFBb0QscUVBQXFFLG9EQUFvRCwyREFBMkQsdURBQXVELDJGQUEyRiw2RkFBNkYsZ0RBQWdELDBDQUEwQyxtQkFBbUIsZUFBZSxFQUFFLFdBQVcsRUFBRSxtRUFBbUUseUNBQXlDLEVBQUU7QUFDOTlJLGlKQUFpSixrQkFBa0IsU0FBUyxtSEFBbUgsc0JBQXNCLDBIQUEwSCxtK0JBQW0rQix1REFBdUQsNkhBQTZILFlBQVksaUJBQWlCLG1HQUFtRyxPQUFPLFFBQVEsV0FBVywwQkFBMEIsVUFBVSxzR0FBc0csT0FBTyxRQUFRLGlDQUFpQyxtQkFBbUIsVUFBVSxXQUFXLFlBQVksZ0JBQWdCLDhZQUE4WSwrREFBK0QsdWtEQUF1a0QscWlDQUFxaUMscXdDQUFxd0Msa0JBQWtCLHFFQUFxRSxhQUFhLDRLQUE0SyxvREFBb0Qsa1pBQWtaO0FBQ2wvTixrSkFBa0osa0JBQWtCLFNBQVMsdUhBQXVILHNCQUFzQix3SEFBd0gsdStCQUF1K0IsdURBQXVELDZIQUE2SCxZQUFZLGlCQUFpQixtR0FBbUcsT0FBTyxRQUFRLFdBQVcsMEJBQTBCLFVBQVUsc0dBQXNHLE9BQU8sUUFBUSxpQ0FBaUMsbUJBQW1CLFVBQVUsV0FBVyxZQUFZLGdCQUFnQiw4WUFBOFksK0RBQStELHdjQUF3Yyx3bUJBQXdtQjtBQUNsK0csR0FBRztBQUNIO0FBQ0EsZ0lBQWdJLHlCQUF5Qiw0QkFBNEIsa0JBQWtCLGtCQUFrQixpQkFBaUIsbUdBQW1HLDBDQUEwQyx1Q0FBdUMsR0FBRyxjQUFjLHlCQUF5QixHQUFHLGVBQWUseUJBQXlCLGlCQUFpQixnQkFBZ0IsaUJBQWlCLGtCQUFrQixpQkFBaUIsNkJBQTZCLG1CQUFtQiwyQkFBMkIsR0FBRyxpQkFBaUIseUJBQXlCLGlCQUFpQixnQkFBZ0IsaUJBQWlCLGtCQUFrQixpQkFBaUIsMkJBQTJCLEdBQUcsV0FBVyxpQkFBaUIsa0JBQWtCLDZCQUE2QixrQkFBa0Isc0NBQXNDLHdFQUF3RSxtRUFBbUUsZ0ZBQWdGLDZEQUE2RCwrREFBK0QsbUVBQW1FLG1GQUFtRiwwQkFBMEIsZUFBZSxpQkFBaUIsd0JBQXdCLDBCQUEwQixHQUFHLCtEQUErRCwwQkFBMEIsR0FBRyxzQ0FBc0MscUJBQXFCLGNBQWMsZUFBZSxvQ0FBb0MsMENBQTBDLGtCQUFrQixpQkFBaUIsR0FBRyxzQ0FBc0MscUJBQXFCLGNBQWMsa0JBQWtCLGtCQUFrQixpQkFBaUIsR0FBRyxnRUFBZ0UsY0FBYyxHQUFHLGlFQUFpRSxlQUFlLEdBQUcsZ0VBQWdFLHdCQUF3QixHQUFHLGlFQUFpRSx1QkFBdUIsR0FBRyxzQ0FBc0MsMkJBQTJCLGlCQUFpQixrQkFBa0IsOEJBQThCLHlCQUF5Qiw0QkFBNEIscUJBQXFCLG1CQUFtQixzQkFBc0IsR0FBRyx5RUFBeUUsYUFBYSxjQUFjLEdBQUcsMEVBQTBFLGFBQWEsZUFBZSxHQUFHLGtCQUFrQixvQkFBb0IsR0FBRyx1Q0FBdUMscUJBQXFCLEdBQUcsVUFBVSw4QkFBOEIsMkJBQTJCLHNCQUFzQixHQUFHLGdCQUFnQix3QkFBd0IsR0FBRyxtQkFBbUIsa0JBQWtCLEdBQUcsK0VBQStFLDZCQUE2Qix5QkFBeUIsMEJBQTBCLEdBQUcsZ0NBQWdDLG9CQUFvQixHQUFHLGFBQWEsMkJBQTJCLHdCQUF3QixnQkFBZ0IsaUJBQWlCLDhCQUE4QixnQkFBZ0IsaUJBQWlCLEdBQUcsV0FBVyxtQkFBbUIsR0FBRyx5QkFBeUIsbUJBQW1CLEdBQUcsa0NBQWtDLHdCQUF3QixnQkFBZ0IsaUJBQWlCLGlCQUFpQixrQkFBa0IseUJBQXlCLHVCQUF1Qix3QkFBd0IscUJBQXFCLEdBQUcsZ0JBQWdCLDBCQUEwQixHQUFHLGdCQUFnQix5QkFBeUIsR0FBRyxxQkFBcUIsMEJBQTBCLEdBQUcsbURBQW1ELHNCQUFzQixxQkFBcUIsc0JBQXNCLEdBQUcsUUFBUSxtQkFBbUIsR0FBRywwREFBMEQsbUJBQW1CLHNCQUFzQixxQkFBcUIsY0FBYyxlQUFlLGlCQUFpQixrQkFBa0Isc0JBQXNCLDRCQUE0QixpQkFBaUIsR0FBRyxnQkFBZ0IsNEJBQTRCLGlCQUFpQiwyQkFBMkIsaUJBQWlCLGtCQUFrQixrQ0FBa0MsR0FBRyxtQkFBbUIsbUJBQW1CLEdBQUcsZUFBZSxtQkFBbUIscUJBQXFCLHVCQUF1QixJQUFJO0FBQ3Y5SSwyRUFBMkUsVUFBVSxXQUFXLFdBQVcsV0FBVyxZQUFZLFdBQVcsR0FBRyxxQkFBcUIsbUJBQW1CLHdCQUF3QixhQUFhLFlBQVksaUJBQWlCLGtCQUFrQixpQ0FBaUMsR0FBRywyQkFBMkIsd0JBQXdCLGVBQWUsc0NBQXNDLGdCQUFnQixpQkFBaUIsd0JBQXdCLHVCQUF1QixzQ0FBc0MscUNBQXFDLGtEQUFrRCxxREFBcUQsOEJBQThCLDZCQUE2QiwwQ0FBMEMsNkNBQTZDLEdBQUc7QUFDL3lCLDhJQUE4SSw2QkFBNkIsR0FBRyxNQUFNLDZCQUE2Qix3QkFBd0IsaUJBQWlCLHdCQUF3QixtQkFBbUIseUJBQXlCLG1CQUFtQix3QkFBd0IsR0FBRyxZQUFZLGtCQUFrQiwrQkFBK0IsNEJBQTRCLHVCQUF1QixHQUFHLFVBQVUsbUJBQW1CLHdCQUF3QixHQUFHLFlBQVksdUNBQXVDLEdBQUcsU0FBUyxpQkFBaUIsNEJBQTRCLHdCQUF3QixHQUFHLDZEQUE2RCw0QkFBNEIsd0JBQXdCLGlCQUFpQix3QkFBd0IsOEJBQThCLHNCQUFzQixHQUFHLFVBQVUsd0JBQXdCLHNCQUFzQixpQkFBaUIsR0FBRyxhQUFhLG1CQUFtQix3QkFBd0Isa0JBQWtCLHVCQUF1QixHQUFHLGNBQWMsbUJBQW1CLG9CQUFvQixxQkFBcUIsNEJBQTRCLHFCQUFxQixHQUFHLG9CQUFvQixrQkFBa0IsR0FBRyxZQUFZLGlCQUFpQixrQkFBa0IseUJBQXlCLGNBQWMsZUFBZSxzQ0FBc0MscUJBQXFCLEdBQUcsZUFBZSxtQkFBbUIsR0FBRyxpQkFBaUIsa0JBQWtCLHNCQUFzQixnREFBZ0QsK0JBQStCLDRCQUE0Qix1QkFBdUIsb0JBQW9CLHNCQUFzQixHQUFHO0FBQ3RuRCxHQUFHO0FBQ0g7QUFDQSx5dkRBQXl2RCxlQUFlLGtCQUFrQixvUUFBb1Esd0JBQXdCLGtCQUFrQiwwTkFBME4sd0JBQXdCLGtCQUFrQixrVUFBa1UsZUFBZSx3QkFBd0Isb0JBQW9CLHNCQUFzQixvQkFBb0Isc0JBQXNCO0FBQ3p3Rixzb0RBQXNvRDtBQUN0b0Qsa25DQUFrbkMsZUFBZSx5R0FBeUcsZUFBZSwwc0NBQTBzQyw4QkFBOEIsZUFBZSxrQkFBa0IsZUFBZSxvQkFBb0IscUJBQXFCLHNCQUFzQixvQkFBb0Isc0JBQXNCLDZCQUE2QjtBQUN2cEYsdWxEQUF1bEQsMGRBQTBkLDZjQUE2YztBQUM5L0UsbTFEQUFtMUQ7QUFDbjFELHMxREFBczFEO0FBQ3QxRCxrd0JBQWt3QixrL0JBQWsvQixtRUFBbUUsa3JDQUFrckMsb3NDQUFvc0M7QUFDN3FJLHN3QkFBc3dCLHlpRUFBeWlFLGlEQUFpRCxhQUFhLGVBQWUsWUFBWSxnQkFBZ0Isc0JBQXNCLG9CQUFvQixzQkFBc0IsNkJBQTZCO0FBQ3IvRix3b0VBQXdvRTtBQUN4b0UsczBFQUFzMEUsYUFBYSxlQUFlLGtCQUFrQixZQUFZLHdCQUF3QixxQkFBcUIsc0JBQXNCLG9CQUFvQixzQkFBc0IsNkJBQTZCLHNuQkFBc25CLGFBQWEsZUFBZSxrQkFBa0IsWUFBWSx3QkFBd0IscUJBQXFCLHNCQUFzQixvQkFBb0Isc0JBQXNCLDZCQUE2QixxWkFBcVosZUFBZSxrQkFBa0IsWUFBWSxpQkFBaUIsb0JBQW9CLHNCQUFzQiw2ZkFBNmYsZUFBZSxrQkFBa0IsWUFBWSxpQkFBaUIsb0JBQW9CLHNCQUFzQjtBQUN0Nkksa3dCQUFrd0IsMGtDQUEwa0MsZUFBZSxrQkFBa0IsZUFBZSwwQkFBMEIsb0JBQW9CLHNCQUFzQjtBQUNoOEQsczdFQUFzN0U7QUFDdDdFLDJrR0FBMmtHO0FBQzNrRyxtaklBQW1qSTtBQUNuakksbXdCQUFtd0IsZ2dEQUFnZ0QsZ1hBQWdYO0FBQ25uRiwyd0JBQTJ3Qix3MENBQXcwQyxVQUFVLGVBQWUsZUFBZSxnQkFBZ0Isc0JBQXNCLG9CQUFvQixzQkFBc0IsNkJBQTZCLDZJQUE2SSxhQUFhLGVBQWUsWUFBWSxnQkFBZ0Isc0JBQXNCLG9CQUFvQixzQkFBc0IsNkJBQTZCO0FBQzFnRixzckRBQXNyRCxrQkFBa0IsZUFBZSxpQkFBaUIsbUJBQW1CLFVBQVUsZUFBZSxzQkFBc0IseUJBQXlCLHNDQUFzQyxvQkFBb0IsZ0JBQWdCLGFBQWEsZUFBZSxrQkFBa0IsZUFBZSx3QkFBd0Isb0JBQW9CLHNCQUFzQixvQkFBb0Isd0NBQXdDLG9CQUFvQixpQkFBaUIsWUFBWSxxQkFBcUIscUJBQXFCLHFCQUFxQixvQkFBb0I7QUFDNXNFLDZyREFBNnJELFVBQVUsZUFBZSxrQkFBa0IsZUFBZSxvQkFBb0IscUJBQXFCLHNCQUFzQixvQkFBb0Isc0JBQXNCLDZCQUE2QiwyTUFBMk0sYUFBYSxlQUFlLGtCQUFrQixZQUFZLHdCQUF3QixxQkFBcUIsc0JBQXNCLG9CQUFvQixzQkFBc0IsNkJBQTZCLHFNQUFxTSxhQUFhLGVBQWUsa0JBQWtCLFlBQVksd0JBQXdCLHFCQUFxQixzQkFBc0Isb0JBQW9CLHNCQUFzQiw2QkFBNkIsc01BQXNNLGFBQWEsZUFBZSxrQkFBa0IsWUFBWSx3QkFBd0IscUJBQXFCLHNCQUFzQixvQkFBb0Isc0JBQXNCLDZCQUE2QixnUEFBZ1AsYUFBYSxlQUFlLGtCQUFrQixZQUFZLHdCQUF3QixxQkFBcUIsc0JBQXNCLG9CQUFvQixzQkFBc0IsNkJBQTZCO0FBQ245RyxrbkVBQWtuRTtBQUNsbkUsMHNEQUEwc0QsYUFBYSxlQUFlLGtCQUFrQixlQUFlLHdCQUF3QixxQkFBcUIsc0JBQXNCLG9CQUFvQixzQkFBc0IsNkJBQTZCLG9KQUFvSixzZ0JBQXNnQjtBQUMzaUYsa3dCQUFrd0IsZ2dDQUFnZ0MsbWpFQUFtakU7QUFDcnpILG93QkFBb3dCLDhzREFBOHNELDJYQUEyWCxhQUFhLGVBQWUsWUFBWSxnQkFBZ0Isc0JBQXNCLG9CQUFvQixzQkFBc0IsNkJBQTZCO0FBQ2wrRjtBQUNBOzs7QUNuQ0E7QUFBQTtBQUNzQjtBQUNHO0FBQzJCOztBQUVBO0FBQ2M7QUFDbEI7QUFDTTtBQUNOO0FBQ0E7O0FBRXVCOztBQUV2RTtBQUNBO0FBQ0E7QUFDTyxJQUFJLDJCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQWdCO0FBQy9CLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQWdCO0FBQy9CLG1EQUFtRDs7QUFFbkQsUUFBUSxnQkFBQyxRQUFRLDJCQUFnQixDQUFDLGNBQWM7QUFDaEQsUUFBUSxnQkFBQyxRQUFRLDJCQUFnQixDQUFDLHFCQUFxQjtBQUN2RCxRQUFRLGdCQUFDLFFBQVEsMkJBQWdCLENBQUMsWUFBWTtBQUM5QyxRQUFRLGdCQUFDLFFBQVEsMkJBQWdCLENBQUMsZUFBZTtBQUNqRCxRQUFRLGdCQUFDLFFBQVEsMkJBQWdCLENBQUMsWUFBWTtBQUM5QyxRQUFRLGdCQUFDLFFBQVEsMkJBQWdCLENBQUMsWUFBWTtBQUM5QyxRQUFRLGdCQUFDLFFBQVEsMkJBQWdCLENBQUMsbUJBQW1COztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsZ0JBQUM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQUM7QUFDMUIsWUFBWSxnQkFBQztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsUUFBUSxnQkFBQzs7QUFFVDtBQUNBLDBCQUEwQjtBQUMxQixvREFBb0Q7QUFDcEQsV0FBVyxnQkFBQztBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsZ0JBQUM7QUFDVDtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxvQkFBb0IsZ0JBQUM7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdCQUFDLCtCQUErQixjQUFjO0FBQ3REO0FBQ0EsUUFBUSxnQkFBQyxzQ0FBc0Msb0NBQW9DO0FBQ25GLGdCQUFnQixnQkFBQyxzQ0FBc0Msb0NBQW9DO0FBQzNGLGdCQUFnQixnQkFBQyxrQ0FBa0MsZ0NBQWdDO0FBQ25GLGdCQUFnQixnQkFBQyxtQ0FBbUMsaUNBQWlDO0FBQ3JGLGtCQUFrQixnQkFBQyw4QkFBOEIsOEJBQThCO0FBQy9FLGlCQUFpQixnQkFBQztBQUNsQixpQkFBaUIsZ0JBQUM7QUFDbEIsaUJBQWlCLGdCQUFDO0FBQ2xCLGtCQUFrQixnQkFBQztBQUNuQixrQkFBa0IsZ0JBQUM7QUFDbkIsa0JBQWtCLGdCQUFDO0FBQ25CLGtCQUFrQixnQkFBQztBQUNuQixnQkFBZ0IsZ0JBQUM7QUFDakIsZ0JBQWdCLGdCQUFDO0FBQ2pCLGdCQUFnQixnQkFBQztBQUNqQixnQkFBZ0IsZ0JBQUM7QUFDakIsZ0JBQWdCLGdCQUFDO0FBQ2pCLGdCQUFnQixnQkFBQztBQUNqQixnQkFBZ0IsZ0JBQUM7QUFDakIsZ0JBQWdCLGdCQUFDO0FBQ2pCLGdCQUFnQixnQkFBQzs7QUFFakI7QUFDQSxRQUFRLGdCQUFDLDJEQUEyRCxZQUFZOztBQUVoRixRQUFRLGdCQUFDOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQkFBZ0I7QUFDL0Isd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFDO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjs7QUFFakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsZ0JBQUM7QUFDckI7QUFDQSxvQkFBb0IsZ0JBQUM7QUFDckI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQkFBZ0I7QUFDL0Isc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0EsaURBQWlELG9DQUFvQztBQUNyRjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQWdCO0FBQy9CLG1EQUFtRDs7QUFFbkQsUUFBUSxnQkFBQztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBQyxpQ0FBaUMsV0FBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixnQkFBQztBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUFnQjtBQUMvQixpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFDO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQ0FBbUM7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qISBBdGxhc01ha2VyOiBJbWFnZSBEcmF3aW5nICovXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuXG4vKipcbiAqIEBwYWdlIEF0bGFzTWFrZXI6IEltYWdlIERyYXdpbmdcbiAqL1xuXG5leHBvcnQgdmFyIEF0bGFzTWFrZXJEcmF3ID0ge1xuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiByZXNpemVXaW5kb3dcbiAgICAgKi9cbiAgICByZXNpemVXaW5kb3c6IGZ1bmN0aW9uIHJlc2l6ZVdpbmRvdygpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKHJlc2l6ZVdpbmRvdywxKTtpZihsKWNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCxsKTtcblxuICAgICAgICB2YXIgd0g9bWUuY29udGFpbmVyLmhlaWdodCgpO1xuICAgICAgICB2YXIgd1c9bWUuY29udGFpbmVyLndpZHRoKCk7ICAgIFxuICAgICAgICB2YXIgICAgd0FzcGVjdD13Vy93SDtcbiAgICAgICAgdmFyICAgIGJBc3BlY3Q9bWUuYnJhaW5fVyptZS5icmFpbl9XZGltLyhtZS5icmFpbl9IKm1lLmJyYWluX0hkaW0pO1xuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgaWYobWUuZWRpdE1vZGU9PTEpIHtcbiAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIEluIGVkaXQgbW9kZSB3aWR0aCBvciBoZWlnaHQgY2FuIGJlIGZpeGVkIHRvIDEwMCVcbiAgICAgICAgICAgIC8vIGRlcGVuZGluZyBvbiB0aGUgc2xpY2UgYW5kIGNvbnRhaW5lciBhc3BlY3QgcmF0aW9cbiAgICAgICAgICAgIGlmKHdBc3BlY3Q+YkFzcGVjdClcbiAgICAgICAgICAgICAgICAkKCcjcmVzaXphYmxlJykuY3NzKHt3aWR0aDooMTAwKmJBc3BlY3Qvd0FzcGVjdCkrJyUnLGhlaWdodDonMTAwJSd9KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAkKCcjcmVzaXphYmxlJykuY3NzKHt3aWR0aDonMTAwJScsaGVpZ2h0OigxMDAqd0FzcGVjdC9iQXNwZWN0KSsnJSd9KTtcbiAgICAgICAgLypcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEluIGRpc3BsYXkgbW9kZSBzbGljZSB3aWR0aCBpcyBhbHdheXMgZml4ZWQgdG8gMTAwJVxuICAgICAgICAgICAgJCgnI3Jlc2l6YWJsZScpLmNzcyh7d2lkdGg6JzEwMCUnLGhlaWdodDooMTAwKndBc3BlY3QvYkFzcGVjdCkrJyUnfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNsaWNlIGhlaWdodCBjYW5ub3QgYmUgbGFyZ2VyIHRoYW4gd2luZG93J3MgaW5uZXIgaGVpZ2h0OlxuICAgICAgICAgICAgdmFyIHNsaWNlSD1tZS5jb250YWluZXIuaGVpZ2h0KCk7XG4gICAgICAgICAgICB2YXIgd2luZG93SD13aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgICAgICBpZihzbGljZUg+d2luZG93SCkge1xuICAgICAgICAgICAgICAgIHZhciBmPXdpbmRvd0gvc2xpY2VIO1xuICAgICAgICAgICAgICAgICQoJyNyZXNpemFibGUnKS5jc3Moe3dpZHRoOihmKjEwMCkrJyUnLGhlaWdodDpmKigxMDAqd0FzcGVjdC9iQXNwZWN0KSsnJSd9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIGNvbmZpZ3VyZUJyYWluSW1hZ2VcbiAgICAgKi9cbiAgICBjb25maWd1cmVCcmFpbkltYWdlOiBmdW5jdGlvbiBjb25maWd1cmVCcmFpbkltYWdlKCkge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2coY29uZmlndXJlQnJhaW5JbWFnZSk7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG4gICAgXG4gICAgICAgIGlmKG1lLlVzZXIudmlldz09bnVsbClcbiAgICAgICAgICAgIG1lLlVzZXIudmlldz1cInNhZ1wiO1xuICAgICAgICAgICAgXG4gICAgICAgIHZhciBzMnY9bWUuVXNlci5zMnY7XG4gICAgICAgIHN3aXRjaChtZS5Vc2VyLnZpZXcpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NhZyc6ICAgIG1lLmJyYWluX1c9czJ2LnNkaW1bMV07IG1lLmJyYWluX0g9czJ2LnNkaW1bMl07IG1lLmJyYWluX0Q9czJ2LnNkaW1bMF07IG1lLmJyYWluX1dkaW09czJ2LndwaXhkaW1bMV07IG1lLmJyYWluX0hkaW09czJ2LndwaXhkaW1bMl07IGJyZWFrOyAvLyBzYWdpdGFsXG4gICAgICAgICAgICBjYXNlICdjb3InOiAgICBtZS5icmFpbl9XPXMydi5zZGltWzBdOyBtZS5icmFpbl9IPXMydi5zZGltWzJdOyBtZS5icmFpbl9EPXMydi5zZGltWzFdOyBtZS5icmFpbl9XZGltPXMydi53cGl4ZGltWzBdOyBtZS5icmFpbl9IZGltPXMydi53cGl4ZGltWzJdOyBicmVhazsgLy8gY29yb25hbFxuICAgICAgICAgICAgY2FzZSAnYXhpJzogICAgbWUuYnJhaW5fVz1zMnYuc2RpbVswXTsgbWUuYnJhaW5fSD1zMnYuc2RpbVsxXTsgbWUuYnJhaW5fRD1zMnYuc2RpbVsyXTsgbWUuYnJhaW5fV2RpbT1zMnYud3BpeGRpbVswXTsgbWUuYnJhaW5fSGRpbT1zMnYud3BpeGRpbVsxXTsgYnJlYWs7IC8vIGF4aWFsXG4gICAgICAgIH1cblxuICAgICAgICBtZS5jYW52YXMud2lkdGg9bWUuYnJhaW5fVztcbiAgICAgICAgbWUuY2FudmFzLmhlaWdodD1tZS5icmFpbl9IKm1lLmJyYWluX0hkaW0vbWUuYnJhaW5fV2RpbTtcbiAgICAgICAgbWUuYnJhaW5fb2ZmY24ud2lkdGg9bWUuYnJhaW5fVztcbiAgICAgICAgbWUuYnJhaW5fb2ZmY24uaGVpZ2h0PW1lLmJyYWluX0g7XG4gICAgICAgIG1lLmJyYWluX3B4PW1lLmJyYWluX29mZnR4LmdldEltYWdlRGF0YSgwLDAsbWUuYnJhaW5fb2ZmY24ud2lkdGgsbWUuYnJhaW5fb2ZmY24uaGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIGlmKG1lLlVzZXIuc2xpY2U9PW51bGwgfHwgbWUuVXNlci5zbGljZT49bWUuYnJhaW5fRC0xKVxuICAgICAgICAgICAgbWUuVXNlci5zbGljZT1wYXJzZUludChtZS5icmFpbl9ELzIpO1xuXG4gICAgICAgIG1lLnNlbmRVc2VyRGF0YU1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoeyd2aWV3JzptZS5Vc2VyLnZpZXcsJ3NsaWNlJzptZS5Vc2VyLnNsaWNlfSkpO1xuICAgICAgICBcbiAgICAgICAgLy8gY29uZmlndXJlIHRvb2xiYXIgc2xpZGVyXG4gICAgICAgICQoXCIuc2xpZGVyI3NsaWNlXCIpLmRhdGEoe21heDptZS5icmFpbl9ELTEsdmFsOm1lLlVzZXIuc2xpY2V9KTtcbiAgICAgICAgaWYoJChcIiNzbGljZSAudGh1bWJcIilbMF0pICQoXCIjc2xpY2UgLnRodW1iXCIpWzBdLnN0eWxlLmxlZnQ9KG1lLlVzZXIuc2xpY2UvKG1lLmJyYWluX0QtMSkqMTAwKStcIiVcIjtcbiAgICAgICAgbWUuZHJhd0ltYWdlcygpO1xuICAgICAgICBtZS5pbml0Q3Vyc29yKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gY29uZmlndXJlQXRsYXNJbWFnZVxuICAgICAqL1xuICAgIGNvbmZpZ3VyZUF0bGFzSW1hZ2U6IGZ1bmN0aW9uIGNvbmZpZ3VyZUF0bGFzSW1hZ2UoKSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyhjb25maWd1cmVBdGxhc0ltYWdlKTtpZihsKWNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCxsKTtcbiAgICBcbiAgICAgICAgLy8gaGFzIHRvIGJlIHJ1biAqYWZ0ZXIqIGNvbmZpZ3VyZUJyYWluSW1hZ2VcbiAgICAgICAgbWUuYXRsYXNfb2ZmY24ud2lkdGg9bWUuYnJhaW5fVztcbiAgICAgICAgbWUuYXRsYXNfb2ZmY24uaGVpZ2h0PW1lLmJyYWluX0g7XG4gICAgICAgIG1lLmF0bGFzX3B4PW1lLmF0bGFzX29mZnR4LmdldEltYWdlRGF0YSgwLDAsbWUuYXRsYXNfb2ZmY24ud2lkdGgsbWUuYXRsYXNfb2ZmY24uaGVpZ2h0KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBuZWFyZXN0TmVpZ2hib3VyXG4gICAgICovXG4gICAgbmVhcmVzdE5laWdoYm91cjogZnVuY3Rpb24gbmVhcmVzdE5laWdoYm91cihjdHgpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKG5lYXJlc3ROZWlnaGJvdXIsMSk7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG4gICAgXG4gICAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgY3R4Lm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIGNvbXB1dGVTZWdtZW50ZWRWb2x1bWVcbiAgICAgKi9cbiAgICBjb21wdXRlU2VnbWVudGVkVm9sdW1lOiBmdW5jdGlvbiBjb21wdXRlU2VnbWVudGVkVm9sdW1lKCkge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2coY29tcHV0ZVNlZ21lbnRlZFZvbHVtZSwxKTtpZihsKWNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCxsKTtcblxuICAgICAgICB2YXIgaSxzdW09MDtcbiAgICAgICAgdmFyICAgIGRhdGE9bWUuYXRsYXMuZGF0YTtcbiAgICAgICAgdmFyICAgIGRpbT1tZS5hdGxhcy5kaW07XG5cbiAgICAgICAgZm9yKGk9MDtpPGRpbVswXSpkaW1bMV0qZGltWzJdO2krKykge1xuICAgICAgICAgICAgaWYoZGF0YVtpXT4wKVxuICAgICAgICAgICAgICAgIHN1bSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW0qbWUuVXNlci5waXhkaW1bMF0qbWUuVXNlci5waXhkaW1bMV0qbWUuVXNlci5waXhkaW1bMl07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gZGlzcGxheUluZm9ybWF0aW9uXG4gICAgICogQGRlc2MgT3ZlcmxheXMgdGV4dCBhbmQgdmVjdG9yaWFsIGluZm9ybWF0aW9uIG9uIHRvcCBvZiB0aGUgYW5ub3RhdGlvbiB2b2x1bWUgc2xpY2UuIFRleHQgaW5mb3JtYXRpb24gaXMgYWRkZWQgZnJvbSB0aGUgQXRsYXNNYWtlcldpZGdldC5pbmZvIG9iamVjdC4gVmVjdG9yaWFsIGluZm9ybWF0aW9uIGlzIGRpc3BsYXllZCB1c2luZyBzdmcgZm9ybWF0XG4gICAgICovXG4gICAgZGlzcGxheUluZm9ybWF0aW9uOiBmdW5jdGlvbiBkaXNwbGF5SW5mb3JtYXRpb24oKSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyhkaXNwbGF5SW5mb3JtYXRpb24sMSk7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG4gICAgICAgICAgICBcbiAgICAgICAgbWUuaW5mby5zbGljZT1tZS5Vc2VyLnNsaWNlO1xuICAgICAgICB2YXIgaT0wLHN0cjtcbiAgICAgICAgdmFyIHRleHQ9bWUuY29udGFpbmVyLmZpbmQoXCIjdGV4dC1sYXllclwiKTtcbiAgICAgICAgdmFyIHZlY3Rvcj1tZS5jb250YWluZXIuZmluZChcIiN2ZWN0b3ItbGF5ZXJcIik7XG4gICAgICAgIFxuICAgICAgICBzdHI9XCJcIjtcbiAgICAgICAgZm9yKHZhciBrIGluIG1lLmluZm8pIHtcbiAgICAgICAgICAgIHN0cis9XCI8c3Bhbj5cIitrK1wiOiBcIittZS5pbmZvW2tdK1wiPC9zcGFuPjxici8+XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dC5odG1sKHN0cik7XG4gICAgICAgIFxuICAgICAgICBzdHI9XCJcIjtcbiAgICAgICAgaWYobWUuVXNlci5tZWFzdXJlTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgVz1wYXJzZUZsb2F0KCQoJyNhdGxhc01ha2VyIGNhbnZhcycpLmNzcygnd2lkdGgnKSk7XG4gICAgICAgICAgICB2YXIgdz1wYXJzZUZsb2F0KCQoJyNhdGxhc01ha2VyIGNhbnZhcycpLmF0dHIoJ3dpZHRoJykpO1xuICAgICAgICAgICAgdmFyIHp4PVcvdyx6eT16eCptZS5icmFpbl9IZGltL21lLmJyYWluX1dkaW0scD1tZS5Vc2VyLm1lYXN1cmVMZW5ndGgsc3RyMTtcbiAgICAgICAgICAgIHZhciBXPXBhcnNlRmxvYXQoJCgnI2F0bGFzTWFrZXIgY2FudmFzJykuY3NzKCd3aWR0aCcpKTtcbiAgICAgICAgICAgIHZhciB3PXBhcnNlRmxvYXQoJCgnI2F0bGFzTWFrZXIgY2FudmFzJykuYXR0cignd2lkdGgnKSk7XG4gICAgICAgICAgICBzdHIxPVwiTVwiK3p4KnBbMF0ueCtcIixcIit6eSpwWzBdLnk7XG4gICAgICAgICAgICBmb3IoaT0xO2k8cC5sZW5ndGg7aSsrKVxuICAgICAgICAgICAgICAgIHN0cjErPVwiTFwiK3p4KnBbaV0ueCtcIixcIit6eSpwW2ldLnk7XG4gICAgICAgICAgICBzdHIrPVsgICAgXCI8Y2lyY2xlIGZpbGw9JyMwMGZmMDAnIGN4PVwiK3p4KnBbMF0ueCtcIiBjeT1cIit6eSpwWzBdLnkrXCIgcj0zIC8+XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiPHBhdGggc3Ryb2tlPScjMDBmZjAwJyBmaWxsPSdub25lJyBkPSdcIitzdHIxK1wiJy8+XCIsXG4gICAgICAgICAgICAgICAgICAgIChpPjApP1wiPGNpcmNsZSBmaWxsPScjMDBmZjAwJyBjeD1cIit6eCpwW2ktMV0ueCtcIiBjeT1cIit6eSpwW2ktMV0ueStcIiByPTMgLz5cIjpcIlwiXS5qb2luKFwiXFxuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZlY3Rvci5odG1sKHN0cik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gZHJhd0ltYWdlc1xuICAgICAqL1xuICAgIGRyYXdJbWFnZXM6IGZ1bmN0aW9uIGRyYXdJbWFnZXMoKSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyhkcmF3SW1hZ2VzLDEpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuICAgIFxuICAgICAgICBpZihtZS5icmFpbl9pbWcuaW1nXG4gICAgICAgICAgICYmIG1lLmZsYWdMb2FkaW5nSW1nLnZpZXdcbiAgICAgICAgICAgJiYgbWUuZmxhZ0xvYWRpbmdJbWcuc2xpY2UpIHtcbiAgICAgICAgICAgIG1lLmNvbnRleHQuY2xlYXJSZWN0KDAsMCxtZS5jb250ZXh0LmNhbnZhcy53aWR0aCxtZS5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIG1lLmRpc3BsYXlJbmZvcm1hdGlvbigpO1xuXG4gICAgICAgICAgICBtZS5uZWFyZXN0TmVpZ2hib3VyKG1lLmNvbnRleHQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBtZS5jb250ZXh0LmRyYXdJbWFnZShtZS5icmFpbl9pbWcuaW1nLDAsMCxtZS5icmFpbl9XLG1lLmJyYWluX0gqbWUuYnJhaW5fSGRpbS9tZS5icmFpbl9XZGltKTtcbiAgICAgICAgICAgIG1lLmRyYXdBdGxhc0ltYWdlKG1lLmZsYWdMb2FkaW5nSW1nLnZpZXcsbWUuZmxhZ0xvYWRpbmdJbWcuc2xpY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW1lLmJyYWluX2ltZy5pbWcgfHwgbWUuYnJhaW5faW1nLnZpZXchPW1lLlVzZXIudmlldyB8fCBtZS5icmFpbl9pbWcuc2xpY2UhPW1lLlVzZXIuc2xpY2UpIHtcbiAgICAgICAgICAgIG1lLnNlbmRSZXF1ZXN0U2xpY2VNZXNzYWdlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBkcmF3QXRsYXNJbWFnZVxuICAgICAqL1xuICAgIGRyYXdBdGxhc0ltYWdlOiBmdW5jdGlvbiBkcmF3QXRsYXNJbWFnZSh2aWV3LHNsaWNlKSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyhkcmF3QXRsYXNJbWFnZSwxKTtpZihsKWNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCxsKTtcbiAgICBcbiAgICAgICAgaWYoIW1lLmF0bGFzKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBtZS5hdGxhcy5kYXRhO1xuICAgICAgICBjb25zdCBkaW0gPSBtZS5hdGxhcy5kaW07XG4gICAgICAgIGxldCBpLCBzLCB2YWw7XG5cbiAgICAgICAgbGV0IHgsIHk7XG4gICAgICAgIGxldCB5cz1zbGljZSwgeWM9c2xpY2UsIHlhPXNsaWNlO1xuICAgICAgICBmb3IoeSA9IDA7IHkgPCBtZS5icmFpbl9IOyB5KyspXG4gICAgICAgIGZvcih4ID0gMDsgeCA8IG1lLmJyYWluX1c7IHgrKykge1xuICAgICAgICAgICAgc3dpdGNoKHZpZXcpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzYWcnOnMgPSBbeXMseCxtZS5icmFpbl9ILTEteV07IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Nvcic6cyA9IFt4LHljLG1lLmJyYWluX0gtMS15XTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYXhpJzpzID0gW3gsbWUuYnJhaW5fSC0xLXkseWFdOyBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgPSBtZS5TMkkocyxtZS5Vc2VyKTtcblxuICAgICAgICAgICAgdmFyIGM9bWUub250b2xvZ3lWYWx1ZVRvQ29sb3IoZGF0YVtpXSk7XG4gICAgICAgICAgICB2YXIgYWxwaGE9KGRhdGFbaV0+MCk/MjU1OjA7XG4gICAgICAgICAgICBpID0gKHkqbWUuYXRsYXNfb2ZmY24ud2lkdGgreCkqNDtcbiAgICAgICAgICAgIG1lLmF0bGFzX3B4LmRhdGFbIGkgXSAgPWNbMF07XG4gICAgICAgICAgICBtZS5hdGxhc19weC5kYXRhWyBpKzEgXT1jWzFdO1xuICAgICAgICAgICAgbWUuYXRsYXNfcHguZGF0YVsgaSsyIF09Y1syXTtcbiAgICAgICAgICAgIG1lLmF0bGFzX3B4LmRhdGFbIGkrMyBdPWFscGhhKm1lLmFscGhhTGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgbWUuYXRsYXNfb2ZmdHgucHV0SW1hZ2VEYXRhKG1lLmF0bGFzX3B4LCAwLCAwKTtcblxuICAgICAgICBtZS5uZWFyZXN0TmVpZ2hib3VyKG1lLmNvbnRleHQpO1xuICAgICAgICBtZS5jb250ZXh0LmRyYXdJbWFnZShtZS5hdGxhc19vZmZjbiwwLDAsbWUuYnJhaW5fVyxtZS5icmFpbl9IKm1lLmJyYWluX0hkaW0vbWUuYnJhaW5fV2RpbSk7XG4gICAgfVxufTtcbiIsIi8qISBBdGxhc01ha2VyOiBJbnRlcmFjdGlvbiAqL1xuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuXG4vKipcbiAqIEBwYWdlIEF0bGFzTWFrZXI6IEludGVyYWN0aW9uXG4gKi9cbmV4cG9ydCB2YXIgQXRsYXNNYWtlckludGVyYWN0aW9uID0ge1xuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIExvY2FsIHVzZXIgaW50ZXJhY3Rpb25cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gY2hhbmdlVG9vbGJhckRpc3BsYXlcbiAgICAgKi9cbiAgICBjaGFuZ2VUb29sYmFyRGlzcGxheTogZnVuY3Rpb24gY2hhbmdlVG9vbGJhckRpc3BsYXkoZGlzcGxheSkge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2coY2hhbmdlVG9vbGJhckRpc3BsYXksMCxcIiNmMDBcIik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG4gICAgICAgIFxuICAgICAgICBzd2l0Y2goZGlzcGxheSkge1xuICAgICAgICAgICAgY2FzZSBcIm1pbmltaXplXCI6XG4gICAgICAgICAgICAgICAgJChcIiN0b29scy1tYXhpbWl6ZWRcIikuaGlkZSgpO1xuICAgICAgICAgICAgICAgICQoXCIjdG9vbHMtbWluaW1pemVkXCIpLnNob3coKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtYXhpbWl6ZVwiOlxuICAgICAgICAgICAgICAgICQoXCIjdG9vbHMtbWF4aW1pemVkXCIpLnNob3coKTtcbiAgICAgICAgICAgICAgICAkKFwiI3Rvb2xzLW1pbmltaXplZFwiKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICAgICQoXCJib2R5XCIpLmF0dHIoXCJkYXRhLXRvb2xiYXJEaXNwbGF5XCIsXCJsZWZ0XCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgJChcImJvZHlcIikuYXR0cihcImRhdGEtdG9vbGJhckRpc3BsYXlcIixcInJpZ2h0XCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gY2hhbmdlVmlld1xuICAgICAqL1xuICAgIGNoYW5nZVZpZXc6IGZ1bmN0aW9uIGNoYW5nZVZpZXcodGhlVmlldykge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2coY2hhbmdlVmlldywwLFwiI2YwMFwiKTtpZihsKWNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCxsKTtcbiAgICBcbiAgICAgICAgc3dpdGNoKHRoZVZpZXcpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NhZyc6XG4gICAgICAgICAgICAgICAgbWUuVXNlci52aWV3PSdzYWcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29yJzpcbiAgICAgICAgICAgICAgICBtZS5Vc2VyLnZpZXc9J2Nvcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdheGknOlxuICAgICAgICAgICAgICAgIG1lLlVzZXIudmlldz0nYXhpJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBtZS5zZW5kVXNlckRhdGFNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHsndmlldyc6bWUuVXNlci52aWV3fSkpO1xuICAgIFxuICAgICAgICBtZS5jb25maWd1cmVCcmFpbkltYWdlKCk7XG4gICAgICAgIG1lLmNvbmZpZ3VyZUF0bGFzSW1hZ2UoKTtcbiAgICAgICAgbWUucmVzaXplV2luZG93KCk7XG5cbiAgICAgICAgbWUuZHJhd0ltYWdlcygpO1xuICAgICAgICBcbiAgICAgICAgbWUuaW5pdEN1cnNvcigpO1xuXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gY2hhbmdlVG9vbFxuICAgICAqIEBkZXNjIENoYW5nZSB0aGUgdG9vbCB0aGF0IGRlZmluZXMgdGhlIGVmZmVjdCBvZiBtb3VzZSBjbGlja3NcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGhlVG9vbGUgTmFtZSBvZiB0aGUgdG9vbDogUGFpbnQsIEVyYXNlLCBNZWFzdXJlLCBBZGp1c3RcbiAgICAgKi9cbiAgICBjaGFuZ2VUb29sOiBmdW5jdGlvbiBjaGFuZ2VUb29sKHRoZVRvb2wpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKGNoYW5nZVRvb2wsMCxcIiNmMDBcIik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG4gICAgXG4gICAgICAgIGlmKHRoZVRvb2wudG9Mb3dlckNhc2UoKT09bWUuVXNlci50b29sKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgc3dpdGNoKHRoZVRvb2wpIHtcbiAgICAgICAgICAgIGNhc2UgJ1Nob3cnOlxuICAgICAgICAgICAgICAgIG1lLlVzZXIudG9vbD0nc2hvdyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdQYWludCc6XG4gICAgICAgICAgICAgICAgbWUuVXNlci50b29sPSdwYWludCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdFcmFzZSc6XG4gICAgICAgICAgICAgICAgbWUuVXNlci50b29sPSdlcmFzZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdNZWFzdXJlJzpcbiAgICAgICAgICAgICAgICBtZS5Vc2VyLnRvb2w9J21lYXN1cmUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQWRqdXN0JzpcbiAgICAgICAgICAgICAgICBtZS5Vc2VyLnRvb2w9J2FkanVzdCc7XG4gICAgICAgICAgICAgICAgaWYoJChcIiNhZGp1c3RcIikubGVuZ3RoPT0wKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLmNvbnRhaW5lci5maW5kKFwiI3Jlc2l6YWJsZVwiKS5hcHBlbmQobWUuaHRtbC5hZGp1c3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0V5ZWRyb3AnOlxuICAgICAgICAgICAgICAgIG1lLlVzZXIudG9vbD0nZXllZHJvcCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbWUuc2VuZFVzZXJEYXRhTWVzc2FnZShKU09OLnN0cmluZ2lmeSh7J3Rvb2wnOm1lLlVzZXIudG9vbH0pKTtcbiAgICAgICAgbWUuVXNlci5tZWFzdXJlTGVuZ3RoPW51bGw7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gY2hhbmdlUGVuU2l6ZVxuICAgICAqL1xuICAgIGNoYW5nZVBlblNpemU6IGZ1bmN0aW9uIGNoYW5nZVBlblNpemUodGhlU2l6ZSkge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2coY2hhbmdlUGVuU2l6ZSwwLFwiI2YwMFwiKTtpZihsKWNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCxsKTtcbiAgICBcbiAgICAgICAgbWUuVXNlci5wZW5TaXplPXBhcnNlSW50KHRoZVNpemUpO1xuICAgICAgICBtZS5zZW5kVXNlckRhdGFNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHsncGVuU2l6ZSc6bWUuVXNlci5wZW5TaXplfSkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIGNoYW5nZVBlbkNvbG9yXG4gICAgICovXG4gICAgY2hhbmdlUGVuQ29sb3I6IGZ1bmN0aW9uIGNoYW5nZVBlbkNvbG9yKGluZGV4KSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyhjaGFuZ2VQZW5Db2xvciwwLFwiI2YwMFwiKTtpZihsKWNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCxsKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBjPW1lLm9udG9sb2d5LmxhYmVsc1tpbmRleF0uY29sb3I7XG4gICAgICAgICQoXCIjY29sb3JcIikuY3NzKHtiYWNrZ3JvdW5kQ29sb3I6J3JnYignK2NbMF0rJywnK2NbMV0rJywnK2NbMl0rJyknfSk7XG4gICAgICAgIG1lLlVzZXIucGVuVmFsdWU9bWUub250b2xvZ3kubGFiZWxzW2luZGV4XS52YWx1ZTtcbiAgICAgICAgbWUuc2VuZFVzZXJEYXRhTWVzc2FnZShKU09OLnN0cmluZ2lmeSh7J3BlblZhbHVlJzptZS5Vc2VyLnBlblZhbHVlfSkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIGNoYW5nZVNsaWNlXG4gICAgICovXG4gICAgY2hhbmdlU2xpY2U6IGZ1bmN0aW9uIGNoYW5nZVNsaWNlKHgpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKGNoYW5nZVNsaWNlLDEsXCIjZjAwXCIpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuICAgIFxuICAgICAgICBtZS5Vc2VyLnNsaWNlPXg7XG4gICAgICAgIG1lLnNlbmRVc2VyRGF0YU1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoeydzbGljZSc6bWUuVXNlci5zbGljZX0pKTtcblxuICAgICAgICBtZS5kcmF3SW1hZ2VzKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gcHJldlNsaWNlXG4gICAgICovXG4gICAgcHJldlNsaWNlOiBmdW5jdGlvbiBwcmV2U2xpY2UoKSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyhwcmV2U2xpY2UsMSxcIiNmMDBcIik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG5cbiAgICAgICAgdmFyIHg9JChcIiNzbGljZVwiKS5kYXRhKFwidmFsXCIpLTE7XG4gICAgICAgIGlmKHg8MCkgeD0wO1xuICAgICAgICB4PU1hdGgucm91bmQoeCk7XG4gICAgICAgIGlmKHghPSQoXCIjc2xpY2VcIikuZGF0YShcInZhbFwiKSkge1xuICAgICAgICAgICAgJChcIiNzbGljZVwiKS5kYXRhKFwidmFsXCIseCk7XG4gICAgICAgICAgICBtZS5jaGFuZ2VTbGljZSh4KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIG5leHRTbGljZVxuICAgICAqL1xuICAgIG5leHRTbGljZTogZnVuY3Rpb24gbmV4dFNsaWNlKCkge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2cobmV4dFNsaWNlLDEsXCIjZjAwXCIpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuXG4gICAgICAgIHZhciBtYXg9JChcIiNzbGljZVwiKS5kYXRhKFwibWF4XCIpO1xuICAgICAgICB2YXIgeD0kKFwiI3NsaWNlXCIpLmRhdGEoXCJ2YWxcIikrMTtcbiAgICAgICAgaWYoeD5tYXgpIHg9bWF4O1xuICAgICAgICB4PU1hdGgucm91bmQoeCk7XG4gICAgICAgIGlmKHghPSQoXCIjc2xpY2VcIikuZGF0YShcInZhbFwiKSkge1xuICAgICAgICAgICAgJChcIiNzbGljZVwiKS5kYXRhKFwidmFsXCIseCk7XG4gICAgICAgICAgICBtZS5jaGFuZ2VTbGljZSh4KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIHRvZ2dsZUZpbGxcbiAgICAgKi9cbiAgICB0b2dnbGVGaWxsOiBmdW5jdGlvbiB0b2dnbGVGaWxsKHgpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKHRvZ2dsZUZpbGwsMCxcIiNmMDBcIik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG4gICAgXG4gICAgICAgIG1lLlVzZXIuZG9GaWxsPXg7XG4gICAgICAgIG1lLnNlbmRVc2VyRGF0YU1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoeydkb0ZpbGwnOm1lLlVzZXIuZG9GaWxsfSkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIHRvZ2dsZUNoYXRcbiAgICAgKi9cbiAgICB0b2dnbGVDaGF0OiBmdW5jdGlvbiB0b2dnbGVDaGF0KCkge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2codG9nZ2xlQ2hhdCwwLFwiI2YwMFwiKTtpZihsKWNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCxsKTtcbiAgICBcbiAgICAgICAgJChcIiNjaGF0QmxvY2tcIikudG9nZ2xlKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gdG9nZ2xlRnVsbHNjcmVlblxuICAgICAqL1xuICAgIHRvZ2dsZUZ1bGxzY3JlZW46IGZ1bmN0aW9uIHRvZ2dsZUZ1bGxzY3JlZW4oKSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyh0b2dnbGVGdWxsc2NyZWVuLDAsXCIjZjAwXCIpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuXG4gICAgICAgIGlmKG1lLmZ1bGxzY3JlZW49PWZhbHNlKSB7XG4gICAgICAgICAgICAvLyBFbnRlciBmdWxsc2NyZWVuXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIFxuICAgICAgICAgICAgLy8gYWRkIGJsYWNrIG92ZXJsYXlcbiAgICAgICAgICAgIHZhciBibGFjaz0kKFwiPGRpdiBpZD0nYmxhY2tPdmVybGF5Jz5cIik7XG4gICAgICAgICAgICBibGFjay5jc3Moe3Bvc2l0aW9uOidmaXhlZCcsdG9wOjAsbGVmdDowLHdpZHRoOicxMDAlJyxoZWlnaHQ6JzEwMCUnLCd6LWluZGV4Jzo1LCdiYWNrZ3JvdW5kLWNvbG9yJzonIzIyMid9KTtcbiAgICAgICAgICAgICQoJ2JvZHknKS5hcHBlbmQoYmxhY2spO1xuICAgIFxuICAgICAgICAgICAgLy8gY29uZmlndXJlIGRpc3BsYXkgbW9kZVxuICAgICAgICAgICAgLy8gICAgJChcIiNhdGxhc01ha2VyXCIpLnJlbW92ZUNsYXNzKCdkaXNwbGF5LW1vZGUnKTtcbiAgICAgICAgICAgICQoXCJib2R5XCIpLmFkZENsYXNzKCdhdGxhc01ha2VyLWZ1bGxzY3JlZW4nKTtcbiAgICAgICAgICAgICQoXCIjYXRsYXNNYWtlclwiKS5kZXRhY2goKS5hcHBlbmRUbygnYm9keScpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyAgICBtZS5lZGl0TW9kZT0xO1xuICAgICAgICAgICAgbWUucmVzaXplV2luZG93KCk7XG4gICAgXG4gICAgICAgICAgICAvLyBjb25maWd1cmUgdG9vbGJhciBmb3IgZWRpdCBtb2RlXG4gICAgICAgICAgICAvLyQoXCIjbG9nXCIpLm91dGVySGVpZ2h0KCQoXCIjdG9vbHMtc2lkZVwiKS5vdXRlckhlaWdodCgpLSQoXCIjbG9nXCIpLm9mZnNldCgpLnRvcC0kKFwiI21zZ1wiKS5jbG9zZXN0KFwidHJcIikub3V0ZXJIZWlnaHQoKSk7XG4gICAgICAgICAgICBtZS5mdWxsc2NyZWVuPXRydWU7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIEV4aXQgZnVsbHNjcmVlblxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIFxuICAgICAgICAgICAgLy8gcmVtb3ZlIGJsYWNrIG92ZXJsYXlcbiAgICAgICAgICAgICQoXCIjYmxhY2tPdmVybGF5XCIpLnJlbW92ZSgpO1xuICAgIFxuICAgICAgICAgICAgLy8gZ28gYmFjayB0byBkaXNwbGF5IG1vZGVcbiAgICAgICAgICAgICQoXCJib2R5XCIpLnJlbW92ZUNsYXNzKCdhdGxhc01ha2VyLWZ1bGxzY3JlZW4nKTtcbiAgICAgICAgICAgIC8vICAgICQoXCIjYXRsYXNNYWtlclwiKS5hZGRDbGFzcygnZGlzcGxheS1tb2RlJyk7XG4gICAgICAgICAgICAkKFwiI2F0bGFzTWFrZXJcIikuZGV0YWNoKCkuYXBwZW5kVG8oJyNzdGVyZW90YXhpYycpO1xuICAgICAgICAgICAgLy8gICAgbWUuZWRpdE1vZGU9MDtcbiAgICAgICAgICAgIG1lLnJlc2l6ZVdpbmRvdygpO1xuXG4gICAgICAgICAgICBtZS5mdWxsc2NyZWVuPWZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gcmVuZGVyM0RcbiAgICAgKi9cbiAgICByZW5kZXIzRDogZnVuY3Rpb24gcmVuZGVyM0QoKSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyhyZW5kZXIzRCwwLFwiI2YwMFwiKTtpZihsKWNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCxsKTtcbiAgICAgICAgXG4gICAgICAgIC8vIHB1dHMgYSBmcmVzaCB2ZXJzaW9uIG9mIHRoZSBzZWdtZW50YXRpb24gaW4gbG9jYWxTdG9yYWdlXG4gICAgICAgIGxvY2FsU3RvcmFnZS5icmFpbmJveD1VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFttZS5lbmNvZGVOaWZ0aSgpXSkpO1xuICAgICAgICBcbiAgICAgICAgLy8gb3BlbnMgM2QgcmVuZGVyIHdpbmRvd1xuICAgICAgICB3aW5kb3cub3BlbihtZS5ob3N0bmFtZSArIFwiL3N1cmZhY2UuaHRtbD9wYXRoPVwiK21lLlVzZXIuZGlybmFtZSttZS5Vc2VyLmF0bGFzRmlsZW5hbWUsXCJfYmxhbmtcIik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gbGlua1xuICAgICAqL1xuICAgIGxpbms6IGZ1bmN0aW9uIGxpbmsoKSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyhsaW5rLDAsXCIjZjAwXCIpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuICAgICAgICB3aW5kb3cucHJvbXB0KFwiQ29weSB0byBjbGlwYm9hcmQ6XCIsIGxvY2F0aW9uLmhyZWYrXCImdmlldz1cIitBdGxhc01ha2VyV2lkZ2V0LlVzZXIudmlldytcIiZzbGljZT1cIitBdGxhc01ha2VyV2lkZ2V0LlVzZXIuc2xpY2UpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIHVwbG9hZFxuICAgICAqL1xuICAgIHVwbG9hZDogZnVuY3Rpb24gdXBsb2FkKCkge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2codXBsb2FkLDAsXCIjZjAwXCIpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuICAgICAgICBcbiAgICAgICAgdmFyIGlucD0kKFwiPGlucHV0PlwiKTtcbiAgICAgICAgaW5wLmhpZGUoKTtcbiAgICAgICAgJChcImJvZHlcIikuYXBwZW5kKGlucCk7XG4gICAgICAgIHZhciBpbnB1dD1pbnAuZ2V0KDApO1xuICAgICAgICBpbnB1dC50eXBlPVwiZmlsZVwiO1xuICAgICAgICBpbnB1dC5vbmNoYW5nZT1mdW5jdGlvbiBmcm9tX3VwbG9hZChlKXtcbiAgICAgICAgICAgIHZhciBuYW1lPXRoaXMuZmlsZXNbMF07XG4gICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiBmcm9tX3VwbG9hZChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdD1lLnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgdmFyIG5paTtcbiAgICAgICAgICAgICAgICBpZihuYW1lLm5hbWUuc3BsaXQoJy4nKS5wb3AoKT09XCJnelwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmZsYXRlPW5ldyBwYWtvLkluZmxhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaW5mbGF0ZS5wdXNoKG5ldyBVaW50OEFycmF5KHJlc3VsdCksdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG5paT1pbmZsYXRlLnJlc3VsdC5idWZmZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgbmlpPXJlc3VsdDtcbiAgICAgICAgICAgICAgICB2YXIgbXJpPW1lLmxvYWROaWZ0aShuaWkpO1xuXG4gICAgICAgICAgICAgICAgaWYoICAgIG1yaS5kaW1bMF0hPW1lLlVzZXIuZGltWzBdIHx8XG4gICAgICAgICAgICAgICAgICAgIG1yaS5kaW1bMV0hPW1lLlVzZXIuZGltWzFdIHx8XG4gICAgICAgICAgICAgICAgICAgIG1yaS5kaW1bMl0hPW1lLlVzZXIuZGltWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1I6IFZvbHVtZSBkaW1lbnNpb25zIGRvIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBjb3B5IHVwbG9hZGVkIGRhdGEgdG8gYXRsYXMgZGF0YVxuICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgIGZvcihpPTA7aTxtZS5hdGxhcy5kYXRhLmxlbmd0aDtpKyspXG4gICAgICAgICAgICAgICAgICAgIG1lLmF0bGFzLmRhdGFbaV09bXJpLmRhdGFbaV07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gc2VuZCB1cGxvYWRlZCBkYXRhIHRvIHNlcnZlciAoY29tcHJlc3NlZClcbiAgICAgICAgICAgICAgICBtZS5zb2NrZXQuYmluYXJ5VHlwZT1cImFycmF5YnVmZmVyXCI7XG4gICAgICAgICAgICAgICAgbWUuc29ja2V0LnNlbmQocGFrby5kZWZsYXRlKG1yaS5kYXRhKSk7XG4gICAgICAgICAgICAgICAgbWUuc29ja2V0LmJpbmFyeVR5cGU9XCJibG9iXCI7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gcmVkcmF3IGltYWdlc1xuICAgICAgICAgICAgICAgIG1lLmRyYXdJbWFnZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihuYW1lKTtcbiAgICAgICAgICAgIGlucC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dC5jbGljaygpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIGRvd25sb2FkXG4gICAgICovXG4gICAgZG93bmxvYWQ6IGZ1bmN0aW9uIGRvd25sb2FkKCkge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2coZG93bmxvYWQsMCxcIiNmMDBcIik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG4gICAgICAgICAgICBcbiAgICAgICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgIHZhciBuaWlnej1tZS5lbmNvZGVOaWZ0aSgpO1xuICAgICAgICB2YXIgbmlpZ3pCbG9iID0gbmV3IEJsb2IoW25paWd6XSk7XG4gICAgICAgIGEuaHJlZj13aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChuaWlnekJsb2IpO1xuICAgICAgICBhLmRvd25sb2FkPW1lLmF0bGFzTmFtZStcIi5uaWkuZ3pcIjtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKTtcbiAgICAgICAgYS5jbGljaygpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIGNvbG9yXG4gICAgICovXG4gICAgY29sb3I6IGZ1bmN0aW9uIGNvbG9yKCkge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2coY29sb3IsMCxcIiNmMDBcIik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG4gICAgICAgIFxuICAgICAgICAkKFwiI2xhYmVsc2V0XCIpLmFwcGVuZFRvKG1lLmNvbnRhaW5lcik7XG4gICAgICAgICQoXCIjbGFiZWxzZXRcIikuc2hvdygpO1xuXG4gICAgICAgIHZhciBvYmo9JChcIiNsYWJlbHNldFwiKTtcbiAgICAgICAgJChvYmopLmZpbmQoXCJzcGFuI2xhYmVscy1uYW1lXCIpLnRleHQobWUub250b2xvZ3kubmFtZSk7XG4gICAgICAgICQob2JqKS5maW5kKFwiI2xhYmVsLWxpc3RcIikuaHRtbChcIlwiKTtcbiAgICAgICAgZm9yKHZhciBpPTA7aTxtZS5vbnRvbG9neS5sYWJlbHMubGVuZ3RoO2krKykge1xuICAgICAgICAgICAgdmFyIGw9bWUub250b2xvZ3kubGFiZWxzW2ldO1xuICAgICAgICAgICAgdmFyIGxhPSQob2JqKS5maW5kKFwiI2xhYmVsLXRlbXBsYXRlXCIpLmNsb25lKCk7XG4gICAgICAgICAgICBsYS5hdHRyKHtcImRhdGEtaW5kZXhcIjppfSk7XG4gICAgICAgICAgICBsYS5maW5kKFwiLmxhYmVsLWNvbG9yXCIpLmNzcyh7YmFja2dyb3VuZENvbG9yOlwicmdiKFwiK2wuY29sb3JbMF0rXCIsXCIrbC5jb2xvclsxXStcIixcIitsLmNvbG9yWzJdK1wiKVwifSk7XG4gICAgICAgICAgICBsYS5maW5kKFwiLmxhYmVsLW5hbWVcIikudGV4dChsLm5hbWUpO1xuICAgICAgICAgICAgbGEuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbWUuY2hhbmdlUGVuQ29sb3IoJCh0aGlzKS5hdHRyKFwiZGF0YS1pbmRleFwiKSk7XG4gICAgICAgICAgICAgICAgJChvYmopLmhpZGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJChvYmopLmZpbmQoXCIjbGFiZWwtbGlzdFwiKS5hcHBlbmQobGEpO1xuICAgICAgICAgICAgbGEuc2hvdygpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gb250b2xvZ3lWYWx1ZVRvQ29sb3JcbiAgICAgKi9cbiAgICBvbnRvbG9neVZhbHVlVG9Db2xvcjogZnVuY3Rpb24gb250b2xvZ3lWYWx1ZVRvQ29sb3IodmFsKSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyhvbnRvbG9neVZhbHVlVG9Db2xvciwzLFwiI2YwMFwiKTtpZihsKWNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCxsKTtcblxuICAgICAgICB2YXIgYz1bMCwwLDBdO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaWYodmFsIGluIG1lLm9udG9sb2d5LnZhbHVlVG9JbmRleClcbiAgICAgICAgICAgIGk9bWUub250b2xvZ3kudmFsdWVUb0luZGV4W3ZhbF07XG4gICAgICAgIGlmKGkhPXVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYz1tZS5vbnRvbG9neS5sYWJlbHNbaV0uY29sb3I7XG4gICAgICAgIH0gZWxzZSBpZih2YWwpIHtcbiAgICAgICAgICAgIGM9WzI1NSwwLDBdOyAvLyB1bmF2YWlsYWJsZSBsYWJlbHMgYXJlIHNldCB0byBwdXJlIHJlZFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIGV5ZWRyb3BcbiAgICAgKi9cbiAgICBleWVkcm9wIDogZnVuY3Rpb24gZXllZHJvcCggeCx5LHVzcikge1xuICAgICAgICB2YXIgbWUgPSBBdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbCA9IG1lLnRyYWNlTG9nKGV5ZWRyb3AsMCxcIiNmMDBcIik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG4gICAgICAgIFxuICAgICAgICB2YXIgICAgeiA9IHVzci5zbGljZTtcbiAgICAgICAgdmFyIGkgPSBtZS5zbGljZTJpbmRleCggeCx5LHosdXNyLnZpZXcgKTtcbiAgICAgICAgcmV0dXJuIG1lLmF0bGFzLmRhdGFbaV07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gdG9nZ2xlUHJlY2lzZUN1cnNvclxuICAgICAqL1xuICAgIHRvZ2dsZVByZWNpc2VDdXJzb3I6IGZ1bmN0aW9uIHRvZ2dsZVByZWNpc2VDdXJzb3IoKSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyh0b2dnbGVQcmVjaXNlQ3Vyc29yLDAsXCIjZjAwXCIpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuICAgIFxuICAgICAgICBtZS5mbGFnVXNlUHJlY2lzZUN1cnNvcj0hbWUuZmxhZ1VzZVByZWNpc2VDdXJzb3I7XG4gICAgICAgIG1lLmluaXRDdXJzb3IoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBpbml0Q3Vyc29yXG4gICAgICovXG4gICAgaW5pdEN1cnNvcjogZnVuY3Rpb24gaW5pdEN1cnNvcigpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKGluaXRDdXJzb3IsMSxcIiNmMDBcIik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG5cbiAgICAgICAgdmFyIFc9cGFyc2VGbG9hdCgkKCcjYXRsYXNNYWtlciBjYW52YXMnKS5jc3MoJ3dpZHRoJykpO1xuICAgICAgICB2YXIgSD1wYXJzZUZsb2F0KCQoJyNhdGxhc01ha2VyIGNhbnZhcycpLmNzcygnaGVpZ2h0JykpO1xuICAgICAgICB2YXIgdz1wYXJzZUZsb2F0KCQoJyNhdGxhc01ha2VyIGNhbnZhcycpLmF0dHIoJ3dpZHRoJykpO1xuICAgICAgICB2YXIgaD1wYXJzZUZsb2F0KCQoJyNhdGxhc01ha2VyIGNhbnZhcycpLmF0dHIoJ2hlaWdodCcpKTtcbiAgICAgICAgXG4gICAgICAgIG1lLkNyc3IueD1wYXJzZUludCh3LzIpO1xuICAgICAgICBtZS5DcnNyLnk9cGFyc2VJbnQoaC8yKTtcbiAgICAgICAgXG4gICAgICAgIG1lLkNyc3IuZng9cGFyc2VJbnQody8yKSooVy93KTtcbiAgICAgICAgbWUuQ3Jzci5meT1wYXJzZUludChoLzIpKihIL2gpO1xuICAgICAgICAkKFwiI2N1cnNvclwiKS5jc3Moe2xlZnQ6KG1lLkNyc3IueCooVy93KSkrXCJweFwiLHRvcDoobWUuQ3Jzci55KihIL2gpKStcInB4XCIsd2lkdGg6bWUuVXNlci5wZW5TaXplKihXL3cpLGhlaWdodDptZS5Vc2VyLnBlblNpemUqKEgvaCl9KTtcbiAgICAgICAgXG4gICAgICAgIGlmKG1lLmZsYWdVc2VQcmVjaXNlQ3Vyc29yKSB7XG4gICAgICAgICAgICBpZigkKFwiI2ZpbmdlclwiKS5sZW5ndGg9PTApIHtcbiAgICAgICAgICAgICAgICBtZS5jb250YWluZXIuYXBwZW5kKFwiPGRpdiBpZD0nZmluZ2VyJz48L2Rpdj5cIik7XG4gICAgICAgICAgICAgICAgJChcIiNmaW5nZXJcIikuYWRkQ2xhc3MoXCJ0b3VjaERldmljZVwiKTtcblxuICAgICAgICAgICAgICAgIC8vIGNvbmZpZ3VyZSB0b3VjaCBldmVudHMgZm9yIHRhYmxldHNcbiAgICAgICAgICAgICAgICAkKFwiI2ZpbmdlclwiKS5vbihcInRvdWNoc3RhcnRcIixmdW5jdGlvbihlKXttZS50b3VjaHN0YXJ0KGUpfSk7XG4gICAgICAgICAgICAgICAgJChcIiNmaW5nZXJcIikub24oXCJ0b3VjaGVuZFwiLGZ1bmN0aW9uKGUpe21lLnRvdWNoZW5kKGUpfSk7XG4gICAgICAgICAgICAgICAgJChcIiNmaW5nZXJcIikub24oXCJ0b3VjaG1vdmVcIixmdW5jdGlvbihlKXttZS50b3VjaG1vdmUoZSl9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIHR1cm4gb2ZmIGV2ZW50dWFsIHRvdWNoIGV2ZW50cyBoYW5kbGVkIGJ5IGNhbnZhc1xuICAgICAgICAgICAgICAgIG1lLmNhbnZhcy5vbnRvdWNoc3RhcnQ9bnVsbDtcbiAgICAgICAgICAgICAgICBtZS5jYW52YXMub250b3VjaG1vdmU9bnVsbDtcbiAgICAgICAgICAgICAgICBtZS5jYW52YXMub250b3VjaGVuZD1udWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWUudXBkYXRlQ3Vyc29yKCk7XG5cbiAgICAgICAgICAgICQoXCIjZmluZ2VyXCIpLmNzcyh7bGVmdDptZS5DcnNyLmZ4K1wicHhcIix0b3A6bWUuQ3Jzci5meStcInB4XCJ9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBwcmVjaXNlIGN1cnNvclxuICAgICAgICAgICAgJChcIiNmaW5nZXJcIikucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIC8vIGNvbmZpZ3VyZSB0b3VjaCBldmVudHMgZm9yIHRhYmxldHNcbiAgICAgICAgICAgIG1lLmNhbnZhcy5vbnRvdWNoc3RhcnQ9bWUudG91Y2hzdGFydDtcbiAgICAgICAgICAgIG1lLmNhbnZhcy5vbnRvdWNobW92ZT1tZS50b3VjaG1vdmU7XG4gICAgICAgICAgICBtZS5jYW52YXMub250b3VjaGVuZD1tZS50b3VjaGVuZDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIHVwZGF0ZUN1cnNvclxuICAgICAqL1xuICAgIHVwZGF0ZUN1cnNvcjogZnVuY3Rpb24gdXBkYXRlQ3Vyc29yKCkge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2codXBkYXRlQ3Vyc29yLDEsXCIjZjAwXCIpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuXG4gICAgICAgICQoXCIjZmluZ2VyXCIpLnJlbW92ZUNsYXNzKFwibW92ZSBkcmF3IGNvbmZpZ3VyZVwiKTtcbiAgICAgICAgc3dpdGNoKG1lLkNyc3Iuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJtb3ZlXCI6ICQoXCIjZmluZ2VyXCIpLmFkZENsYXNzKFwibW92ZVwiKTsgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZHJhd1wiOiAkKFwiI2ZpbmdlclwiKS5hZGRDbGFzcyhcImRyYXdcIik7ICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNvbmZpZ3VyZVwiOiAkKFwiI2ZpbmdlclwiKS5hZGRDbGFzcyhcImNvbmZpZ3VyZVwiKTsgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBtb3VzZWRvd246IGZ1bmN0aW9uIG1vdXNlZG93bihlKSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyhtb3VzZWRvd24sMCxcIiNmMDBcIik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG4gICAgXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICB2YXIgVz1wYXJzZUZsb2F0KCQoJyNhdGxhc01ha2VyIGNhbnZhcycpLmNzcygnd2lkdGgnKSk7XG4gICAgICAgIHZhciBIPXBhcnNlRmxvYXQoJCgnI2F0bGFzTWFrZXIgY2FudmFzJykuY3NzKCdoZWlnaHQnKSk7XG4gICAgICAgIHZhciB3PXBhcnNlRmxvYXQoJCgnI2F0bGFzTWFrZXIgY2FudmFzJykuYXR0cignd2lkdGgnKSk7XG4gICAgICAgIHZhciBoPXBhcnNlRmxvYXQoJCgnI2F0bGFzTWFrZXIgY2FudmFzJykuYXR0cignaGVpZ2h0JykpO1xuICAgICAgICB2YXIgbz0kKCcjYXRsYXNNYWtlciBjYW52YXMnKS5vZmZzZXQoKTtcbiAgICAgICAgdmFyIHg9cGFyc2VJbnQoKGUucGFnZVgtby5sZWZ0KSoody9XKSk7XG4gICAgICAgIC8vIGkgaGF2ZSB0byBhZGQgaGVyZSB0aGUgY29tcGVuc2F0aW9uIGZvciByZWN0YW5ndWxhciBwaXhlbHM6IGYoYnJhaW5fV2RpbSwgYnJhaW5fSGRpbSlcbiAgICAgICAgdmFyIHk9cGFyc2VJbnQoKGUucGFnZVktby50b3ApKihoL0gpKTtcbiAgICAgICAgbWUuZG93bih4LE1hdGgucm91bmQoeSptZS5icmFpbl9XZGltL21lLmJyYWluX0hkaW0pKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBtb3VzZW1vdmVcbiAgICAgKiBAZGVzYyBIYW5kbGVzIGEgbW91c2UgbW92ZSBldmVudC4gVGhlIHggYW5kIHkgc2xpY2Ugc2NyZWVucyBhcmUgY29tcHV0ZWQgZnJvbSB0aGUgcGFnZVggYW5kIHBhZ2VZIHNjcmVlbiBjb29yZGluYXRlcyBhbmQgZGlzcGF0Y2hlZCB0byB0aGUgZ2VuZXJpYyBtb3ZlIGhhbmRsZXIuIFRoZSBwb3NpdGlvbiBhbmQgc2l6ZSBvZiB0aGUgY3Vyc29yIGFyZSBhZGp1c3RlZC5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIG1vdXNlbW92ZTogZnVuY3Rpb24gbW91c2Vtb3ZlKGUpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKG1vdXNlbW92ZSwyLFwiI2YwMFwiKTtpZihsKWNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCxsKTtcbiAgICBcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgVz1wYXJzZUZsb2F0KCQoJyNhdGxhc01ha2VyIGNhbnZhcycpLmNzcygnd2lkdGgnKSk7XG4gICAgICAgIHZhciBIPXBhcnNlRmxvYXQoJCgnI2F0bGFzTWFrZXIgY2FudmFzJykuY3NzKCdoZWlnaHQnKSk7XG4gICAgICAgIHZhciB3PXBhcnNlRmxvYXQoJCgnI2F0bGFzTWFrZXIgY2FudmFzJykuYXR0cignd2lkdGgnKSk7XG4gICAgICAgIHZhciBoPXBhcnNlRmxvYXQoJCgnI2F0bGFzTWFrZXIgY2FudmFzJykuYXR0cignaGVpZ2h0JykpO1xuICAgICAgICB2YXIgbz0kKCcjYXRsYXNNYWtlciBjYW52YXMnKS5vZmZzZXQoKTtcbiAgICAgICAgdmFyIHg9cGFyc2VJbnQoKGUucGFnZVgtby5sZWZ0KSoody9XKSk7XG4gICAgICAgIHZhciB5PXBhcnNlSW50KChlLnBhZ2VZLW8udG9wKSooaC9IKSk7XG4gICAgXG4gICAgICAgICQoXCIjY3Vyc29yXCIpLmNzcyh7XG4gICAgICAgICAgICBsZWZ0Oih4KihXL3cpKSsncHgnLFxuICAgICAgICAgICAgdG9wOih5KihIL2gpKSsncHgnLFxuICAgICAgICAgICAgd2lkdGg6bWUuVXNlci5wZW5TaXplKihXL3cpLFxuICAgICAgICAgICAgaGVpZ2h0Om1lLlVzZXIucGVuU2l6ZSooSC9oKVxuICAgICAgICB9KTtcbiAgICAgICAgbWUubW92ZSh4LE1hdGgucm91bmQoeSptZS5icmFpbl9XZGltL21lLmJyYWluX0hkaW0pKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBtb3VzZXVwXG4gICAgICovXG4gICAgbW91c2V1cDogZnVuY3Rpb24gbW91c2V1cChlKSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyhtb3VzZXVwLDAsXCIjZjAwXCIpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuICAgIFxuICAgICAgICBtZS51cChlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiB0b3VjaHN0YXJ0XG4gICAgICovXG4gICAgdG91Y2hzdGFydDogZnVuY3Rpb24gdG91Y2hzdGFydChlKSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyh0b3VjaHN0YXJ0LDAsXCIjZjAwXCIpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuICAgIFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgdmFyIFc9cGFyc2VGbG9hdCgkKCcjYXRsYXNNYWtlciBjYW52YXMnKS5jc3MoJ3dpZHRoJykpO1xuICAgICAgICB2YXIgSD1wYXJzZUZsb2F0KCQoJyNhdGxhc01ha2VyIGNhbnZhcycpLmNzcygnaGVpZ2h0JykpO1xuICAgICAgICB2YXIgdz1wYXJzZUZsb2F0KCQoJyNhdGxhc01ha2VyIGNhbnZhcycpLmF0dHIoJ3dpZHRoJykpO1xuICAgICAgICB2YXIgaD1wYXJzZUZsb2F0KCQoJyNhdGxhc01ha2VyIGNhbnZhcycpLmF0dHIoJ2hlaWdodCcpKTtcbiAgICAgICAgdmFyIG89JCgnI2F0bGFzTWFrZXIgY2FudmFzJykub2Zmc2V0KCk7XG4gICAgICAgIHZhciAgICB0b3VjaEV2ZW50O1xuICAgICAgICBpZihlLm9yaWdpbmFsRXZlbnQpXG4gICAgICAgICAgICB0b3VjaEV2ZW50PWUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdG91Y2hFdmVudD1lLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICB2YXIgeD1wYXJzZUludCgodG91Y2hFdmVudC5wYWdlWC1vLmxlZnQpKih3L1cpKTtcbiAgICAgICAgdmFyIHk9cGFyc2VJbnQoKHRvdWNoRXZlbnQucGFnZVktby50b3ApKihoL0gpKTtcbiAgICBcbiAgICAgICAgaWYobWUuZmxhZ1VzZVByZWNpc2VDdXJzb3IpIHtcbiAgICAgICAgICAgIC8vIFByZWNpc2lvbiBjdXJzb3JcbiAgICAgICAgICAgIG1lLkNyc3IueDA9eDtcbiAgICAgICAgICAgIG1lLkNyc3IuY2FjaGVkWD14O1xuICAgICAgICAgICAgbWUuQ3Jzci55MD15O1xuICAgICAgICAgICAgbWUuQ3Jzci5jYWNoZWRZPXk7XG4gICAgICAgICAgICBtZS5DcnNyLmZ4PSQoXCIjZmluZ2VyXCIpLm9mZnNldCgpLmxlZnQ7XG4gICAgICAgICAgICBtZS5DcnNyLmZ5PSQoXCIjZmluZ2VyXCIpLm9mZnNldCgpLnRvcDtcbiAgICAgICAgICAgIG1lLkNyc3IudG91Y2hTdGFydGVkPXRydWU7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmKCBtZS5DcnNyLmNhY2hlZFggPT0gbWUuQ3Jzci54MCAmJiBtZS5DcnNyLmNhY2hlZFk9PW1lLkNyc3IueTAgJiYgIW1lLkNyc3IudG91Y2hTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3J0IHRhcDogY2hhbmdlIG1vZGVcbiAgICAgICAgICAgICAgICAgICAgbWUuQ3Jzci5zdGF0ZT0obWUuQ3Jzci5zdGF0ZT09XCJtb3ZlXCIpP1wiZHJhd1wiOlwibW92ZVwiO1xuICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVDdXJzb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LDIwMCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChtZS5DcnNyLmNhY2hlZFg9PW1lLkNyc3IueDAgJiYgbWUuQ3Jzci5jYWNoZWRZPT1tZS5DcnNyLnkwICYmIG1lLkNyc3IudG91Y2hTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvbmcgdGFwOiBjaGFuZ2UgdG8gY29uZmlndXJlIG1vZGVcbiAgICAgICAgICAgICAgICAgICAgbWUuQ3Jzci5wcmV2U3RhdGU9bWUuQ3Jzci5zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgbWUuQ3Jzci5zdGF0ZT1cImNvbmZpZ3VyZVwiO1xuICAgICAgICAgICAgICAgICAgICBtZS51cGRhdGVDdXJzb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LDEwMDApO1xuICAgICAgICAgICAgbWUuZG93bihtZS5DcnNyLngsTWF0aC5yb3VuZChtZS5DcnNyLnkqbWUuYnJhaW5fV2RpbS9tZS5icmFpbl9IZGltKSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgbWUuZG93bih4LE1hdGgucm91bmQoeSptZS5icmFpbl9XZGltL21lLmJyYWluX0hkaW0pKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiB0b3VjaG1vdmVcbiAgICAgKi9cbiAgICB0b3VjaG1vdmU6IGZ1bmN0aW9uIHRvdWNobW92ZShlKSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyh0b3VjaG1vdmUsMixcIiNmMDBcIik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG4gICAgICAgIFxuICAgICAgICBpZihtZS5DcnNyLnRvdWNoU3RhcnRlZD09ZmFsc2UgJiYgbWUuZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV0FSTklORzogdG91Y2ggY2FuIG1vdmUgd2l0aG91dCBoYXZpbmcgc3RhcnRlZFwiKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgdmFyIFc9cGFyc2VGbG9hdCgkKCcjYXRsYXNNYWtlciBjYW52YXMnKS5jc3MoJ3dpZHRoJykpO1xuICAgICAgICB2YXIgSD1wYXJzZUZsb2F0KCQoJyNhdGxhc01ha2VyIGNhbnZhcycpLmNzcygnaGVpZ2h0JykpO1xuICAgICAgICB2YXIgdz1wYXJzZUZsb2F0KCQoJyNhdGxhc01ha2VyIGNhbnZhcycpLmF0dHIoJ3dpZHRoJykpO1xuICAgICAgICB2YXIgaD1wYXJzZUZsb2F0KCQoJyNhdGxhc01ha2VyIGNhbnZhcycpLmF0dHIoJ2hlaWdodCcpKTtcbiAgICAgICAgdmFyIG89JCgnI2F0bGFzTWFrZXIgY2FudmFzJykub2Zmc2V0KCk7XG4gICAgICAgIHZhciAgICB0b3VjaEV2ZW50O1xuICAgICAgICBpZihlLm9yaWdpbmFsRXZlbnQpXG4gICAgICAgICAgICB0b3VjaEV2ZW50PWUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdG91Y2hFdmVudD1lLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICB2YXIgeD1wYXJzZUludCgodG91Y2hFdmVudC5wYWdlWC1vLmxlZnQpKih3L1cpKTtcbiAgICAgICAgdmFyIHk9cGFyc2VJbnQoKHRvdWNoRXZlbnQucGFnZVktby50b3ApKihoL0gpKTtcbiAgICBcbiAgICAgICAgaWYobWUuZmxhZ1VzZVByZWNpc2VDdXJzb3IpIHtcbiAgICAgICAgICAgIC8vIFByZWNpc2lvbiBjdXJzb3JcbiAgICAgICAgICAgIHZhciBkeD14LW1lLkNyc3IueDA7XG4gICAgICAgICAgICB2YXIgZHk9eS1tZS5DcnNyLnkwO1xuICAgICAgICAgICAgaWYobWUuQ3Jzci5zdGF0ZT09XCJtb3ZlXCJ8fG1lLkNyc3Iuc3RhdGU9PVwiZHJhd1wiKSB7XG4gICAgICAgICAgICAgICAgbWUuQ3Jzci54Kz1keDtcbiAgICAgICAgICAgICAgICBtZS5DcnNyLnkrPWR5O1xuICAgICAgICAgICAgICAgICQoXCIjY3Vyc29yXCIpLmNzcyh7bGVmdDptZS5DcnNyLngqKFcvdyksdG9wOm1lLkNyc3IueSooSC9oKSx3aWR0aDptZS5Vc2VyLnBlblNpemUqKFcvdyksaGVpZ2h0Om1lLlVzZXIucGVuU2l6ZSooSC9oKX0pO1xuICAgICAgICAgICAgICAgIGlmKG1lLkNyc3Iuc3RhdGU9PVwiZHJhd1wiKVxuICAgICAgICAgICAgICAgICAgICBtZS5tb3ZlKG1lLkNyc3IueCxNYXRoLnJvdW5kKG1lLkNyc3IueSptZS5icmFpbl9XZGltL21lLmJyYWluX0hkaW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lLkNyc3IuZngrPWR4KihXL3cpO1xuICAgICAgICAgICAgbWUuQ3Jzci5meSs9ZHkqKEgvaCk7XG4gICAgICAgICAgICAkKFwiI2ZpbmdlclwiKS5vZmZzZXQoe2xlZnQ6bWUuQ3Jzci5meCx0b3A6bWUuQ3Jzci5meX0pO1xuICAgICAgICBcbiAgICAgICAgICAgIG1lLkNyc3IueDA9eDtcbiAgICAgICAgICAgIG1lLkNyc3IueTA9eTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQoXCIjY3Vyc29yXCIpLmNzcyh7XG4gICAgICAgICAgICAgICAgbGVmdDooeCooVy93KSkrJ3B4JyxcbiAgICAgICAgICAgICAgICB0b3A6KHkqKEgvaCkpKydweCcsXG4gICAgICAgICAgICAgICAgd2lkdGg6bWUuVXNlci5wZW5TaXplKihXL3cpLFxuICAgICAgICAgICAgICAgIGhlaWdodDptZS5Vc2VyLnBlblNpemUqKEgvaClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWUubW92ZSh4LE1hdGgucm91bmQoeSptZS5icmFpbl9XZGltL21lLmJyYWluX0hkaW0pKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIHRvdWNoZW5kXG4gICAgICovXG4gICAgdG91Y2hlbmQ6IGZ1bmN0aW9uIHRvdWNoZW5kKGUpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKHRvdWNoZW5kLDAsXCIjZjAwXCIpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuICAgICAgICBcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIFxuICAgICAgICBpZihtZS5mbGFnVXNlUHJlY2lzZUN1cnNvcikge1xuICAgICAgICAgICAgLy8gUHJlY2lzaW9uIGN1cnNvclxuICAgICAgICAgICAgbWUuQ3Jzci50b3VjaFN0YXJ0ZWQ9ZmFsc2U7XG4gICAgICAgICAgICBpZihtZS5DcnNyLnN0YXRlPT1cImNvbmZpZ3VyZVwiKSB7XG4gICAgICAgICAgICAgICAgbWUuQ3Jzci5zdGF0ZT1tZS5DcnNyLnByZXZTdGF0ZTtcbiAgICAgICAgICAgICAgICBtZS51cGRhdGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAgICBcbiAgICAgICAgbWUudXAoZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gZG93blxuICAgICAqIEBkZXNjIEdlbmVyaWMgcG9pbnRlciBkb3duIGV2ZW50OiBEZWFscyB3aXRoIGRvd24gZXZlbnRzIGdlbmVyYXRlZCBieSBtb3VzZSBjbGlja3Mgb3IgdG91Y2ggZXZlbnRzLiBUaGUgZWZmZWN0IG9mIHRoZSBkb3duIGV2ZW50IGlzIGRldGVybWluZWQgYnkgdGhlIGN1cnJlbnQgVXNlci50b29sXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSB4IFggY29vcmRpbmF0ZSBpbiBzbGljZSBzcGFjZVxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0geSBZIGNvb3JkaW5hdGUgaW4gc2xpY2Ugc3BhY2VcbiAgICAgKi9cbiAgICBkb3duOiBmdW5jdGlvbiBkb3duKHgseSkge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2coZG93biwwLFwiI2YwMFwiKTtpZihsKWNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCxsKTtcbiAgICBcbiAgICAgICAgdmFyIHo9bWUuVXNlci5zbGljZTtcbiAgICAgICAgXG4gICAgICAgIHN3aXRjaChtZS5Vc2VyLnRvb2wpIHtcbiAgICAgICAgICAgIGNhc2UgJ3Nob3cnOlxuICAgICAgICAgICAgICAgIG1lLlVzZXIubW91c2VJc0Rvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1lLnNlbmRVc2VyRGF0YU1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoeydtb3VzZUlzRG93bic6dHJ1ZX0pKTtcbiAgICAgICAgICAgICAgICBtZS5zaG93eHkoLTEsJ20nLHgseSxtZS5Vc2VyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3BhaW50JzpcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgJ2VkaXQnIGFjY2Vzc1xuICAgICAgICAgICAgICAgIGlmKG1lLmVkaXRNb2RlID09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBmaWxsXG4gICAgICAgICAgICAgICAgaWYobWUuVXNlci5kb0ZpbGwpXG4gICAgICAgICAgICAgICAgICAgIG1lLnBhaW50eHkoLTEsJ2YnLHgseSxtZS5Vc2VyKTtcbiAgICAgICAgICAgICAgICAvL3BhaW50XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLlVzZXIubW91c2VJc0Rvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtZS5zZW5kVXNlckRhdGFNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHsnbW91c2VJc0Rvd24nOnRydWV9KSk7XG4gICAgICAgICAgICAgICAgICAgIG1lLnBhaW50eHkoLTEsJ21mJyx4LHksbWUuVXNlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZXJhc2UnOlxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciAnZWRpdCcgYWNjZXNzXG4gICAgICAgICAgICAgICAgaWYobWUuZWRpdE1vZGUgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIGZpbGxcbiAgICAgICAgICAgICAgICBpZihtZS5Vc2VyLmRvRmlsbClcbiAgICAgICAgICAgICAgICAgICAgbWUucGFpbnR4eSgtMSwnZScseCx5LG1lLlVzZXIpO1xuICAgICAgICAgICAgICAgIC8vIGVyYXNlXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLlVzZXIubW91c2VJc0Rvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtZS5zZW5kVXNlckRhdGFNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHsnbW91c2VJc0Rvd24nOnRydWV9KSk7XG4gICAgICAgICAgICAgICAgICAgIG1lLnBhaW50eHkoLTEsJ21lJyx4LHksbWUuVXNlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWVhc3VyZSc6XG4gICAgICAgICAgICAgICAgaWYobWUuVXNlci5tZWFzdXJlTGVuZ3RoPT1udWxsKVxuICAgICAgICAgICAgICAgICAgICBtZS5Vc2VyLm1lYXN1cmVMZW5ndGg9W3t4OngseTp5fV07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBtZS5Vc2VyLm1lYXN1cmVMZW5ndGgucHVzaCh7eDp4LHk6eX0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYWRqdXN0JzpcbiAgICAgICAgICAgICAgICBtZS5Vc2VyLm1vdXNlSXNEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtZS5pbmZvLng9eC9tZS5icmFpbl9XO1xuICAgICAgICAgICAgICAgIG1lLmluZm8ueT0xLXkvbWUuYnJhaW5fSDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2V5ZWRyb3AnOlxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1lLmV5ZWRyb3AoIHgseSxtZS5Vc2VyICk7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkgeyBicmVhazsgfVxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IG1lLm9udG9sb2d5LnZhbHVlVG9JbmRleFsgdmFsdWUgXTtcbiAgICAgICAgICAgICAgICB2YXIgc2VsUmVnaW9uTmFtZSA9IG1lLm9udG9sb2d5LmxhYmVsc1sgaW5kZXggXS5uYW1lO1xuICAgICAgICAgICAgICAgIG1lLmluZm8ucmVnaW9uID0gc2VsUmVnaW9uTmFtZTtcbiAgICAgICAgICAgICAgICBtZS5jaGFuZ2VQZW5Db2xvciggaW5kZXggKTtcbiAgICAgICAgICAgICAgICB2YXIgc2VsUmVnaW9uQ29sb3IgPSBtZS5vbnRvbG9neS5sYWJlbHNbIGluZGV4IF0uY29sb3I7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gaW5pdCBhbm5vdGF0aW9uIGxlbmd0aCBjb3VudGVyXG4gICAgICAgIG1lLmFubm90YXRpb25MZW5ndGg9MDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBtb3ZlXG4gICAgICogQGRlc2MgR2VuZXJpYyBwb2ludGVyIG1vdmUgZXZlbnQ6IERlYWxzIHdpdGggbW92ZSBldmVudHMgZ2VuZXJhdGVkIGJ5IG1vdXNlIGNsaWNrcyBvciB0b3VjaCBldmVudHMuIFRoZSBlZmZlY3Qgb2YgdGhlIG1vdmUgZXZlbnQgaXMgZGV0ZXJtaW5lZCBieSB0aGUgY3VycmVudCBVc2VyLnRvb2xcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IHggWCBjb29yZGluYXRlIGluIHNsaWNlIHNwYWNlXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSB5IFkgY29vcmRpbmF0ZSBpbiBzbGljZSBzcGFjZVxuICAgICAqL1xuICAgIG1vdmU6IGZ1bmN0aW9uIG1vdmUoeCx5KSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyhtb3ZlLDIsXCIjZjAwXCIpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuICAgIFxuICAgICAgICAvKlxuICAgICAgICBpZihNeUxvZ2luV2lkZ2V0LmxvZ2dlZGluPT0wIHx8IG1lLmVkaXRNb2RlPT0wKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAqL1xuXG4gICAgICAgIHZhciB6PW1lLlVzZXIuc2xpY2U7XG5cbiAgICAgICAgaWYoIW1lLlVzZXIubW91c2VJc0Rvd24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBzd2l0Y2gobWUuVXNlci50b29sKSB7XG4gICAgICAgICAgICBjYXNlICdzaG93JzpcbiAgICAgICAgICAgICAgICBtZS5zaG93eHkoLTEsJ20nLHgseSxtZS5Vc2VyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3BhaW50JzpcbiAgICAgICAgICAgICAgICBtZS5wYWludHh5KC0xLCdsZicseCx5LG1lLlVzZXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZXJhc2UnOlxuICAgICAgICAgICAgICAgIG1lLnBhaW50eHkoLTEsJ2xlJyx4LHksbWUuVXNlcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhZGp1c3QnOlxuICAgICAgICAgICAgICAgIG1lLmluZm8ueD14L21lLmJyYWluX1c7XG4gICAgICAgICAgICAgICAgbWUuaW5mby55PTEteS9tZS5icmFpbl9IO1xuICAgICAgICAgICAgICAgIG1lLmRyYXdJbWFnZXMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIHVwXG4gICAgICogQGRlc2MgR2VuZXJpYyBwb2ludGVyIHVwIGV2ZW50OiBEZWFscyB3aXRoIHVwIGV2ZW50cyBnZW5lcmF0ZWQgYnkgbW91c2UgY2xpY2tzIG9yIHRvdWNoIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IHggWCBjb29yZGluYXRlIGluIHNsaWNlIHNwYWNlXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSB5IFkgY29vcmRpbmF0ZSBpbiBzbGljZSBzcGFjZVxuICAgICAqL1xuICAgIHVwOiBmdW5jdGlvbiB1cChlKSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyh1cCwwLFwiI2YwMFwiKTtpZihsKWNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCxsKTtcblxuICAgICAgICAvKlxuICAgICAgICBpZihNeUxvZ2luV2lkZ2V0LmxvZ2dlZGluPT0wIHx8IG1lLmVkaXRNb2RlPT0wKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAqL1xuXG4gICAgICAgIC8vIFNlbmQgbW91c2UgdXAgKHRvdWNoIGVuZGVkKSBtZXNzYWdlXG4gICAgICAgIG1lLlVzZXIubW91c2VJc0Rvd24gPSBmYWxzZTtcbiAgICAgICAgbWUuVXNlci54MD0tMTtcblxuICAgICAgICBtZS5zZW5kVXNlckRhdGFNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHsnbW91c2VJc0Rvd24nOmZhbHNlfSkpO1xuICAgICAgICBcbiAgICAgICAgdmFyIG1zZztcbiAgICAgICAgXG4gICAgICAgIHN3aXRjaChtZS5Vc2VyLnRvb2wpIHtcbiAgICAgICAgICAgIGNhc2UgJ3Nob3cnOlxuICAgICAgICAgICAgICAgIHZhciBtc2c9e1wiY1wiOlwidVwifTtcbiAgICAgICAgICAgICAgICBtZS5zZW5kU2hvd01lc3NhZ2UobXNnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3BhaW50JzpcbiAgICAgICAgICAgIGNhc2UgJ2VyYXNlJzpcbiAgICAgICAgICAgICAgICB2YXIgbXNnPXtjOlwibXVcIn07XG4gICAgICAgICAgICAgICAgbWUuc2VuZFBhaW50TWVzc2FnZShtc2cpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGFkZCBhbm5vdGF0ZWQgbGVuZ3RoIHRvIFVzZXIuYW5ub3RhdGlvbiBsZW5ndGggYW5kIHBvc3QgdG8gREJcbiAgICAgICAgICAgICAgICBtZS5sb2dUb0RhdGFiYXNlKFwiYW5ub3RhdGlvbkxlbmd0aFwiLHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOm1lLlVzZXIuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBhdGxhczptZS5Vc2VyLmF0bGFzRmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDptZS5hbm5vdGF0aW9uTGVuZ3RoXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBwYXJzZUludChyZXNwb25zZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBtZS5pbmZvLmxlbmd0aCA9IGxlbmd0aCtcIiBtbVwiO1xuICAgICAgICAgICAgICAgICAgICBtZS5kaXNwbGF5SW5mb3JtYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBtZS5hbm5vdGF0aW9uTGVuZ3RoPTA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gY29tcHV0ZSB0b3RhbCBzZWdtZW50ZWQgdm9sdW1lXG4gICAgICAgICAgICAgICAgdmFyIHZvbD1tZS5jb21wdXRlU2VnbWVudGVkVm9sdW1lKCk7XG4gICAgICAgICAgICAgICAgbWUuaW5mby52b2x1bWU9cGFyc2VJbnQodm9sKStcIiBtbTNcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2V5ZWRyb3AnOlxuICAgICAgICAgICAgICAgIG1lLmRpc3BsYXlJbmZvcm1hdGlvbigpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBtc2c9e1wiY1wiOlwibXVcIn07XG4gICAgICAgICAgICAgICAgbWUuc2VuZFBhaW50TWVzc2FnZShtc2cpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2YXIgbXNnPXtcImNcIjpcIm11XCJ9O1xuICAgICAgICAgICAgICAgIG1lLnNlbmRQYWludE1lc3NhZ2UobXNnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICAgIFRFU1RcbiAgICAgICAgKi9cbiAgICAgICAgLy9tZS5zZW5kUmVxdWVzdFNsaWNlTWVzc2FnZSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIGtleURvd25cbiAgICAgKi9cbiAgICBrZXlEb3duOiBmdW5jdGlvbiBrZXlEb3duKGUpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKGtleURvd24sMixcIiNmMDBcIik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG4gICAgXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwia2V5OlwiLGUud2hpY2gpO1xuICAgICAgICBcbiAgICAgICAgaWYoZS53aGljaD09MTMgJiYgJChlLnRhcmdldCkuYXR0cignY29udGVudGVkaXRhYmxlJykpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoZS50YXJnZXQudGFnTmFtZSE9XCJCT0RZXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgXG4gICAgICAgIHN3aXRjaChlLndoaWNoKSB7XG4gICAgICAgICAgICBjYXNlIDEzOiAvLyByZXR1cm5cbiAgICAgICAgICAgICAgICBpZihtZS5Vc2VyLm1lYXN1cmVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aD0wO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcD1tZS5Vc2VyLm1lYXN1cmVMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3ZGltPW1lLmJyYWluX1dkaW0saGRpbT1tZS5icmFpbl9IZGltO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGk9MTtpPHAubGVuZ3RoO2krKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCs9TWF0aC5zcXJ0KE1hdGgucG93KHdkaW0qKHBbaV0ueC1wW2ktMV0ueCksMikrTWF0aC5wb3coaGRpbSoocFtpXS55LXBbaS0xXS55KSwyKSk7XG4gICAgICAgICAgICAgICAgICAgICQoXCIjbG9nXCIpLmFwcGVuZChcIkxlbmd0aDogXCIrbGVuZ3RoK1wiPGJyLz5cIik7XG4gICAgICAgICAgICAgICAgICAgIG1lLlVzZXIubWVhc3VyZUxlbmd0aD1udWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzc6IC8vIGxlZnQgYXJyb3dcbiAgICAgICAgICAgICAgICBtZS5wcmV2U2xpY2UoKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM5OiAvLyByaWdodCBhcnJvd1xuICAgICAgICAgICAgICAgIG1lLm5leHRTbGljZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBvbmtleVxuICAgICAqL1xuICAgIG9ua2V5OiBmdW5jdGlvbiBvbmtleShlKSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyhvbmtleSwyLFwiI2YwMFwiKTtpZihsKWNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCxsKTtcblxuICAgICAgICBpZiAoZS5rZXlDb2RlID09IDEzKSB7XG4gICAgICAgICAgICBtZS5zZW5kQ2hhdE1lc3NhZ2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qISBBdGxhc01ha2VyOiBJbnB1dC9PdXRwdXQgKi9cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSdcbmltcG9ydCAqIGFzIHBha28gZnJvbSAnLi4vLi4vZG93bmxvYWRzL3Bha28ubWluLmpzJztcblxuLyoqXG4gKiBAcGFnZSBBdGxhc01ha2VyOiBJbnB1dC9PdXRwdXRcbiAqL1xuZXhwb3J0IHZhciBBdGxhc01ha2VySU8gPSB7XG4gICAgTmlpSGRyTEU6IFN0cnVjdCgpXG4gICAgICAgIC53b3JkMzJTbGUoJ3NpemVvZl9oZHInKSAgICAgICAgLy8gU2l6ZSBvZiB0aGUgaGVhZGVyLiBNdXN0IGJlIDM0OCAoYnl0ZXMpXG4gICAgICAgIC5jaGFycygnZGF0YV90eXBlJywxMCkgICAgICAgICAgLy8gTm90IHVzZWQ7IGNvbXBhdGliaWxpdHkgd2l0aCBhbmFseXplLlxuICAgICAgICAuY2hhcnMoJ2RiX25hbWUnLDE4KSAgICAgICAgICAgIC8vIE5vdCB1c2VkOyBjb21wYXRpYmlsaXR5IHdpdGggYW5hbHl6ZS5cbiAgICAgICAgLndvcmQzMlNsZSgnZXh0ZW50cycpICAgICAgICAgICAvLyBOb3QgdXNlZDsgY29tcGF0aWJpbGl0eSB3aXRoIGFuYWx5emUuXG4gICAgICAgIC53b3JkMTZTbGUoJ3Nlc3Npb25fZXJyb3InKSAgICAgLy8gTm90IHVzZWQ7IGNvbXBhdGliaWxpdHkgd2l0aCBhbmFseXplLlxuICAgICAgICAud29yZDgoJ3JlZ3VsYXInKSAgICAgICAgICAgICAgIC8vIE5vdCB1c2VkOyBjb21wYXRpYmlsaXR5IHdpdGggYW5hbHl6ZS5cbiAgICAgICAgLndvcmQ4KCdkaW1faW5mbycpICAgICAgICAgICAgICAvLyBFbmNvZGluZyBkaXJlY3Rpb25zIChwaGFzZSwgZnJlcXVlbmN5LCBzbGljZSkuXG4gICAgICAgIC5hcnJheSgnZGltJyw4LCd3b3JkMTZTbGUnKSAgICAgLy8gRGF0YSBhcnJheSBkaW1lbnNpb25zLlxuICAgICAgICAuZmxvYXRsZSgnaW50ZW50X3AxJykgICAgICAgICAgIC8vIDFzdCBpbnRlbnQgcGFyYW1ldGVyLlxuICAgICAgICAuZmxvYXRsZSgnaW50ZW50X3AyJykgICAgICAgICAgIC8vIDJuZCBpbnRlbnQgcGFyYW1ldGVyLlxuICAgICAgICAuZmxvYXRsZSgnaW50ZW50X3AzJykgICAgICAgICAgIC8vIDNyZCBpbnRlbnQgcGFyYW1ldGVyLlxuICAgICAgICAud29yZDE2U2xlKCdpbnRlbnRfY29kZScpICAgICAgIC8vIG5pZnRpIGludGVudC5cbiAgICAgICAgLndvcmQxNlNsZSgnZGF0YXR5cGUnKSAgICAgICAgICAgIC8vIERhdGEgdHlwZS5cbiAgICAgICAgLndvcmQxNlNsZSgnYml0cGl4JykgICAgICAgICAgICAvLyBOdW1iZXIgb2YgYml0cyBwZXIgdm94ZWwuXG4gICAgICAgIC53b3JkMTZTbGUoJ3NsaWNlX3N0YXJ0JykgICAgICAgIC8vIEZpcnN0IHNsaWNlIGluZGV4LlxuICAgICAgICAuYXJyYXkoJ3BpeGRpbScsOCwnZmxvYXRsZScpICAgIC8vIEdyaWQgc3BhY2luZ3MgKHVuaXQgcGVyIGRpbWVuc2lvbikuXG4gICAgICAgIC5mbG9hdGxlKCd2b3hfb2Zmc2V0JykgICAgICAgICAgICAvLyBPZmZzZXQgaW50byBhIC5uaWkgZmlsZS5cbiAgICAgICAgLmZsb2F0bGUoJ3NjbF9zbG9wZScpICAgICAgICAgICAgLy8gRGF0YSBzY2FsaW5nLCBzbG9wZS5cbiAgICAgICAgLmZsb2F0bGUoJ3NjbF9pbnRlcicpICAgICAgICAgICAgLy8gRGF0YSBzY2FsaW5nLCBvZmZzZXQuXG4gICAgICAgIC53b3JkMTZTbGUoJ3NsaWNlX2VuZCcpICAgICAgICAgICAgLy8gTGFzdCBzbGljZSBpbmRleC5cbiAgICAgICAgLndvcmQ4KCdzbGljZV9jb2RlJykgICAgICAgICAgICAvLyBTbGljZSB0aW1pbmcgb3JkZXIuXG4gICAgICAgIC53b3JkOCgneHl6dF91bml0cycpICAgICAgICAgICAgLy8gVW5pdHMgb2YgcGl4ZGltWzEuLjRdLlxuICAgICAgICAuZmxvYXRsZSgnY2FsX21heCcpICAgICAgICAgICAgICAgIC8vIE1heGltdW0gZGlzcGxheSBpbnRlbnNpdHkuXG4gICAgICAgIC5mbG9hdGxlKCdjYWxfbWluJykgICAgICAgICAgICAgICAgLy8gTWluaW11bSBkaXNwbGF5IGludGVuc2l0eS5cbiAgICAgICAgLmZsb2F0bGUoJ3NsaWNlX2R1cmF0aW9uJykgICAgICAgIC8vIFRpbWUgZm9yIG9uZSBzbGljZS5cbiAgICAgICAgLmZsb2F0bGUoJ3RvZmZzZXQnKSAgICAgICAgICAgICAgICAvLyBUaW1lIGF4aXMgc2hpZnQuXG4gICAgICAgIC53b3JkMzJTbGUoJ2dsbWF4JykgICAgICAgICAgICAgICAgLy8gTm90IHVzZWQ7IGNvbXBhdGliaWxpdHkgd2l0aCBhbmFseXplLlxuICAgICAgICAud29yZDMyU2xlKCdnbG1pbicpICAgICAgICAgICAgICAgIC8vIE5vdCB1c2VkOyBjb21wYXRpYmlsaXR5IHdpdGggYW5hbHl6ZS5cbiAgICAgICAgLmNoYXJzKCdkZXNjcmlwJyw4MCkgICAgICAgICAgICAvLyBBbnkgdGV4dC5cbiAgICAgICAgLmNoYXJzKCdhdXhfZmlsZScsMjQpICAgICAgICAgICAgLy8gQXV4aWxpYXJ5IGZpbGVuYW1lLlxuICAgICAgICAud29yZDE2U2xlKCdxZm9ybV9jb2RlJykgICAgICAgIC8vIFVzZSB0aGUgcXVhdGVybmlvbiBmaWVsZHMuXG4gICAgICAgIC53b3JkMTZTbGUoJ3Nmb3JtX2NvZGUnKSAgICAgICAgLy8gVXNlIG9mIHRoZSBhZmZpbmUgZmllbGRzLlxuICAgICAgICAuZmxvYXRsZSgncXVhdGVybl9iJykgICAgICAgICAgICAvLyBRdWF0ZXJuaW9uIGIgcGFyYW1ldGVyLlxuICAgICAgICAuZmxvYXRsZSgncXVhdGVybl9jJykgICAgICAgICAgICAvLyBRdWF0ZXJuaW9uIGMgcGFyYW1ldGVyLlxuICAgICAgICAuZmxvYXRsZSgncXVhdGVybl9kJykgICAgICAgICAgICAvLyBRdWF0ZXJuaW9uIGQgcGFyYW1ldGVyLlxuICAgICAgICAuZmxvYXRsZSgncW9mZnNldF94JykgICAgICAgICAgICAvLyBRdWF0ZXJuaW9uIHggc2hpZnQuXG4gICAgICAgIC5mbG9hdGxlKCdxb2Zmc2V0X3knKSAgICAgICAgICAgIC8vIFF1YXRlcm5pb24geSBzaGlmdC5cbiAgICAgICAgLmZsb2F0bGUoJ3FvZmZzZXRfeicpICAgICAgICAgICAgLy8gUXVhdGVybmlvbiB6IHNoaWZ0LlxuICAgICAgICAuYXJyYXkoJ3Nyb3dfeCcsNCwnZmxvYXRsZScpICAgIC8vIDFzdCByb3cgYWZmaW5lIHRyYW5zZm9ybVxuICAgICAgICAuYXJyYXkoJ3Nyb3dfeScsNCwnZmxvYXRsZScpICAgIC8vIDJuZCByb3cgYWZmaW5lIHRyYW5zZm9ybS5cbiAgICAgICAgLmFycmF5KCdzcm93X3onLDQsJ2Zsb2F0bGUnKSAgICAvLyAzcmQgcm93IGFmZmluZSB0cmFuc2Zvcm0uXG4gICAgICAgIC5jaGFycygnaW50ZW50X25hbWUnLDE2KSAgICAgICAgLy8gTmFtZSBvciBtZWFuaW5nIG9mIHRoZSBkYXRhLlxuICAgICAgICAuY2hhcnMoJ21hZ2ljJyw0KSwgICAgICAgICAgICAgICAgLy8gTWFnaWMgc3RyaW5nLlxuICAgIE5paUhkckJFOiBTdHJ1Y3QoKVxuICAgICAgICAud29yZDMyU2JlKCdzaXplb2ZfaGRyJykgICAgICAgIC8vIFNpemUgb2YgdGhlIGhlYWRlci4gTXVzdCBiZSAzNDggKGJ5dGVzKVxuICAgICAgICAuY2hhcnMoJ2RhdGFfdHlwZScsMTApICAgICAgICAgIC8vIE5vdCB1c2VkOyBjb21wYXRpYmlsaXR5IHdpdGggYW5hbHl6ZS5cbiAgICAgICAgLmNoYXJzKCdkYl9uYW1lJywxOCkgICAgICAgICAgICAvLyBOb3QgdXNlZDsgY29tcGF0aWJpbGl0eSB3aXRoIGFuYWx5emUuXG4gICAgICAgIC53b3JkMzJTYmUoJ2V4dGVudHMnKSAgICAgICAgICAgLy8gTm90IHVzZWQ7IGNvbXBhdGliaWxpdHkgd2l0aCBhbmFseXplLlxuICAgICAgICAud29yZDE2U2JlKCdzZXNzaW9uX2Vycm9yJykgICAgIC8vIE5vdCB1c2VkOyBjb21wYXRpYmlsaXR5IHdpdGggYW5hbHl6ZS5cbiAgICAgICAgLndvcmQ4KCdyZWd1bGFyJykgICAgICAgICAgICAgICAvLyBOb3QgdXNlZDsgY29tcGF0aWJpbGl0eSB3aXRoIGFuYWx5emUuXG4gICAgICAgIC53b3JkOCgnZGltX2luZm8nKSAgICAgICAgICAgICAgLy8gRW5jb2RpbmcgZGlyZWN0aW9ucyAocGhhc2UsIGZyZXF1ZW5jeSwgc2xpY2UpLlxuICAgICAgICAuYXJyYXkoJ2RpbScsOCwnd29yZDE2U2JlJykgICAgIC8vIERhdGEgYXJyYXkgZGltZW5zaW9ucy5cbiAgICAgICAgLmZsb2F0YmUoJ2ludGVudF9wMScpICAgICAgICAgICAvLyAxc3QgaW50ZW50IHBhcmFtZXRlci5cbiAgICAgICAgLmZsb2F0YmUoJ2ludGVudF9wMicpICAgICAgICAgICAvLyAybmQgaW50ZW50IHBhcmFtZXRlci5cbiAgICAgICAgLmZsb2F0YmUoJ2ludGVudF9wMycpICAgICAgICAgICAvLyAzcmQgaW50ZW50IHBhcmFtZXRlci5cbiAgICAgICAgLndvcmQxNlNiZSgnaW50ZW50X2NvZGUnKSAgICAgICAvLyBuaWZ0aSBpbnRlbnQuXG4gICAgICAgIC53b3JkMTZTYmUoJ2RhdGF0eXBlJykgICAgICAgICAgICAvLyBEYXRhIHR5cGUuXG4gICAgICAgIC53b3JkMTZTYmUoJ2JpdHBpeCcpICAgICAgICAgICAgLy8gTnVtYmVyIG9mIGJpdHMgcGVyIHZveGVsLlxuICAgICAgICAud29yZDE2U2JlKCdzbGljZV9zdGFydCcpICAgICAgICAvLyBGaXJzdCBzbGljZSBpbmRleC5cbiAgICAgICAgLmFycmF5KCdwaXhkaW0nLDgsJ2Zsb2F0YmUnKSAgICAvLyBHcmlkIHNwYWNpbmdzICh1bml0IHBlciBkaW1lbnNpb24pLlxuICAgICAgICAuZmxvYXRiZSgndm94X29mZnNldCcpICAgICAgICAgICAgLy8gT2Zmc2V0IGludG8gYSAubmlpIGZpbGUuXG4gICAgICAgIC5mbG9hdGJlKCdzY2xfc2xvcGUnKSAgICAgICAgICAgIC8vIERhdGEgc2NhbGluZywgc2xvcGUuXG4gICAgICAgIC5mbG9hdGJlKCdzY2xfaW50ZXInKSAgICAgICAgICAgIC8vIERhdGEgc2NhbGluZywgb2Zmc2V0LlxuICAgICAgICAud29yZDE2U2JlKCdzbGljZV9lbmQnKSAgICAgICAgICAgIC8vIExhc3Qgc2xpY2UgaW5kZXguXG4gICAgICAgIC53b3JkOCgnc2xpY2VfY29kZScpICAgICAgICAgICAgLy8gU2xpY2UgdGltaW5nIG9yZGVyLlxuICAgICAgICAud29yZDgoJ3h5enRfdW5pdHMnKSAgICAgICAgICAgIC8vIFVuaXRzIG9mIHBpeGRpbVsxLi40XS5cbiAgICAgICAgLmZsb2F0YmUoJ2NhbF9tYXgnKSAgICAgICAgICAgICAgICAvLyBNYXhpbXVtIGRpc3BsYXkgaW50ZW5zaXR5LlxuICAgICAgICAuZmxvYXRiZSgnY2FsX21pbicpICAgICAgICAgICAgICAgIC8vIE1pbmltdW0gZGlzcGxheSBpbnRlbnNpdHkuXG4gICAgICAgIC5mbG9hdGJlKCdzbGljZV9kdXJhdGlvbicpICAgICAgICAvLyBUaW1lIGZvciBvbmUgc2xpY2UuXG4gICAgICAgIC5mbG9hdGJlKCd0b2Zmc2V0JykgICAgICAgICAgICAgICAgLy8gVGltZSBheGlzIHNoaWZ0LlxuICAgICAgICAud29yZDMyU2JlKCdnbG1heCcpICAgICAgICAgICAgICAgIC8vIE5vdCB1c2VkOyBjb21wYXRpYmlsaXR5IHdpdGggYW5hbHl6ZS5cbiAgICAgICAgLndvcmQzMlNiZSgnZ2xtaW4nKSAgICAgICAgICAgICAgICAvLyBOb3QgdXNlZDsgY29tcGF0aWJpbGl0eSB3aXRoIGFuYWx5emUuXG4gICAgICAgIC5jaGFycygnZGVzY3JpcCcsODApICAgICAgICAgICAgLy8gQW55IHRleHQuXG4gICAgICAgIC5jaGFycygnYXV4X2ZpbGUnLDI0KSAgICAgICAgICAgIC8vIEF1eGlsaWFyeSBmaWxlbmFtZS5cbiAgICAgICAgLndvcmQxNlNiZSgncWZvcm1fY29kZScpICAgICAgICAvLyBVc2UgdGhlIHF1YXRlcm5pb24gZmllbGRzLlxuICAgICAgICAud29yZDE2U2JlKCdzZm9ybV9jb2RlJykgICAgICAgIC8vIFVzZSBvZiB0aGUgYWZmaW5lIGZpZWxkcy5cbiAgICAgICAgLmZsb2F0YmUoJ3F1YXRlcm5fYicpICAgICAgICAgICAgLy8gUXVhdGVybmlvbiBiIHBhcmFtZXRlci5cbiAgICAgICAgLmZsb2F0YmUoJ3F1YXRlcm5fYycpICAgICAgICAgICAgLy8gUXVhdGVybmlvbiBjIHBhcmFtZXRlci5cbiAgICAgICAgLmZsb2F0YmUoJ3F1YXRlcm5fZCcpICAgICAgICAgICAgLy8gUXVhdGVybmlvbiBkIHBhcmFtZXRlci5cbiAgICAgICAgLmZsb2F0YmUoJ3FvZmZzZXRfeCcpICAgICAgICAgICAgLy8gUXVhdGVybmlvbiB4IHNoaWZ0LlxuICAgICAgICAuZmxvYXRiZSgncW9mZnNldF95JykgICAgICAgICAgICAvLyBRdWF0ZXJuaW9uIHkgc2hpZnQuXG4gICAgICAgIC5mbG9hdGJlKCdxb2Zmc2V0X3onKSAgICAgICAgICAgIC8vIFF1YXRlcm5pb24geiBzaGlmdC5cbiAgICAgICAgLmFycmF5KCdzcm93X3gnLDQsJ2Zsb2F0YmUnKSAgICAvLyAxc3Qgcm93IGFmZmluZSB0cmFuc2Zvcm1cbiAgICAgICAgLmFycmF5KCdzcm93X3knLDQsJ2Zsb2F0YmUnKSAgICAvLyAybmQgcm93IGFmZmluZSB0cmFuc2Zvcm0uXG4gICAgICAgIC5hcnJheSgnc3Jvd196Jyw0LCdmbG9hdGJlJykgICAgLy8gM3JkIHJvdyBhZmZpbmUgdHJhbnNmb3JtLlxuICAgICAgICAuY2hhcnMoJ2ludGVudF9uYW1lJywxNikgICAgICAgIC8vIE5hbWUgb3IgbWVhbmluZyBvZiB0aGUgZGF0YS5cbiAgICAgICAgLmNoYXJzKCdtYWdpYycsNCksICAgICAgICAgICAgICAgIC8vIE1hZ2ljIHN0cmluZy5cbiAgICBNZ2hIZHI6IFN0cnVjdCgpXG4gICAgICAgIC53b3JkMzJTYmUoJ3YnKVxuICAgICAgICAud29yZDMyU2JlKCduZGltMScpXG4gICAgICAgIC53b3JkMzJTYmUoJ25kaW0yJylcbiAgICAgICAgLndvcmQzMlNiZSgnbmRpbTMnKVxuICAgICAgICAud29yZDMyU2JlKCduZnJhbWVzJylcbiAgICAgICAgLndvcmQzMlNiZSgndHlwZScpXG4gICAgICAgIC53b3JkMzJTYmUoJ2RvZicpXG4gICAgICAgIC53b3JkMTZTYmUoJ3Jhc19nb29kX2ZsYWcnKVxuICAgICAgICAuYXJyYXkoJ2RlbHRhJywzLCdmbG9hdGJlJylcbiAgICAgICAgLmFycmF5KCdNZGMnLDksJ2Zsb2F0YmUnKVxuICAgICAgICAuYXJyYXkoJ1B4eXpfYycsMywnZmxvYXRiZScpLFxuICAgIE1naEZ0cjogU3RydWN0KClcbiAgICAgICAgLmFycmF5KCdtcnBhcm1zJyw0LCdmbG9hdGJlJyksXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIGVuY29kZU5pZnRpXG4gICAgICovXG4gICAgZW5jb2RlTmlmdGk6IGZ1bmN0aW9uIGVuY29kZU5pZnRpKCkge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2coZW5jb2RlTmlmdGkpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuXG4gICAgICAgIHZhciBzaXplb2ZfaGRyPTM0ODtcbiAgICAgICAgdmFyIGRpbWVuc2lvbnM9NDsgICAgICAgICAgICAvLyBudW1iZXIgb2YgZGltZW5zaW9uIHZhbHVlcyBwcm92aWRlZFxuICAgICAgICB2YXIgc3BhY2V0aW1ldW5pdHM9Mis4OyAgICAgICAgLy8gMj1uaWZ0aSBjb2RlIGZvciBtaWxsaW1ldHJlcyB8IDg9bmlmdGkgY29kZSBmb3Igc2Vjb25kc1xuICAgICAgICB2YXIgZGF0YXR5cGU9MjsgICAgICAgICAgICAgICAgLy8gZGF0YXR5cGUgZm9yIDggYml0cyAoRFRfVUNIQVI4IGluIG5pZnRpIG9yIFVDSEFSIGluIGFuYWx5emUpXG4gICAgICAgIHZhciB2b3hfb2Zmc2V0PTM1MjtcbiAgICAgICAgdmFyIGJpdHNQZXJWb3hlbD04O1xuICAgIFxuICAgICAgICB2YXIgbmV3SGRyID0ge1xuICAgICAgICAgICAgc2l6ZW9mX2hkcjogc2l6ZW9mX2hkcixcbiAgICAgICAgICAgICAgICBkYXRhX3R5cGU6ICcnLCBkYl9uYW1lOiAnJywgZXh0ZW50czogMCwgc2Vzc2lvbl9lcnJvcjogMCwgcmVndWxhcjogMCwgZGltX2luZm86IDAsXG4gICAgICAgICAgICBkaW06IFszLCBtZS5Vc2VyLmRpbVswXSwgbWUuVXNlci5kaW1bMV0sIG1lLlVzZXIuZGltWzJdLCAxLCAxLCAxLCAxXSxcbiAgICAgICAgICAgICAgICBpbnRlbnRfcDE6IDAsIGludGVudF9wMjogMCwgaW50ZW50X3AzOiAwLCBpbnRlbnRfY29kZTogMCxcbiAgICAgICAgICAgIGRhdGF0eXBlOiBkYXRhdHlwZSwgICAgLy8gdWNoYXJcbiAgICAgICAgICAgIGJpdHBpeDogYml0c1BlclZveGVsLFxuICAgICAgICAgICAgICAgIHNsaWNlX3N0YXJ0OiAwLFxuICAgICAgICAgICAgcGl4ZGltOiBbLTEsIG1lLlVzZXIucGl4ZGltWzBdLCBtZS5Vc2VyLnBpeGRpbVsxXSwgbWUuVXNlci5waXhkaW1bMl0sIDAsIDEsIDEsIDFdLFxuICAgICAgICAgICAgdm94X29mZnNldDogdm94X29mZnNldCxcbiAgICAgICAgICAgICAgICBzY2xfc2xvcGU6IDEsIHNjbF9pbnRlcjogMCwgc2xpY2VfZW5kOiAwLCBzbGljZV9jb2RlOiAwLFxuICAgICAgICAgICAgICAgIHh5enRfdW5pdHM6IDEwLFxuICAgICAgICAgICAgICAgIGNhbF9tYXg6IDAsIGNhbF9taW46IDAsIHNsaWNlX2R1cmF0aW9uOiAwLCB0b2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgIGdsbWF4OiAwLCBnbG1pbjogMCxcbiAgICAgICAgICAgICAgICBkZXNjcmlwOiAnQnJhaW5Cb3gsIDIwIEF1Z3VzdCAyMDE2JyxcbiAgICAgICAgICAgICAgICBhdXhfZmlsZTogJycsXG4gICAgICAgICAgICAgICAgcWZvcm1fY29kZTogMCxcbiAgICAgICAgICAgICAgICBzZm9ybV9jb2RlOiAxLFxuICAgICAgICAgICAgICAgIHF1YXRlcm5fYjogMCwgcXVhdGVybl9jOiAwLCBxdWF0ZXJuX2Q6IDAsXG4gICAgICAgICAgICAgICAgcW9mZnNldF94OiAwLCBxb2Zmc2V0X3k6IDAsIHFvZmZzZXRfejogMCxcbiAgICAgICAgICAgIHNyb3dfeDogW21lLlVzZXIudjJ3WzBdWzBdLCBtZS5Vc2VyLnYyd1sxXVswXSwgbWUuVXNlci52MndbMl1bMF0sIG1lLlVzZXIud29yaVswXV0sXG4gICAgICAgICAgICBzcm93X3k6IFttZS5Vc2VyLnYyd1swXVsxXSwgbWUuVXNlci52MndbMV1bMV0sIG1lLlVzZXIudjJ3WzJdWzFdLCBtZS5Vc2VyLndvcmlbMV1dLFxuICAgICAgICAgICAgc3Jvd196OiBbbWUuVXNlci52MndbMF1bMl0sIG1lLlVzZXIudjJ3WzFdWzJdLCBtZS5Vc2VyLnYyd1syXVsyXSwgbWUuVXNlci53b3JpWzJdXSxcbiAgICAgICAgICAgICAgICBpbnRlbnRfbmFtZTogJycsXG4gICAgICAgICAgICAgICAgbWFnaWM6ICduKzEnXG4gICAgICAgIH07XG4gICAgICAgIG1lLk5paUhkckxFLmFsbG9jYXRlKCk7XG4gICAgICAgIG5paWhkciA9IG1lLk5paUhkckxFLmJ1ZmZlcigpO1xuICAgICAgICBmb3IoaSBpbiBuZXdIZHIpXG4gICAgICAgICAgICBtZS5OaWlIZHJMRS5maWVsZHNbaV0gPSBuZXdIZHJbaV07XG4gICAgICAgIGhkciA9IHRvQXJyYXlCdWZmZXIobmlpaGRyKTtcbiAgICAgICAgdmFyIGRhdGE9bWUuYXRsYXMuZGF0YTtcbiAgICAgICAgdmFyIG5paSA9IG5ldyBVaW50OEFycmF5KHZveF9vZmZzZXQrZGF0YS5sZW5ndGgpO1xuICAgICAgICBmb3IoaT0wO2k8c2l6ZW9mX2hkcjtpKyspXG4gICAgICAgICAgICBuaWlbaV09aGRyW2ldO1xuICAgICAgICBmb3IoaT0wO2k8ZGF0YS5sZW5ndGg7aSsrKVxuICAgICAgICAgICAgbmlpW2krdm94X29mZnNldF09ZGF0YVtpXTtcblxuICAgICAgICB2YXIgbmlpZ3o9bmV3IHBha28uRGVmbGF0ZSh7Z3ppcDp0cnVlfSk7XG4gICAgICAgIG5paWd6LnB1c2gobmlpLHRydWUpO1xuICAgICAgICAgICAgXG4gICAgICAgIHJldHVybiBuaWlnei5yZXN1bHQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gc2F2ZU5pZnRpXG4gICAgICovXG4gICAgc2F2ZU5pZnRpOiBmdW5jdGlvbiBzYXZlTmlmdGkoKSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyhzYXZlTmlmdGkpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuICAgIFxuICAgICAgICB2YXIgbmlpZ3o9bWUuZW5jb2RlTmlmdGkoKTtcbiAgICAgICAgdmFyIG5paWd6QmxvYiA9IG5ldyBCbG9iKFtuaWlnel0pO1xuICAgIFxuICAgICAgICAkKFwiYSNkb3dubG9hZF9hdGxhc1wiKS5hdHRyKFwiaHJlZlwiLHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG5paWd6QmxvYikpO1xuICAgICAgICAkKFwiYSNkb3dubG9hZF9hdGxhc1wiKS5hdHRyKFwiZG93bmxvYWRcIixtZS5Vc2VyLmF0bGFzRmlsZW5hbWUpO1xuICAgIH0sXG4gICAgc3dhcEludDE2OiBmdW5jdGlvbiBzd2FwSW50MTYoYXJyKSB7XG4gICAgICAgIHZhciBpLGR2ID0gbmV3IERhdGFWaWV3KGFyci5idWZmZXIpO1xuICAgICAgICBmb3IoaT0wO2k8YXJyLmxlbmd0aDtpKyspIHtcbiAgICAgICAgICAgIGFycltpXT0gZHYuZ2V0SW50MTYoMippLGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgc3dhcFVpbnQxNjogZnVuY3Rpb24gc3dhcFVpbnQxNihhcnIpIHtcbiAgICAgICAgdmFyIGksZHYgPSBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlcik7XG4gICAgICAgIGZvcihpPTA7aTxhcnIubGVuZ3RoO2krKykge1xuICAgICAgICAgICAgYXJyW2ldPSBkdi5nZXRVaW50MTYoMippLGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgc3dhcEludDMyOiBmdW5jdGlvbiBzd2FwSW50MzIoYXJyKSB7XG4gICAgICAgIHZhciBpLGR2ID0gbmV3IERhdGFWaWV3KGFyci5idWZmZXIpO1xuICAgICAgICBmb3IoaT0wO2k8YXJyLmxlbmd0aDtpKyspIHtcbiAgICAgICAgICAgIGFycltpXT0gZHYuZ2V0SW50MzIoNCppLGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgc3dhcEZsb2F0MzI6IGZ1bmN0aW9uIHN3YXBGbG9hdDMyKGFycikge1xuICAgICAgICB2YXIgaSxkdiA9IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyKTtcbiAgICAgICAgZm9yKGk9MDtpPGFyci5sZW5ndGg7aSsrKSB7XG4gICAgICAgICAgICBhcnJbaV09IGR2LmdldEZsb2F0MzIoNCppLGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIGxvYWROaWZ0aVxuICAgICAqL1xuICAgIGxvYWROaWZ0aTogZnVuY3Rpb24gbG9hZE5pZnRpKG5paSkge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2cobG9hZE5pZnRpLDEpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuICAgICAgICB2YXIgZW5kaWFubmVzcz0nbGUnO1xuXG4gICAgICAgIG1lLk5paUhkckxFLl9zZXRCdWZmKHRvQnVmZmVyKG5paSkpO1xuICAgICAgICB2YXIgaD1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1lLk5paUhkckxFLmZpZWxkcykpO1xuICAgICAgICBpZihoLnNpemVvZl9oZHIhPTM0OCkge1xuICAgICAgICAgICAgbWUuTmlpSGRyQkUuX3NldEJ1ZmYodG9CdWZmZXIobmlpKSk7XG4gICAgICAgICAgICBoPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobWUuTmlpSGRyQkUuZmllbGRzKSk7ICAgXG4gICAgICAgICAgICBlbmRpYW5uZXNzPSdiZSc7ICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciAgICB2b3hfb2Zmc2V0PWgudm94X29mZnNldDtcbiAgICAgICAgdmFyICAgIHNpemVvZl9oZHI9aC5zaXplb2ZfaGRyO1xuICAgIFxuICAgICAgICB2YXIgbXJpPXt9O1xuICAgICAgICBtcmkuaGRyPW5paS5zbGljZSgwLHZveF9vZmZzZXQpO1xuICAgICAgICBtcmkuZGF0YXR5cGU9aC5kYXRhdHlwZTtcbiAgICAgICAgbXJpLmRpbT1baC5kaW1bMV0saC5kaW1bMl0saC5kaW1bM11dO1xuICAgICAgICBtcmkucGl4ZGltPVtoLnBpeGRpbVsxXSxoLnBpeGRpbVsyXSxoLnBpeGRpbVszXV07XG4gICAgICAgIFxuICAgICAgICBzd2l0Y2gobXJpLmRhdGF0eXBlKVxuICAgICAgICB7XG4gICAgICAgICAgICBjYXNlIDI6IC8vIFVDSEFSXG4gICAgICAgICAgICAgICAgbXJpLmRhdGE9bmV3IFVpbnQ4QXJyYXkobmlpLHZveF9vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyNTY6IC8vIElOVDhcbiAgICAgICAgICAgICAgICBtcmkuZGF0YT1uZXcgVWludDhBcnJheShuaWksdm94X29mZnNldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6IC8vIFNIT1JUXG4gICAgICAgICAgICAgICAgaWYoZW5kaWFubmVzcz09J2xlJylcbiAgICAgICAgICAgICAgICAgICAgbXJpLmRhdGE9bmV3IEludDE2QXJyYXkobmlpLHZveF9vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgbXJpLmRhdGE9bWUuc3dhcEludDE2KG5ldyBJbnQxNkFycmF5KG5paSx2b3hfb2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDg6ICAvLyBJTlRcbiAgICAgICAgICAgICAgICBpZihlbmRpYW5uZXNzPT0nbGUnKVxuICAgICAgICAgICAgICAgICAgICBtcmkuZGF0YT1uZXcgSW50MzJBcnJheShuaWksdm94X29mZnNldCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBtcmkuZGF0YT1tZS5zd2FwSW50MzIobmV3IEludDMyQXJyYXkobmlpLHZveF9vZmZzZXQpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTY6IC8vIEZMT0FUXG4gICAgICAgICAgICAgICAgaWYoZW5kaWFubmVzcz09J2xlJylcbiAgICAgICAgICAgICAgICAgICAgbXJpLmRhdGE9bmV3IEZsb2F0MzJBcnJheShuaWksdm94X29mZnNldCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBtcmkuZGF0YT1tZS5zd2FwRmxvYXQzMihuZXcgRmxvYXQzMkFycmF5KG5paSx2b3hfb2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI1NjogLy8gSU5UOFxuICAgICAgICAgICAgICAgIG1yaS5kYXRhPW5ldyBJbnQ4QXJyYXkobmlpLHZveF9vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1MTI6IC8vIFVJTlQxNlxuICAgICAgICAgICAgICAgIGlmKGVuZGlhbm5lc3M9PSdsZScpXG4gICAgICAgICAgICAgICAgICAgIG1yaS5kYXRhPW5ldyBVaW50MTZBcnJheShuaWksdm94X29mZnNldCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBtcmkuZGF0YT1tZS5zd2FwVWludDE2KG5ldyBVaW50MTZBcnJheShuaWksdm94X29mZnNldCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVSUk9SOiBVbmtub3duIGRhdGFUeXBlOiBcIittcmkuZGF0YXR5cGUpO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIHJldHVybiBtcmk7XG4gICAgfSxcbiAgICAvKlxuICAgICAgICB7TGluZWFyIGFsZ2VicmFcbiAgICAqL1xuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBjb21wdXRlUzJWVHJhbnNmb3JtYXRpb25cbiAgICAgKi9cbiAgICBjb21wdXRlUzJWVHJhbnNmb3JtYXRpb246IGZ1bmN0aW9uIGNvbXB1dGVTMlZUcmFuc2Zvcm1hdGlvbigpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKGNvbXB1dGVTMlZUcmFuc2Zvcm1hdGlvbik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogQHRvZG8gTXVjaCBvZiB0aGUgY29kZSBkb3duc3RhaXJzIGNhbiBiZSByZW1vdmVkXG4gICAgICAgICAqL1xuXG4gICAgICAgIHZhciBtcmkgPSBtZS5Vc2VyO1xuICAgICAgICB2YXIgdjJ3PW1yaS52Mnc7XG4gICAgICAgIHZhciB3b3JpPW1yaS53b3JpO1xuICAgICAgICB2YXIgd3BpeGRpbT1tZS5zdWJWZWNWZWMobWUubXVsTWF0VmVjKHYydyxbMSwxLDFdKSxtZS5tdWxNYXRWZWModjJ3LFswLDAsMF0pKTtcbiAgICAgICAgdmFyIHd2bWF4PW1lLmFkZFZlY1ZlYyhtZS5tdWxNYXRWZWModjJ3LFttcmkuZGltWzBdLTEsbXJpLmRpbVsxXS0xLG1yaS5kaW1bMl0tMV0pLHdvcmkpO1xuICAgICAgICB2YXIgd3ZtaW49bWUuYWRkVmVjVmVjKG1lLm11bE1hdFZlYyh2MncsWzAsMCwwXSksd29yaSk7XG4gICAgICAgIHZhciB3bWluPVtNYXRoLm1pbih3dm1pblswXSx3dm1heFswXSksTWF0aC5taW4od3ZtaW5bMV0sd3ZtYXhbMV0pLE1hdGgubWluKHd2bWluWzJdLHd2bWF4WzJdKV07XG4gICAgICAgIHZhciB3bWF4PVtNYXRoLm1heCh3dm1pblswXSx3dm1heFswXSksTWF0aC5tYXgod3ZtaW5bMV0sd3ZtYXhbMV0pLE1hdGgubWF4KHd2bWluWzJdLHd2bWF4WzJdKV07XG4gICAgICAgIHZhciB3MnM9W1sxL01hdGguYWJzKHdwaXhkaW1bMF0pLDAsMF0sWzAsMS9NYXRoLmFicyh3cGl4ZGltWzFdKSwwXSxbMCwwLDEvTWF0aC5hYnMod3BpeGRpbVsyXSldXTtcblxuICAgICAgICB2YXIgaT12MndbMF07XG4gICAgICAgIHZhciBqPXYyd1sxXTtcbiAgICAgICAgdmFyIGs9djJ3WzJdO1xuICAgICAgICB2YXIgbWk9e2k6MCx2OjB9O2kubWFwKGZ1bmN0aW9uKG8sbil7aWYoTWF0aC5hYnMobyk+TWF0aC5hYnMobWkudikpIG1pPXtpOm4sdjpvfX0pO1xuICAgICAgICB2YXIgbWo9e2k6MCx2OjB9O2oubWFwKGZ1bmN0aW9uKG8sbil7aWYoTWF0aC5hYnMobyk+TWF0aC5hYnMobWoudikpIG1qPXtpOm4sdjpvfX0pO1xuICAgICAgICB2YXIgbWs9e2k6MCx2OjB9O2subWFwKGZ1bmN0aW9uKG8sbil7aWYoTWF0aC5hYnMobyk+TWF0aC5hYnMobWsudikpIG1rPXtpOm4sdjpvfX0pO1xuICAgICAgICBtcmkuczJ2ID0ge1xuICAgICAgICAgICAgLy8gb2xkIHMydiBmaWVsZHNcbiAgICAgICAgICAgIHMydzogbWUuaW52TWF0KHcycyksXG4gICAgICAgICAgICBzZGltOiBbXSxcbiAgICAgICAgICAgIHNvcmk6IFstd21pblswXS9NYXRoLmFicyh3cGl4ZGltWzBdKSwtd21pblsxXS9NYXRoLmFicyh3cGl4ZGltWzFdKSwtd21pblsyXS9NYXRoLmFicyh3cGl4ZGltWzJdKV0sXG4gICAgICAgICAgICB3cGl4ZGltOiBbXSxcbiAgICAgICAgICAgIHcydjogbWUuaW52TWF0KHYydyksXG4gICAgICAgICAgICB3b3JpOiB3b3JpLFxuXG4gICAgICAgICAgICAvLyBuZXcgczJ2IHRyYW5zZm9ybWF0aW9uXG4gICAgICAgICAgICB4OiBtaS5pLCAvLyBjb3JyZXNwb25kZW5jZSBiZXR3ZWVuIHNwYWNlIGNvb3JkaW5hdGUgeCBhbmQgdm94ZWwgY29vcmRpbmF0ZSBpXG4gICAgICAgICAgICB5OiBtai5pLCAvLyBzYW1lIGZvciB5XG4gICAgICAgICAgICB6OiBtay5pLCAvLyBzYW1lIGZvciB6XG4gICAgICAgICAgICBkeDogKG1pLnY+MCk/MTooLTEpLCAvLyBkaXJlY3Rpb24gb2YgZGlzcGxhY2VtZW50IGluIHNwYWNlIGNvb3JkaW5hdGUgeCB3aXRoIGRpc3BsYWNlbWVudCBpbiB2b3hlbCBjb29yZGluYXRlIGlcbiAgICAgICAgICAgIGR5OiAobWoudj4wKT8xOigtMSksIC8vIHNhbWUgZm9yIHlcbiAgICAgICAgICAgIGR6OiAobWsudj4wKT8xOigtMSksIC8vIHNhbWUgZm9yIHpcbiAgICAgICAgICAgIFg6IChtaS52PjApPzA6KG1yaS5kaW1bMF0tMSksIC8vIHN0YXJ0aW5nIHZhbHVlIGZvciBzcGFjZSBjb29yZGluYXRlIHggd2hlbiB2b3hlbCBjb29yZGluYXRlIGkgc3RhcnRzXG4gICAgICAgICAgICBZOiAobWoudj4wKT8wOihtcmkuZGltWzFdLTEpLCAvLyBzYW1lIGZvciB5XG4gICAgICAgICAgICBaOiAobWsudj4wKT8wOihtcmkuZGltWzJdLTEpIC8vIHNhbWUgZm9yIHpcbiAgICAgICAgfTtcbiAgICAgICAgbXJpLnYydz12Mnc7XG4gICAgICAgIG1yaS53b3JpPXdvcmk7XG4gICAgICAgIG1yaS5zMnYuc2RpbVttaS5pXSA9IG1yaS5kaW1bMF07XG4gICAgICAgIG1yaS5zMnYuc2RpbVttai5pXSA9IG1yaS5kaW1bMV07XG4gICAgICAgIG1yaS5zMnYuc2RpbVttay5pXSA9IG1yaS5kaW1bMl07XG4gICAgICAgIG1yaS5zMnYud3BpeGRpbVttaS5pXSA9IG1yaS5waXhkaW1bMF07XG4gICAgICAgIG1yaS5zMnYud3BpeGRpbVttai5pXSA9IG1yaS5waXhkaW1bMV07XG4gICAgICAgIG1yaS5zMnYud3BpeGRpbVttay5pXSA9IG1yaS5waXhkaW1bMl07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gdGVzdFMyVlRyYW5zZm9ybWF0aW9uXG4gICAgICovXG4gICAgdGVzdFMyVlRyYW5zZm9ybWF0aW9uOiBmdW5jdGlvbiB0ZXN0UzJWVHJhbnNmb3JtYXRpb24oKSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyh0ZXN0UzJWVHJhbnNmb3JtYXRpb24pO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICAgIGNoZWNrIHRoZSBTMlYgdHJhbnNmb3JtYXRpb24gdG8gc2VlIGlmIGl0IGxvb2tzIGNvcnJlY3QuXG4gICAgICAgICAgICBJZiBpdCBkb2VzIG5vdCwgcmVzZXQgaXRcbiAgICAgICAgKi9cbiAgICAgICAgdmFyIG1yaT1tZS5Vc2VyOyAvLyB0aGlzIGxpbmUgaXMgZGlmZmVyZW50IGZyb20gc2VydmVyXG4gICAgICAgIHZhciBkb1Jlc2V0PWZhbHNlO1xuICAgIFxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlRyYW5zZm9ybWF0aW9uIFRFU1Q6XCIpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIiAgMS4gdHJhbnNmb3JtYXRpb24gdm9sdW1lXCIpO1xuICAgICAgICBcbiAgICAgICAgdmFyIHZ2PW1yaS5kaW1bMF0qbXJpLmRpbVsxXSptcmkuZGltWzJdO1xuICAgICAgICB2YXIgdnM9bXJpLnMydi5zZGltWzBdKm1yaS5zMnYuc2RpbVsxXSptcmkuczJ2LnNkaW1bMl07XG4gICAgICAgIHZhciBkaWZmPSh2cy12dikvdnY7XG4gICAgICAgIGlmKE1hdGguYWJzKGRpZmYpPjAuMDAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIiAgICBFUlJPUjogRGlmZmVyZW5jZSBpcyB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIiAgICBvcmlnaW5hbCB2b2x1bWU6XCIsdnYpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCIgICAgcm90YXRlZCB2b2x1bWU6XCIsdnMpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCIgICAgJSBkaWZmZXJlbmNlOlwiLGRpZmYqMTAwKTtcbiAgICAgICAgICAgIGRvUmVzZXQ9dHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiICAgIG9rLlwiKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIiAgMi4gdHJhbnNmb3JtYXRpb24gb3JpZ2luXCIpO1xuICAgICAgICBpZiggICAgbXJpLnMydi5zb3JpWzBdPDB8fG1yaS5zMnYuc29yaVswXT5tcmkuczJ2LnNkaW1bMF0gfHxcbiAgICAgICAgICAgIG1yaS5zMnYuc29yaVsxXTwwfHxtcmkuczJ2LnNvcmlbMV0+bXJpLnMydi5zZGltWzFdIHx8XG4gICAgICAgICAgICBtcmkuczJ2LnNvcmlbMl08MHx8bXJpLnMydi5zb3JpWzJdPm1yaS5zMnYuc2RpbVsyXSkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCIgICAgT3JpZ2luIHBvaW50IGlzIG91dHNpZGUgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGRhdGFcIik7XG4gICAgICAgICAgICBkb1Jlc2V0PXRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIiAgICBvay5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZihkb1Jlc2V0KSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlRIRSBUUkFOU0ZPUk1BVElPTiBXSUxMIEJFIFJFU0VUXCIpO1xuICAgICAgICAgICAgbXJpLnYydz1bW21yaS5waXhkaW1bMF0sMCwwXSxbMCwtbXJpLnBpeGRpbVsxXSwwXSxbMCwwLC1tcmkucGl4ZGltWzJdXV07XG4gICAgICAgICAgICBtcmkud29yaT1bMCxtcmkuZGltWzFdLTEsbXJpLmRpbVsyXS0xXTtcblxuICAgICAgICAgICAgLy8gcmUtY29tcHV0ZSB0aGUgdHJhbnNmb3JtYXRpb24gZnJvbSB2b3hlbCBzcGFjZSB0byBzY3JlZW4gc3BhY2VcbiAgICAgICAgICAgIG1lLmNvbXB1dGVTMlZUcmFuc2Zvcm1hdGlvbigpOyAvLyB0aGlzIGxpbmUgaXMgZGlmZmVyZW50IGZyb20gc2VydmVyXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgY29uc29sZS5sb2cobXJpLmRpcik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtcmkub3JpKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1yaS5zMnYpO1xuICAgICAgICAgICAgKi9cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIFMySVxuICAgICAqL1xuICAgIFMySTogZnVuY3Rpb24gUzJJKHMsbXJpKSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyhTMkksMyk7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG4gICAgICAgIFxuICAgICAgICB2YXIgczJ2ID0gbXJpLnMydjtcbiAgICAgICAgdmFyIHYgPSBbczJ2LlgrczJ2LmR4KnNbczJ2LnhdLHMydi5ZK3Mydi5keSpzW3Mydi55XSxzMnYuWitzMnYuZHoqc1tzMnYuel1dO1xuICAgICAgICBjb25zdCBpbmRleCA9IHZbMF0gKyB2WzFdKm1yaS5kaW1bMF0gKyB2WzJdKm1yaS5kaW1bMF0qbXJpLmRpbVsxXTtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIG11bE1hdFZlY1xuICAgICAqL1xuICAgIG11bE1hdFZlYzogZnVuY3Rpb24gbXVsTWF0VmVjKG0sdikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbVswXVswXSp2WzBdK21bMF1bMV0qdlsxXSttWzBdWzJdKnZbMl0sXG4gICAgICAgICAgICBtWzFdWzBdKnZbMF0rbVsxXVsxXSp2WzFdK21bMV1bMl0qdlsyXSxcbiAgICAgICAgICAgIG1bMl1bMF0qdlswXSttWzJdWzFdKnZbMV0rbVsyXVsyXSp2WzJdXG4gICAgICAgIF07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gaW52TWF0XG4gICAgICovXG4gICAgaW52TWF0OiBmdW5jdGlvbiBpbnZNYXQobSkge1xuICAgICAgICB2YXIgZGV0O1xuICAgICAgICB2YXIgdz1bW10sW10sW11dO1xuXG4gICAgICAgIGRldD1tWzBdWzFdKm1bMV1bMl0qbVsyXVswXSArIG1bMF1bMl0qbVsxXVswXSptWzJdWzFdICsgbVswXVswXSptWzFdWzFdKm1bMl1bMl0gLSBtWzBdWzJdKm1bMV1bMV0qbVsyXVswXSAtIG1bMF1bMF0qbVsxXVsyXSptWzJdWzFdIC0gbVswXVsxXSptWzFdWzBdKm1bMl1bMl07XG4gICAgXG4gICAgICAgIHdbMF1bMF09KG1bMV1bMV0qbVsyXVsyXSAtIG1bMV1bMl0qbVsyXVsxXSkvZGV0O1xuICAgICAgICB3WzBdWzFdPShtWzBdWzJdKm1bMl1bMV0gLSBtWzBdWzFdKm1bMl1bMl0pL2RldDtcbiAgICAgICAgd1swXVsyXT0obVswXVsxXSptWzFdWzJdIC0gbVswXVsyXSptWzFdWzFdKS9kZXQ7XG4gICAgXG4gICAgICAgIHdbMV1bMF09KG1bMV1bMl0qbVsyXVswXSAtIG1bMV1bMF0qbVsyXVsyXSkvZGV0O1xuICAgICAgICB3WzFdWzFdPShtWzBdWzBdKm1bMl1bMl0gLSBtWzBdWzJdKm1bMl1bMF0pL2RldDtcbiAgICAgICAgd1sxXVsyXT0obVswXVsyXSptWzFdWzBdIC0gbVswXVswXSptWzFdWzJdKS9kZXQ7XG4gICAgXG4gICAgICAgIHdbMl1bMF09KG1bMV1bMF0qbVsyXVsxXSAtIG1bMV1bMV0qbVsyXVswXSkvZGV0O1xuICAgICAgICB3WzJdWzFdPShtWzBdWzFdKm1bMl1bMF0gLSBtWzBdWzBdKm1bMl1bMV0pL2RldDtcbiAgICAgICAgd1syXVsyXT0obVswXVswXSptWzFdWzFdIC0gbVswXVsxXSptWzFdWzBdKS9kZXQ7XG4gICAgXG4gICAgICAgIHJldHVybiB3O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIHN1YlZlY1ZlY1xuICAgICAqL1xuICAgIHN1YlZlY1ZlYzogZnVuY3Rpb24gc3ViVmVjVmVjKGEsYikge1xuICAgICAgICByZXR1cm4gW2FbMF0tYlswXSxhWzFdLWJbMV0sYVsyXS1iWzJdXTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBhZGRWZWNWZWNcbiAgICAgKi9cbiAgICBhZGRWZWNWZWM6IGZ1bmN0aW9uIGFkZFZlY1ZlYyhhLGIpIHtcbiAgICAgICAgcmV0dXJuIFthWzBdK2JbMF0sYVsxXStiWzFdLGFbMl0rYlsyXV07XG4gICAgfSxcbiAgICAvKlxuICAgICAgICBMaW5lYXIgQWxnZWJyYX1cbiAgICAqL1xufTsiLCIvKiEgQXRsYXNNYWtlcjogUGFpbnRpbmcgY29tbWFuZHMgKi9cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSdcblxuLyoqXG4gKiBAcGFnZSBBdGxhc01ha2VyOiBQYWludGluZyBjb21tYW5kc1xuICovXG5leHBvcnQgdmFyIEF0bGFzTWFrZXJQYWludCA9IHtcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFBhaW50IGZ1bmN0aW9uc1xuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgc2hvd3h5OiBmdW5jdGlvbiBzaG93eHkodSxjLHgseSx1c3IpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKHNob3d4eSwxLFwiIzBjMFwiKTtpZihsKWNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCxsKTtcbiAgICBcbiAgICAgICAgLy8gdTogdXNlciBudW1iZXJcbiAgICAgICAgLy8gYzogY29tbWFuZFxuICAgICAgICAvLyB4LCB5OiBjb29yZGluYXRlc1xuICAgICAgICBtc2c9e2M6IGMsIHg6IHgsIHk6IHl9O1xuICAgICAgICBpZih1PT0tMSAmJiBKU09OLnN0cmluZ2lmeShtc2cpIT1KU09OLnN0cmluZ2lmeShtZS5tc2cwKSkge1xuICAgICAgICAgICAgbWUuc2VuZFNob3dNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICBtZS5tc2cwPW1zZztcbiAgICAgICAgfVxuICAgICAgICBpZih1IT0tMSkge1xuICAgICAgICAgICAgc3dpdGNoKGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAgaWYodXNyLnBvaW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzci5wb2ludGVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHVzci5wb2ludGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgICAgICBpZighdXNyLnBvaW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzci5wb2ludGVyID0gJChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgc3R5bGU9XCJkaXNwbGF5OmlubGluZS1ibG9jaztoZWlnaHQ6MjBweDttYXJnaW4tbGVmdDotMTBweDttYXJnaW4tdG9wOi0xMHB4O3Bvc2l0aW9uOmFic29sdXRlO2NvbG9yOndoaXRlXCI+JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPGltZyBzcmM9XCInICsgbWUuaG9zdG5hbWUgKyAnL2ltZy9zaG93LnN2Z1wiIGhlaWdodD1cIjEwMCVcIi8+JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKHVzci51c2VybmFtZSA9PSAnQW5vbnltb3VzJyk/dTp1c3IudXNlcm5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKFwiI3Jlc2l6YWJsZVwiKS5hcHBlbmQodXNyLnBvaW50ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVzci5wb2ludGVyLmNzcyh7bGVmdDp4KiQoXCIjcmVzaXphYmxlXCIpLndpZHRoKCkvbWUuYnJhaW5fVyx0b3A6eSokKFwiI3Jlc2l6YWJsZVwiKS5oZWlnaHQoKS9tZS5icmFpbl9IfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVzci54MD14O1xuICAgICAgICB1c3IueTA9eTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBwYWludHh5XG4gICAgICogQGRlc2MgRGlzcGF0Y2hlcyBwYWludC9lcmFzZSBjb21tYW5kcyB0byB0aGUgYW5ub3RhdGlvbiB2b2x1bWUgYW5kIHRvIHRoZSBzZXJ2ZXIgZm9yIGJyb2FkY2FzdFxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gdSBUaGUgbnVtYmVyIG9mIHRoZSB1c2VyIHByb2R1Y2luZyB0aGUgcGFpbnQgZXZlbnQuIHUgPT09IC0xIG1lYW5zIHRoYXQgdGhlIHBhaW50IGV2ZW50IHdhcyBwcm9kdWNlZCBieSBhIGRpZmZlcmVudCB1c2VyLCBhbmQgaXQgaXMgbm90IGJyb2FkY2FzdGVkICh0byBwcmV2ZW50IGxvb3BzKVxuICAgICAqIEBwYXJhbSB7Y2hhcmFjdGVyfSBjIFRoZSBwYWludCBjb21tYW5kOiBsZSwgbGYsIGUsIGYuXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSB4IFggY29vcmRpbmF0ZSBpbiBzbGljZSBzcGFjZVxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0geSBZIGNvb3JkaW5hdGUgaW4gc2xpY2Ugc3BhY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdXNyIFVzZXIgb2JqZWN0IGZvciB0aGUgY3VycmVudCB1c2VyLiBDb250YWlucyB0aGUgcGFpbnRpbmcgdmFsdWUsIHZpZXcgYW5kIHNsaWNlXG4gICAgICovXG4gICAgcGFpbnR4eTogZnVuY3Rpb24gcGFpbnR4eSh1LGMseCx5LHVzcikge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2cocGFpbnR4eSwxLFwiIzBjMFwiKTtpZihsKWNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCxsKTtcbiAgICBcbiAgICAgICAgLy8gdTogdXNlciBudW1iZXJcbiAgICAgICAgLy8gYzogY29tbWFuZFxuICAgICAgICAvLyB4LCB5OiBjb29yZGluYXRlc1xuICAgICAgICBtc2c9e2M6Yyx4OngseTp5fTtcbiAgICAgICAgXG4gICAgICAgIGlmKHU9PS0xICYmIEpTT04uc3RyaW5naWZ5KG1zZykhPUpTT04uc3RyaW5naWZ5KG1lLm1zZzApKSB7XG4gICAgICAgICAgICBtZS5zZW5kUGFpbnRNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICBtZS5tc2cwPW1zZztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyICAgIGRpbT1tZS5hdGxhcy5kaW07XG4gICAgXG4gICAgICAgIHZhciAgICBjb29yZD17eDp4LHk6eSx6OnVzci5zbGljZX07XG4gICAgICAgIGlmKHVzci54MDwwKSB7XG4gICAgICAgICAgICB1c3IueDA9Y29vcmQueDtcbiAgICAgICAgICAgIHVzci55MD1jb29yZC55O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodSE9LTEpIHtcbiAgICAgICAgICAgIGlmKGMgPT09ICdtdScpIHtcbiAgICAgICAgICAgICAgICBpZih1c3IucG9pbnRlcikge1xuICAgICAgICAgICAgICAgICAgICB1c3IucG9pbnRlci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHVzci5wb2ludGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYoIXVzci5wb2ludGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzci5wb2ludGVyID0gJChbXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBzdHlsZT1cImRpc3BsYXk6aW5saW5lLWJsb2NrO2hlaWdodDoyMHB4O21hcmdpbi1sZWZ0Oi0xMHB4O21hcmdpbi10b3A6LTEwcHg7cG9zaXRpb246YWJzb2x1dGU7Y29sb3I6d2hpdGVcIj4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJzxpbWcgc3JjPVwiJyArIG1lLmhvc3RuYW1lICsgJy9pbWcvc2hvdy5zdmdcIiBoZWlnaHQ9XCIxMDAlXCIvPicsXG4gICAgICAgICAgICAgICAgICAgICAgICAoKHVzci51c2VybmFtZSA9PSAnQW5vbnltb3VzJyk/dTp1c3IudXNlcm5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJzwvZGl2PidcbiAgICAgICAgICAgICAgICAgICAgICAgIF0uam9pbignJykpO1xuICAgICAgICAgICAgICAgICAgICAkKFwiI3Jlc2l6YWJsZVwiKS5hcHBlbmQodXNyLnBvaW50ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1c3IucG9pbnRlci5jc3Moe2xlZnQ6eCokKFwiI3Jlc2l6YWJsZVwiKS53aWR0aCgpL21lLmJyYWluX1csdG9wOnkqJChcIiNyZXNpemFibGVcIikuaGVpZ2h0KCkvbWUuYnJhaW5fSH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB2YWw9dXNyLnBlblZhbHVlO1xuICAgICAgICBzd2l0Y2goYykge1xuICAgICAgICAgICAgY2FzZSAnbGUnOlxuICAgICAgICAgICAgICAgIG1lLmxpbmUoY29vcmQueCxjb29yZC55LDAsdXNyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xmJzpcbiAgICAgICAgICAgICAgICBtZS5saW5lKGNvb3JkLngsY29vcmQueSx2YWwsdXNyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICAgIG1lLmZpbGwoY29vcmQueCxjb29yZC55LGNvb3JkLnosMCx1c3Iudmlldyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICBtZS5maWxsKGNvb3JkLngsY29vcmQueSxjb29yZC56LHZhbCx1c3Iudmlldyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB1c3IueDA9Y29vcmQueDtcbiAgICAgICAgdXNyLnkwPWNvb3JkLnk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gcGFpbnR2b2xcbiAgICAgKiBAZGVzYyBQYWludHMgYSBzZXJpZXMgb2Ygdm94ZWxzIGFzIGluZGljYXRlZCBpbiBhbiBhcnJheS4gVGhpcyBmdW5jdGlvbiBpcyBleGNsdXNpdmVseSB1c2VkIGZvciB1bmRvaW5nXG4gICAgICogQHBhcmFtIHtBcnJheX0gdm94ZWxzIEFycmF5IHdoZXJlIGVhY2ggb2JqZWN0IGNvbnRhaW5zIGEgdm94ZWwgaW5kZXggYW5kIGEgdm94ZWwgdmFsdWUuIFRoZSB2b3hlbCBpbmRleCBnb2VzIGZyb20gMCB0byBkaW1bMF0qZGltWzFdKmRpbVsyXS0xXG4gICAgICovXG4gICAgcGFpbnR2b2w6IGZ1bmN0aW9uIHBhaW50dm9sKHZveGVscykge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2cocGFpbnR2b2wsMCxcIiMwYzBcIik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG4gICAgXG4gICAgICAgIHZhciAgICBpLFxuICAgICAgICAgICAgaW5kLCAgICAgICAgICAgIC8vIHZveGVsIGluZGV4XG4gICAgICAgICAgICB2YWw7ICAgICAgICAgICAgLy8gdm94ZWwgZGVsdGEtdmFsdWUsIHN1Y2ggdGhhdCAtPXZhbCB1bmRvZXNcbiAgICAgICAgZm9yKGk9MDtpPHZveGVscy5sZW5ndGg7aSsrKSB7XG4gICAgICAgICAgICBpbmQ9dm94ZWxzW2ldWzBdO1xuICAgICAgICAgICAgdmFsPXZveGVsc1tpXVsxXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbWUuYXRsYXMuZGF0YVtpbmRdPXZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmRyYXdJbWFnZXMoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBmaWxsXG4gICAgICogQGRlc2MgRmlsbHMgYSAyRCBzbGljZSBpbiBhbiBhbm5vdGF0aW9uIHZvbHVtZSBzdGFydGluZyBhdCBjb29yZGluYXRlcyB4LCB5LCB6IHJlcGxhY2luZyBhbGwgdGhlIGNvbm5lY3RlZCBwaXhlbHMgb2Ygc2FtZSB2YWx1ZSBhcyB0aGUgb3JpZ2luYWwgdmFsdWUgYXQgeCwgeSwgelxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0geCBYIGNvb3JkaW5hdGUgaW4gdm94ZWwgc3BhY2VcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHkgWSBjb29yZGluYXRlIGluIHZveGVsIHNwYWNlXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSB6IFogY29vcmRpbmF0ZSBpbiB2b3hlbCBzcGFjZVxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gdmFsIFZhbHVlIHRvIGZpbGwgd2l0aFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBteVZpZXcgVGhlIHN0ZXJlb3RheGljIHBsYW5lIGFsb25nIHdoaWNoIHRvIGZpbGw6IGVpdGhlciAnY29yJywgJ2F4aScgb3IgJ3NhZydcbiAgICAgKi9cbiAgICBmaWxsOiBmdW5jdGlvbiBmaWxsKHgseSx6LHZhbCxteVZpZXcpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKGZpbGwsMCxcIiMwYzBcIik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG4gICAgXG4gICAgICAgIHZhciAgICBhdGxhcz1tZS5hdGxhcztcbiAgICAgICAgdmFyICAgIGRpbT1hdGxhcy5kaW07XG5cbiAgICAgICAgdmFyICAgIFE9W10sXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICBuO1xuICAgICAgICB2YXIgICAgaSxtYXg9MDtcbiAgICAgICAgdmFyIGJ2YWw9YXRsYXMuZGF0YVttZS5zbGljZTJpbmRleCh4LHkseixteVZpZXcpXTsgLy8gYmFja2dyb3VuZC12YWx1ZTogdmFsdWUgb2YgdGhlIHZveGVsIHdoZXJlIHRoZSBjbGljayBvY2N1cnJlZFxuICAgICAgICBcbiAgICAgICAgaWYoYnZhbD09dmFsKSAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBRLnB1c2goe3g6eCx5Onl9KTtcbiAgICAgICAgd2hpbGUoUS5sZW5ndGg+MCkge1xuICAgICAgICAgICAgaWYoUS5sZW5ndGg+bWF4KVxuICAgICAgICAgICAgICAgIG1heD1RLmxlbmd0aDtcbiAgICAgICAgICAgIG49US5zaGlmdCgpO1xuICAgICAgICAgICAgaWYoYXRsYXMuZGF0YVttZS5zbGljZTJpbmRleChuLngsbi55LHosbXlWaWV3KV0hPWJ2YWwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZWZ0PW4ueDtcbiAgICAgICAgICAgIHJpZ2h0PW4ueDtcbiAgICAgICAgICAgIHk9bi55O1xuICAgICAgICAgICAgd2hpbGUgKGxlZnQtMT49MCAmJiBhdGxhcy5kYXRhW21lLnNsaWNlMmluZGV4KGxlZnQtMSx5LHosbXlWaWV3KV09PWJ2YWwpIHtcbiAgICAgICAgICAgICAgICBsZWZ0LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAocmlnaHQrMTxtZS5icmFpbl9XICYmIGF0bGFzLmRhdGFbbWUuc2xpY2UyaW5kZXgocmlnaHQrMSx5LHosbXlWaWV3KV09PWJ2YWwpIHtcbiAgICAgICAgICAgICAgICByaWdodCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yKHg9bGVmdDt4PD1yaWdodDt4KyspIHtcbiAgICAgICAgICAgICAgICBhdGxhcy5kYXRhW21lLnNsaWNlMmluZGV4KHgseSx6LG15VmlldyldPXZhbDtcbiAgICAgICAgICAgICAgICBpZih5LTE+PTAgICAgICAgICAmJiBhdGxhcy5kYXRhW21lLnNsaWNlMmluZGV4KHgseS0xLHosbXlWaWV3KV09PWJ2YWwpXG4gICAgICAgICAgICAgICAgICAgIFEucHVzaCh7eDp4LHk6eS0xfSk7XG4gICAgICAgICAgICAgICAgaWYoeSsxPG1lLmJyYWluX0ggJiYgYXRsYXMuZGF0YVttZS5zbGljZTJpbmRleCh4LHkrMSx6LG15VmlldyldPT1idmFsKVxuICAgICAgICAgICAgICAgICAgICBRLnB1c2goe3g6eCx5OnkrMX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1lLmRyYXdJbWFnZXMoKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJtYXggYXJyYXkgc2l6ZSBmb3IgZmlsbDpcIixtYXgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIGxpbmVcbiAgICAgKi9cbiAgICBsaW5lOiBmdW5jdGlvbiBsaW5lKHgseSx2YWwsdXNyKSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyhsaW5lLDEsXCIjMGMwXCIpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuICAgIFxuICAgICAgICAvLyBCcmVzZW5oYW0ncyBsaW5lIGFsZ29yaXRobSBhZGFwdGVkIGZyb21cbiAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80NjcyMjc5L2JyZXNlbmhhbS1hbGdvcml0aG0taW4tamF2YXNjcmlwdFxuXG4gICAgICAgIHZhciAgICBhdGxhcz1tZS5hdGxhcztcbiAgICAgICAgdmFyICAgIGRpbT1hdGxhcy5kaW07XG4gICAgICAgIHZhciAgICB4eXppMT1uZXcgQXJyYXkoNCk7XG4gICAgICAgIHZhciAgICB4eXppMj1uZXcgQXJyYXkoNCk7XG4gICAgICAgIHZhciAgICBpO1xuICAgICAgICB2YXIgICAgeDE9dXNyLngwO1xuICAgICAgICB2YXIgeTE9dXNyLnkwO1xuICAgICAgICB2YXIgeDI9eDtcbiAgICAgICAgdmFyIHkyPXk7XG4gICAgICAgIHZhciAgICB6PXVzci5zbGljZTtcblxuICAgICAgICAvLyBEZWZpbmUgZGlmZmVyZW5jZXMgYW5kIGVycm9yIGNoZWNrXG4gICAgICAgIHZhciBkeCA9IE1hdGguYWJzKHgyIC0geDEpO1xuICAgICAgICB2YXIgZHkgPSBNYXRoLmFicyh5MiAtIHkxKTtcbiAgICAgICAgdmFyIHN4ID0gKHgxIDwgeDIpID8gMSA6IC0xO1xuICAgICAgICB2YXIgc3kgPSAoeTEgPCB5MikgPyAxIDogLTE7XG4gICAgICAgIHZhciBlcnIgPSBkeCAtIGR5O1xuXG4gICAgICAgIHh5emkxPW1lLnNsaWNlMnh5emkoeDEseTEseix1c3Iudmlldyk7XG4gICAgICAgIHh5emkyPW1lLnNsaWNlMnh5emkoeDIseTIseix1c3Iudmlldyk7XG4gICAgICAgIG1lLmFubm90YXRpb25MZW5ndGgrPU1hdGguc3FydCggICAgTWF0aC5wb3cobWUuYnJhaW5fcGl4ZGltWzBdKih4eXppMVswXS14eXppMlswXSksMikrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3cobWUuYnJhaW5fcGl4ZGltWzFdKih4eXppMVsxXS14eXppMlsxXSksMikrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3cobWUuYnJhaW5fcGl4ZGltWzJdKih4eXppMVsyXS14eXppMlsyXSksMikpO1xuICAgIFxuICAgICAgICBmb3Ioaj0wO2o8TWF0aC5taW4odXNyLnBlblNpemUsbWUuYnJhaW5fVy14MSk7aisrKVxuICAgICAgICBmb3Ioaz0wO2s8TWF0aC5taW4odXNyLnBlblNpemUsbWUuYnJhaW5fSC15MSk7aysrKSB7XG4gICAgICAgICAgICBpPW1lLnNsaWNlMmluZGV4KHgxK2oseTErayx6LHVzci52aWV3KTtcbiAgICAgICAgICAgIGF0bGFzLmRhdGFbaV09dmFsO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIHdoaWxlICghKCh4MSA9PSB4MikgJiYgKHkxID09IHkyKSkpIHtcbiAgICAgICAgICAgIHZhciBlMiA9IGVyciA8PCAxO1xuICAgICAgICAgICAgaWYgKGUyID4gLWR5KSB7XG4gICAgICAgICAgICAgICAgZXJyIC09IGR5O1xuICAgICAgICAgICAgICAgIHgxICs9IHN4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUyIDwgZHgpIHtcbiAgICAgICAgICAgICAgICBlcnIgKz0gZHg7XG4gICAgICAgICAgICAgICAgeTEgKz0gc3k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3Ioaj0wO2o8TWF0aC5taW4odXNyLnBlblNpemUsbWUuYnJhaW5fVy14MSk7aisrKVxuICAgICAgICAgICAgZm9yKGs9MDtrPE1hdGgubWluKHVzci5wZW5TaXplLG1lLmJyYWluX0gteTEpO2srKykge1xuICAgICAgICAgICAgICAgIGk9bWUuc2xpY2UyaW5kZXgoeDEraix5MStrLHosdXNyLnZpZXcpO1xuICAgICAgICAgICAgICAgIGF0bGFzLmRhdGFbaV09dmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1lLmRyYXdJbWFnZXMoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBzbGljZTJpbmRleFxuICAgICAqL1xuICAgIHNsaWNlMmluZGV4OiBmdW5jdGlvbiBzbGljZTJpbmRleChteCxteSxteixteVZpZXcpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKHNsaWNlMmluZGV4LDMsXCIjMGMwXCIpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuICAgIFxuICAgICAgICB2YXIgICAgZGltPW1lLmF0bGFzLmRpbTtcbiAgICAgICAgdmFyICAgIHgseSx6LGk7XG4gICAgICAgIHN3aXRjaChteVZpZXcpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NhZyc6ICAgIHg9bXo7IHk9bXg7IHo9bWUuYnJhaW5fSC0xLW15O2JyZWFrOyAvLyBzYWdpdGFsXG4gICAgICAgICAgICBjYXNlICdjb3InOiAgICB4PW14OyB5PW16OyB6PW1lLmJyYWluX0gtMS1teTticmVhazsgLy8gY29yb25hbFxuICAgICAgICAgICAgY2FzZSAnYXhpJzogICAgeD1teDsgeT1tZS5icmFpbl9ILTEtbXk7IHo9bXo7YnJlYWs7IC8vIGF4aWFsXG4gICAgICAgIH1cbi8qXG4gICAgVFJBTlNGT1JNIFNDUkVFTiBTUEFDRSBJTlRPIFZPWEVMIElOREVYXG4qL1xuICAgICAgICB2YXIgcz1beCx5LHpdO1xuICAgICAgICBpPW1lLlMySShzLG1lLlVzZXIpO1xuXG4gICAgICAgIHJldHVybiBpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIHNsaWNlMnh5emlcbiAgICAgKiBAZGVzYyBDb252ZXJ0IHNsaWNlIGNvb3JkaW5hdGVzIGludG8gdm94ZWwgY29vcmRpbmF0ZXNcbiAgICAgKiBAcmV0dXJuIEFuIGFycmF5IFt4LHkseixpXSB3aGVyZSB0aGUgZmlyc3QgMyB2YWx1ZXMgYXJlIHRoZSB2b3hlbCBjb29yZGluYXRlcyBhbmQgdGhlIDR0aCB2YWx1ZSBpcyB0aGUgdm94ZWwgaW5kZXggKHZhbHVlIGZyb20gMCB0byBkaW1bMF0qZGltWzFdKmRpbVsyXS0xKVxuICAgICAqL1xuICAgIHNsaWNlMnh5emk6IGZ1bmN0aW9uIHNsaWNlMnh5emkobXgsbXksbXosbXlWaWV3KSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyhzbGljZTJ4eXppLDEsXCIjMGMwXCIpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuICAgIFxuICAgICAgICB2YXIgICAgZGltPW1lLmF0bGFzLmRpbTtcbiAgICAgICAgdmFyICAgIHgseSx6LGk7XG4gICAgICAgIHN3aXRjaChteVZpZXcpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NhZyc6ICAgIHg9bXo7IHk9bXg7IHo9bWUuYnJhaW5fSC0xLW15O2JyZWFrOyAvLyBzYWdpdGFsXG4gICAgICAgICAgICBjYXNlICdjb3InOiAgICB4PW14OyB5PW16OyB6PW1lLmJyYWluX0gtMS1teTticmVhazsgLy8gY29yb25hbFxuICAgICAgICAgICAgY2FzZSAnYXhpJzogICAgeD1teDsgeT1tZS5icmFpbl9ILTEtbXk7IHo9bXo7YnJlYWs7IC8vIGF4aWFsXG4gICAgICAgIH1cbi8qXG4gICAgVFJBTlNGT1JNIFNDUkVFTiBTUEFDRSBJTlRPIFZPWEVMIElOREVYXG4qL1xuICAgICAgICB2YXIgcz1beCx5LHpdO1xuICAgICAgICBpPW1lLlMySShzLG1lLlVzZXIpO1xuXG4gICAgICAgIHJldHVybiBbeCx5LHosaV07ICAgIFxuICAgIH1cbn07XG4iLCIvKiEgQXRsYXNNYWtlcjogVXNlciBJbnRlcmZhY2UgRWxlbWVudHMgKi9cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSdcblxuLyoqXG4gKiBAcGFnZSBBdGxhc01ha2VyOiBVc2VyIEludGVyZmFjZSBFbGVtZW50c1xuICovXG5leHBvcnQgdmFyIEF0bGFzTWFrZXJVSSA9IHtcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gc2xpZGVyXG4gICAgICovXG4gICAgc2xpZGVyOiBmdW5jdGlvbiBzbGlkZXIoZWxlbSxjYWxsYmFjaykge1xuICAgICAgICAvLyBJbml0aWFsaXNlIGEgJ3NsaWRlcicgY29udHJvbFxuXG4gICAgICAgICQoZWxlbSkuZGF0YSh7XG4gICAgICAgICAgICBkcmFnOmZhbHNlLFxuICAgICAgICAgICAgdmFsOjAsXG4gICAgICAgICAgICBtYXg6MTAwXG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICB2YXIgbW92ZXg9ZnVuY3Rpb24oZWwsY2xpZW50WCkge1xuICAgICAgICAgICAgaWYgKCQoZWwpLmRhdGEoXCJkcmFnXCIpPT10cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIFI9JChlbCkuZmluZChcIi50cmFja1wiKVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgeD0oY2xpZW50WC1SLmxlZnQpL1Iud2lkdGg7XG4gICAgICAgICAgICAgICAgaWYoeDwwKSB4PTA7XG4gICAgICAgICAgICAgICAgaWYoeD4xKSB4PTE7XG4gICAgICAgICAgICAgICAgeD14KiQoZWwpLmRhdGEoXCJtYXhcIik7XG4gICAgICAgICAgICAgICAgaWYoeCE9JChlbCkuZGF0YShcInZhbFwiKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4PSQoZWwpLmRhdGEoXCJtYXhcIik7XG4gICAgICAgICAgICAgICAgICAgICQoZWwpLmRhdGEoXCJ2YWxcIix4KTtcbiAgICAgICAgICAgICAgICAgICAgJChlbCkuZmluZChcIi50aHVtYlwiKVswXS5zdHlsZS5sZWZ0PSh4KjEwMC9tYXgpK1wiJVwiO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgICQoZG9jdW1lbnQpLm9uKFwibW91c2Vtb3ZlXCIsZnVuY3Rpb24gZnJvbV9zbGlkZXIoZXYpe21vdmV4KGVsZW0sZXYuY2xpZW50WCk7fSk7XG4gICAgICAgICQoZG9jdW1lbnQpLm9uKFwidG91Y2htb3ZlXCIsZnVuY3Rpb24gZnJvbV9zbGlkZXIoZXYpe21vdmV4KGVsZW0sZXYub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCk7fSk7ICAgICAgICBcbiAgICAgICAgJChkb2N1bWVudCkub24oXCJtb3VzZXVwIHRvdWNoZW5kXCIsZnVuY3Rpb24gZnJvbV9zbGlkZXIoKXskKGVsZW0pLmRhdGEoe2RyYWc6ZmFsc2V9KX0pO1xuICAgICAgICAkKGVsZW0pLm9uKCdtb3VzZWRvd24gdG91Y2hzdGFydCcsZnVuY3Rpb24gZnJvbV9zbGlkZXIoKXskKGVsZW0pLmRhdGEoe2RyYWc6dHJ1ZX0pfSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gY2hvc2VcbiAgICAgKi9cbiAgICBjaG9zZTogZnVuY3Rpb24gY2hvc2UoZWxlbSxjYWxsYmFjaykge1xuICAgICAgICAvLyBJbml0aWFsaXNlIGEgJ2Nob3NlJyBjb250cm9sXG4gICAgICAgIHZhciBjaD0kKGVsZW0pLmZpbmQoXCIuYVwiKTtcbiAgICAgICAgY2guZWFjaChmdW5jdGlvbihjLGQpe1xuICAgICAgICAgICAgJChkKS5jbGljayhmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGlmKCQodGhpcykuaGFzQ2xhc3MoXCJwcmVzc2VkXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCQodGhpcykuYXR0cigndGl0bGUnKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2guZWFjaChmdW5jdGlvbigpeyQodGhpcykucmVtb3ZlQ2xhc3MoXCJwcmVzc2VkXCIpfSk7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyhcInByZXNzZWRcIik7XG4gICAgICAgICAgICAgICAgaWYoY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCQodGhpcykuYXR0cigndGl0bGUnKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gdG9nZ2xlXG4gICAgICovXG4gICAgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUoZWxlbSxjYWxsYmFjaykge1xuICAgICAgICAvLyBJbml0aWFsaXNlIGEgJ3RvZ2dsZScgY29udHJvbFxuICAgICAgICAkKGVsZW0pLmNsaWNrKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAkKHRoaXMpLmhhc0NsYXNzKFwicHJlc3NlZFwiKT8kKHRoaXMpLnJlbW92ZUNsYXNzKFwicHJlc3NlZFwiKTokKHRoaXMpLmFkZENsYXNzKFwicHJlc3NlZFwiKTtcbiAgICAgICAgICAgIGlmKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCQodGhpcykuaGFzQ2xhc3MoXCJwcmVzc2VkXCIpKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gcHVzaFxuICAgICAqL1xuICAgIHB1c2g6IGZ1bmN0aW9uIHB1c2goZWxlbSxjYWxsYmFjaykge1xuICAgICAgICAvLyBJbml0aWFsaXNlIGEgJ3B1c2gnIGNvbnRyb2xcbiAgICAgICAgJChlbGVtKS5jbGljayhmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYoY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTsiLCIvKiEgQXRsYXNNYWtlcjogV2ViU29ja2V0cyAqL1xuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuaW1wb3J0ICogYXMgcGFrbyBmcm9tICcuLi8uLi9kb3dubG9hZHMvcGFrby5taW4uanMnO1xuXG4vKipcbiAqIEBwYWdlIEF0bGFzTWFrZXI6IFdlYlNvY2tldHNcbiAqL1xuZXhwb3J0IHZhciBBdGxhc01ha2VyV1MgPSB7XG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBXZWIgc29ja2V0c1xuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIGNyZWF0ZVNvY2tldFxuICAgICAqIEBkZXNjICBDcmVhdGUgYSBXZWJTb2NrZXQgY29ubmVjdGlvbiB1c2luZyB0aGUgV2ViU29ja2V0IG9iamVjdCBvciB0aGUgTW96V2ViU29ja2V0XG4gICAgICogICAgICAgIG9iamVjdC5cbiAgICAgKi9cbiAgICBjcmVhdGVTb2NrZXQ6IGZ1bmN0aW9uIGNyZWF0ZVNvY2tldChob3N0KSB7XG4gICAgICAgIHZhciBtZSA9IEF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsID0gbWUudHJhY2VMb2coY3JlYXRlU29ja2V0LCAwLCBcIiNhY2FcIik7IGlmIChsKSBjb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsIGwpO1xuXG4gICAgICAgIHZhciB3cztcblxuICAgICAgICBpZiAod2luZG93LldlYlNvY2tldCkge1xuICAgICAgICAgICAgd3MgPSBuZXcgV2ViU29ja2V0KGhvc3QpO1xuICAgICAgICB9IGVsc2UgaWYgKHdpbmRvdy5Nb3pXZWJTb2NrZXQpIHtcbiAgICAgICAgICAgIHdzID0gbmV3IE1veldlYlNvY2tldChob3N0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1I6IGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBXZWJTb2NrZXRzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHdzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgKiBAZnVuY3Rpb24gaW5pdFNvY2tldENvbm5lY3Rpb25cbiAgICAqL1xuICAgIGluaXRTb2NrZXRDb25uZWN0aW9uOiBmdW5jdGlvbiBpbml0U29ja2V0Q29ubmVjdGlvbigpIHtcbiAgICAgICAgdmFyIG1lID0gQXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGwgPSBtZS50cmFjZUxvZyhpbml0U29ja2V0Q29ubmVjdGlvbiwgMCwgXCIjYWNhXCIpOyBpZiAobCkgY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLCBsKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgLy8gV1MgY29ubmVjdGlvblxuICAgICAgICAgICAgLy92YXIgaG9zdCA9IFwid3M6Ly9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSArIFwiOjgwODAvXCI7XG4gICAgICAgICAgICB2YXIgaG9zdCA9IG1lLndzaG9zdG5hbWU7XG5cbiAgICAgICAgICAgIGlmIChtZS5kZWJ1ZylcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltpbml0U29ja2V0Q29ubmVjdGlvbl0gaG9zdDpcIiwgaG9zdCk7XG4gICAgICAgICAgICBpZiAobWUucHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgbWUucHJvZ3Jlc3MuaHRtbChcIkNvbm5lY3RpbmcuLi5cIik7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbWUuc29ja2V0ID0gbWUuY3JlYXRlU29ja2V0KGhvc3QpO1xuXG4gICAgICAgICAgICAgICAgbWUuc29ja2V0Lm9ub3BlbiA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lLmRlYnVnKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbaW5pdFNvY2tldENvbm5lY3Rpb25dIGNvbm5lY3Rpb24gb3BlblwiLCBtc2cpO1xuICAgICAgICAgICAgICAgICAgICBtZS5wcm9ncmVzcy5odG1sKFwiPGltZyBzcmM9J1wiICsgbWUuaG9zdG5hbWUgKyBcIi9pbWcvZG93bmxvYWQuc3ZnJyBzdHlsZT0ndmVydGljYWwtYWxpZ246bWlkZGxlJy8+TVJJXCIpO1xuICAgICAgICAgICAgICAgICAgICAkKFwiI2NoYXRcIikudGV4dChcIkNoYXQgKDEgY29ubmVjdGVkKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWUuZmxhZ0Nvbm5lY3RlZCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIG1lLnJlY29ubmVjdGlvblRpbWVvdXQgPSA1O1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIG1lLnJlY2VpdmVGdW5jdGlvbnNbXCJzYXZlTWV0YWRhdGFcIl0gPSBtZS5yZWNlaXZlTWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgbWUucmVjZWl2ZUZ1bmN0aW9uc1tcInVzZXJEYXRhXCJdID0gbWUucmVjZWl2ZVVzZXJEYXRhTWVzc2FnZTtcbiAgICAgICAgICAgICAgICBtZS5yZWNlaXZlRnVuY3Rpb25zW1widm9sSW5mb1wiXSA9IGZ1bmN0aW9uIChkYXRhKSB7IGNvbnNvbGUubG9nKFwidm9sSW5mb1wiLCBkYXRhKSB9O1xuICAgICAgICAgICAgICAgIG1lLnJlY2VpdmVGdW5jdGlvbnNbXCJjaGF0XCJdID0gbWUucmVjZWl2ZUNoYXRNZXNzYWdlO1xuICAgICAgICAgICAgICAgIG1lLnJlY2VpdmVGdW5jdGlvbnNbXCJzaG93XCJdID0gbWUucmVjZWl2ZVNob3dNZXNzYWdlO1xuICAgICAgICAgICAgICAgIG1lLnJlY2VpdmVGdW5jdGlvbnNbXCJwYWludFwiXSA9IG1lLnJlY2VpdmVQYWludE1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgbWUucmVjZWl2ZUZ1bmN0aW9uc1tcInBhaW50dm9sXCJdID0gbWUucmVjZWl2ZVBhaW50Vm9sdW1lTWVzc2FnZTtcbiAgICAgICAgICAgICAgICBtZS5yZWNlaXZlRnVuY3Rpb25zW1wiZGlzY29ubmVjdFwiXSA9IG1lLnJlY2VpdmVEaXNjb25uZWN0TWVzc2FnZTtcbiAgICAgICAgICAgICAgICBtZS5yZWNlaXZlRnVuY3Rpb25zW1wic2VydmVyTWVzc2FnZVwiXSA9IG1lLnJlY2VpdmVTZXJ2ZXJNZXNzYWdlO1xuXG4gICAgICAgICAgICAgICAgbWUucmVjZWl2ZUZ1bmN0aW9uc1tcInJlcXVlc3RTbGljZVwiXSA9IGZ1bmN0aW9uIChkYXRhKSB7IGNvbnNvbGUubG9nKFwicmVxdWVzdFNsaWNlXCIsIGRhdGEpIH07XG4gICAgICAgICAgICAgICAgbWUucmVjZWl2ZUZ1bmN0aW9uc1tcInJlcXVlc3RTbGljZTJcIl0gPSBmdW5jdGlvbiAoZGF0YSkgeyBjb25zb2xlLmxvZyhcInJlcXVlc3RTbGljZTJcIiwgZGF0YSkgfTtcblxuICAgICAgICAgICAgICAgIG1lLnNvY2tldC5vbm1lc3NhZ2UgPSBtZS5yZWNlaXZlU29ja2V0TWVzc2FnZTtcblxuICAgICAgICAgICAgICAgIG1lLnNvY2tldC5vbmNsb3NlID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgICAgICAgICBtZS5mbGFnQ29ubmVjdGVkID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gcmVjb25uZWN0XG4gICAgICAgICAgICAgICAgICAgIC8vIHdhaXQgYSByYW5kb20gaW5pdGlhbCB0aW1lLCB0byBwcmV2ZW50IGFuIGF2YWxhbmNoZVxuICAgICAgICAgICAgICAgICAgICAvLyBvZiByZWNvbm5lY3Rpb25zIGluIGNhc2Ugb2Ygc2VydmVyIGNyYXNoXG4gICAgICAgICAgICAgICAgICAgIHZhciByYW5kID0gMTAwMCArIDUwMDAgKiBNYXRoLnJhbmRvbSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkluaXRpYWwgcmFuZG9tIHRpbWU6XCIsIHJhbmQpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gbWUucmVjb25uZWN0aW9uVGltZW91dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjY2hhdFwiKS50ZXh0KFwiRGlzY29ubmVjdGVkLiBUcnkgdG8gcmVjb25uZWN0IGluIFwiICsgKHRpbWVvdXQtLSkgKyBcIiBzLi4uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lLnRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChtZS50aW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS50aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcIiNjaGF0XCIpLnRleHQoXCJSZWNvbm5lY3RpbmcuLi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnNvY2tldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwobWUudGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnJlY29ubmVjdGlvblRpbWVvdXQgKj0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLmluaXRTb2NrZXRDb25uZWN0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lLnNlbmRVc2VyRGF0YU1lc3NhZ2UoXCJhbGxVc2VyRGF0YVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuc2VuZFVzZXJEYXRhTWVzc2FnZShcInNlbmRBdGxhc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChtZS50aW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbWUucmVjb25uZWN0aW9uVGltZW91dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcIiNjaGF0XCIpLnRleHQoXCJEaXNjb25uZWN0ZWQuIFRyeSB0byByZWNvbm5lY3QgaW4gXCIgKyAodGltZW91dC0tKSArIFwiIHMuLi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjY2hhdFwiKS50ZXh0KFwiRGlzY29ubmVjdGVkLiBUcnkgdG8gcmVjb25uZWN0IGluIFwiICsgKHRpbWVvdXQtLSkgKyBcIiBzLi4uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICB9LCByYW5kKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgd2luZG93Lm9uYmVmb3JldW5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBtZS5zb2NrZXQub25jbG9zZSA9IGZ1bmN0aW9uICgpIHsgfTsgLy8gZGlzYWJsZSBvbmNsb3NlIGhhbmRsZXIgZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgbWUuc29ja2V0LmNsb3NlKClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgJChcIiNjaGF0XCIpLnRleHQoXCJDaGF0IChub3QgY29ubmVjdGVkIC0gY29ubmVjdGlvbiBlcnJvcilcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gcmVjZWl2ZVNvY2tldE1lc3NhZ2VcbiAgICAgKi9cbiAgICByZWNlaXZlU29ja2V0TWVzc2FnZTogZnVuY3Rpb24gcmVjZWl2ZVNvY2tldE1lc3NhZ2UobXNnKSB7XG4gICAgICAgIHZhciBtZSA9IEF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsID0gbWUudHJhY2VMb2cocmVjZWl2ZVNvY2tldE1lc3NhZ2UsIDEsIFwiI2FjYVwiKTsgaWYgKGwpIGNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCwgbCk7XG5cbiAgICAgICAgLy8gTWVzc2FnZTogYXRsYXMgZGF0YSBpbml0aWFsaXNhdGlvblxuICAgICAgICBpZiAobXNnLmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgICBtZS5yZWNlaXZlQmluYXJ5TWVzc2FnZShtc2cuZGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNZXNzYWdlOiBpbnRlcmFjdGlvbiBtZXNzYWdlXG4gICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShtc2cuZGF0YSk7XG4gICAgICAgIG1lLnJlY2VpdmVGdW5jdGlvbnNbZGF0YS50eXBlXShkYXRhKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBzZW5kVXNlckRhdGFNZXNzYWdlXG4gICAgICovXG4gICAgc2VuZFVzZXJEYXRhTWVzc2FnZTogZnVuY3Rpb24gc2VuZFVzZXJEYXRhTWVzc2FnZShkZXNjcmlwdGlvbikge1xuICAgICAgICB2YXIgbWUgPSBBdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbCA9IG1lLnRyYWNlTG9nKHNlbmRVc2VyRGF0YU1lc3NhZ2UsIDEsIFwiI2FjYVwiKTsgaWYgKGwpIGNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCwgbCk7XG5cbiAgICAgICAgaWYgKG1lLmZsYWdDb25uZWN0ZWQgPT0gMClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBpZiAobWUuZGVidWcgPiAxKSBjb25zb2xlLmxvZyhcIm1lc3NhZ2U6IFwiICsgZGVzY3JpcHRpb24pO1xuXG4gICAgICAgIGlmIChkZXNjcmlwdGlvbiA9PT0gXCJhbGxVc2VyRGF0YVwiKVxuICAgICAgICAgICAgdmFyIG1zZyA9IHsgXCJ0eXBlXCI6IFwidXNlckRhdGFcIiwgXCJ1c2VyXCI6IG1lLlVzZXIsIFwiZGVzY3JpcHRpb25cIjogZGVzY3JpcHRpb24gfTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFyIG1zZyA9IHsgXCJ0eXBlXCI6IFwidXNlckRhdGFcIiwgXCJkZXNjcmlwdGlvblwiOiBkZXNjcmlwdGlvbiB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWUuc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkobXNnKSk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVSUk9SOiBVbmFibGUgdG8gc2VuZFVzZXJEYXRhTWVzc2FnZVwiLCBleCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiByZWNlaXZlQmluYXJ5TWVzc2FnZVxuICAgICAqL1xuICAgIHJlY2VpdmVCaW5hcnlNZXNzYWdlOiBmdW5jdGlvbiByZWNlaXZlQmluYXJ5TWVzc2FnZShtc2dEYXRhKSB7XG4gICAgICAgIHZhciBtZSA9IEF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsID0gbWUudHJhY2VMb2cocmVjZWl2ZUJpbmFyeU1lc3NhZ2UsIDEsIFwiI2FjYVwiKTsgaWYgKGwpIGNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCwgbCk7XG5cbiAgICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIGZyb21fcmVjZWl2ZVNvY2tldE1lc3NhZ2UoKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRoaXMucmVzdWx0KTtcbiAgICAgICAgICAgIHZhciBzeiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGV4dCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVtzeiAtIDhdLCBkYXRhW3N6IC0gN10sIGRhdGFbc3ogLSA2XSk7XG5cbiAgICAgICAgICAgIGlmIChtZS5kZWJ1ZyA+IDEpIGNvbnNvbGUubG9nKFwidHlwZTogXCIgKyBleHQpO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGV4dCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ25paSc6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZmxhdGUgPSBuZXcgcGFrby5JbmZsYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGluZmxhdGUucHVzaChkYXRhLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0bGFzID0gbmV3IE9iamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBhdGxhcy5kYXRhID0gaW5mbGF0ZS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGF0bGFzLm5hbWUgPSBtZS5hdGxhc0ZpbGVuYW1lO1xuICAgICAgICAgICAgICAgICAgICBhdGxhcy5kaW0gPSBtZS5icmFpbl9kaW07XG5cbiAgICAgICAgICAgICAgICAgICAgbWUuYXRsYXMgPSBhdGxhcztcblxuICAgICAgICAgICAgICAgICAgICBtZS5jb25maWd1cmVCcmFpbkltYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIG1lLmNvbmZpZ3VyZUF0bGFzSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgbWUucmVzaXplV2luZG93KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbWUuYnJhaW5faW1nLmltZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIG1lLmRyYXdJbWFnZXMoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjb21wdXRlIHRvdGFsIHNlZ21lbnRlZCB2b2x1bWVcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZvbCA9IG1lLmNvbXB1dGVTZWdtZW50ZWRWb2x1bWUoKTtcbiAgICAgICAgICAgICAgICAgICAgbWUuaW5mby52b2x1bWUgPSBwYXJzZUludCh2b2wpICsgXCIgbW0zXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0dXAgZG93bmxvYWQgbGlua1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluayA9IG1lLmNvbnRhaW5lci5maW5kKFwic3BhbiNkb3dubG9hZF9hdGxhc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgbGluay5odG1sKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiPGEgY2xhc3M9J2Rvd25sb2FkJyBocmVmPSdcIiArIG1lLlVzZXIuZGlybmFtZSArIG1lLlVzZXIuYXRsYXNGaWxlbmFtZSArIFwiJz5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiPGltZyBzcmM9J1wiICsgbWUuaG9zdG5hbWUgKyBcIi9pbWcvZG93bmxvYWQuc3ZnJyBzdHlsZT0ndmVydGljYWwtYWxpZ246bWlkZGxlJy8+XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIjwvYT5cIiArIGF0bGFzLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcnKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2pwZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybENyZWF0b3IgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZVVybCA9IHVybENyZWF0b3IuY3JlYXRlT2JqZWN0VVJMKG1zZ0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbWUuaXNNUklMb2FkZWQgPSB0cnVlOyAvLyByZWNlaXZpbmcgYSBqcGcgaXMgcHJvb2Ygb2YgYSBsb2FkZWQgTVJJXG5cbiAgICAgICAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uIGZyb21faW5pdFNvY2tldENvbm5lY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmxhZ0ZpcnN0SW1hZ2UgPSAobWUuYnJhaW5faW1nLmltZyA9PSBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lLmJyYWluX2ltZy5pbWcgPSBpbWc7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5icmFpbl9pbWcudmlldyA9IG1lLmZsYWdMb2FkaW5nSW1nLnZpZXc7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5icmFpbl9pbWcuc2xpY2UgPSBtZS5mbGFnTG9hZGluZ0ltZy5zbGljZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWUuZHJhd0ltYWdlcygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtZS5mbGFnTG9hZGluZ0ltZy5sb2FkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbGFnRmlyc3RJbWFnZSB8fCBtZS5mbGFnTG9hZGluZ0ltZy52aWV3ICE9IG1lLlVzZXIudmlldyB8fCBtZS5mbGFnTG9hZGluZ0ltZy5zbGljZSAhPSBtZS5Vc2VyLnNsaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWUuc2VuZFJlcXVlc3RTbGljZU1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGxvYWRpbmcgaW5kaWNhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAkKFwiI2xvYWRpbmdJbmRpY2F0b3JcIikuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGltZy5zcmMgPSBpbWFnZVVybDtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIobXNnRGF0YSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gcmVjZWl2ZVVzZXJEYXRhTWVzc2FnZVxuICAgICAqL1xuICAgIHJlY2VpdmVVc2VyRGF0YU1lc3NhZ2U6IGZ1bmN0aW9uIHJlY2VpdmVVc2VyRGF0YU1lc3NhZ2UoZGF0YSkge1xuICAgICAgICB2YXIgbWUgPSBBdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbCA9IG1lLnRyYWNlTG9nKHJlY2VpdmVVc2VyRGF0YU1lc3NhZ2UsIDAsIFwiI2FjYVwiKTsgaWYgKGwpIGNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCwgbCk7XG5cbiAgICAgICAgaWYgKG1lLmRlYnVnID4gMSkgY29uc29sZS5sb2coXCJkZXNjcmlwdGlvbjogXCIgKyBkYXRhLmRlc2NyaXB0aW9uLCBkYXRhKTtcblxuICAgICAgICB2YXIgdSA9IGRhdGEudWlkO1xuXG4gICAgICAgIC8vIEZpcnN0IHRpbWUgdGhlIHVzZXIgaXMgb2JzZXJ2ZWRcbiAgICAgICAgaWYgKG1lLkNvbGxhYlt1XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vdmFyICAgIG1zZz1cIjxiPlwiK2RhdGEudXNlci51c2VybmFtZStcIjwvYj4gZW50ZXJlZCBhdGxhcyBcIitkYXRhLnVzZXIuc3BlY2ltZW5OYW1lK1wiL1wiK2RhdGEudXNlci5hdGxhc0ZpbGVuYW1lK1wiPGJyIC8+XCJcbiAgICAgICAgICAgICAgICB2YXIgbXNnO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnVzZXIgPT09IHVuZGVmaW5lZCB8fCBkYXRhLnVzZXIudXNlcm5hbWUgPT09IFwiQW5vbnltb3VzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnID0gXCI8Yj5cIiArIGRhdGEudWlkICsgXCI8L2I+IGVudGVyZWQ8YnIgLz5cIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtc2cgPSBcIjxiPlwiICsgZGF0YS51c2VyLnVzZXJuYW1lICsgXCI8L2I+IGVudGVyZWQ8YnIgLz5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJChcIiNsb2dcIikuYXBwZW5kKG1zZyk7XG4gICAgICAgICAgICAgICAgJChcIiNsb2dcIikuc2Nyb2xsVG9wKCQoXCIjbG9nXCIpWzBdLnNjcm9sbEhlaWdodCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJkYXRhOlwiLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLmRlc2NyaXB0aW9uID09PSBcImFsbFVzZXJEYXRhXCIpXG4gICAgICAgICAgICBtZS5Db2xsYWJbdV0gPSBkYXRhLnVzZXI7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlcyA9IEpTT04ucGFyc2UoZGF0YS5kZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgZm9yIChpIGluIGNoYW5nZXMpXG4gICAgICAgICAgICAgICAgICAgIG1lLkNvbGxhYlt1XVtpXSA9IGNoYW5nZXNbaV07XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdiwgbnVzZXJzID0gMTtcbiAgICAgICAgZm9yICh2IGluIG1lLkNvbGxhYilcbiAgICAgICAgICAgIG51c2VycysrO1xuICAgICAgICAkKFwiI2NoYXRcIikudGV4dChcIkNoYXQgKFwiICsgbnVzZXJzICsgXCIgY29ubmVjdGVkKVwiKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBzZW5kQ2hhdE1lc3NhZ2VcbiAgICAgKi9cbiAgICBzZW5kQ2hhdE1lc3NhZ2U6IGZ1bmN0aW9uIHNlbmRDaGF0TWVzc2FnZSgpIHtcbiAgICAgICAgdmFyIG1lID0gQXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGwgPSBtZS50cmFjZUxvZyhzZW5kQ2hhdE1lc3NhZ2UsIDAsIFwiI2FjYVwiKTsgaWYgKGwpIGNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCwgbCk7XG5cbiAgICAgICAgaWYgKG1lLmZsYWdDb25uZWN0ZWQgPT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG1zZyA9IERPTVB1cmlmeS5zYW5pdGl6ZSgkKCdpbnB1dCNtc2cnKVswXS52YWx1ZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZS5zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7IFwidHlwZVwiOiBcImNoYXRcIiwgXCJtc2dcIjogbXNnLCBcInVzZXJuYW1lXCI6IG1lLlVzZXIudXNlcm5hbWUgfSkpO1xuICAgICAgICAgICAgdmFyIG1zZyA9IFwiPGI+bWU6IDwvYj5cIiArIG1zZyArIFwiPGJyIC8+XCI7XG4gICAgICAgICAgICAkKFwiI2xvZ1wiKS5hcHBlbmQobXNnKTtcbiAgICAgICAgICAgICQoXCIjbG9nXCIpLnNjcm9sbFRvcCgkKFwiI2xvZ1wiKVswXS5zY3JvbGxIZWlnaHQpO1xuICAgICAgICAgICAgJCgnaW5wdXQjbXNnJykudmFsKFwiXCIpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJFUlJPUjogVW5hYmxlIHRvIHNlbmRDaGF0TWVzc2FnZVwiLCBleCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiByZWNlaXZlQ2hhdE1lc3NhZ2VcbiAgICAgKi9cbiAgICByZWNlaXZlQ2hhdE1lc3NhZ2U6IGZ1bmN0aW9uIHJlY2VpdmVDaGF0TWVzc2FnZShkYXRhKSB7XG4gICAgICAgIHZhciBtZSA9IEF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsID0gbWUudHJhY2VMb2cocmVjZWl2ZUNoYXRNZXNzYWdlLCAwLCBcIiNhY2FcIik7IGlmIChsKSBjb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsIGwpO1xuICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcblxuICAgICAgICB2YXIgdGhlU291cmNlID0gbWUuQ29sbGFiW2RhdGEudWlkXS5zb3VyY2U7XG4gICAgICAgIHZhciB0aGVWaWV3ID0gbWUuQ29sbGFiW2RhdGEudWlkXS52aWV3O1xuICAgICAgICB2YXIgdGhlU2xpY2UgPSBtZS5Db2xsYWJbZGF0YS51aWRdLnNsaWNlO1xuICAgICAgICB2YXIgbGluayA9IG1lLmhvc3RuYW1lICsgXCIvbXJpP3VybD1cIiArIHRoZVNvdXJjZSArIFwiJnZpZXc9XCIgKyB0aGVWaWV3ICsgXCImc2xpY2U9XCIgKyB0aGVTbGljZTtcbiAgICAgICAgdmFyIHRoZVVzZXJuYW1lID0gKGRhdGEudXNlcm5hbWUgPT09IFwiQW5vbnltb3VzXCIpP2RhdGEudWlkOmRhdGEudXNlcm5hbWU7XG4gICAgICAgIHZhciBtc2cgPSBcIjxhIGhyZWY9J1wiICtsaW5rK1wiJz48Yj5cIit0aGVVc2VybmFtZStcIjo8L2I+PC9hPiBcIitkYXRhLm1zZytcIjxiciAvPlwiXG4gICAgICAgICQoXCIjbG9nXCIpLmFwcGVuZChtc2cpO1xuICAgICAgICAkKFwiI2xvZ1wiKS5zY3JvbGxUb3AoJChcIiNsb2dcIilbMF0uc2Nyb2xsSGVpZ2h0KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBzZW5kUGFpbnRNZXNzYWdlXG4gICAgICogQGRlc2MgT24gdXNlciBwYWludGluZywgdGhpcyBmdW5jdGlvbiBicm9hZGNhc3RzIHRoZSBwYWludGluZyBldmVudCB0byBhbGwgb3RoZXIgY29ubmVjdGVkIHVzZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1zZyBQYWludGluZyBldmVudCBvYmplY3Q6IHtcImNcIjpjLFwieFwiOngsXCJ5XCI6eX0sIHdoZXJlIFwiY1wiIGlzIHRoZSBjb21tYW5kIChsLGUsbGYsZWYpIGFuZCB4IGFuZCB5IGFyZSB0aGUgY29vcmRpbmF0ZXMgaW4gc2xpY2Ugc3BhY2VcbiAgICAgKi9cbiAgICBzZW5kUGFpbnRNZXNzYWdlOiBmdW5jdGlvbiBzZW5kUGFpbnRNZXNzYWdlKG1zZykge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2coc2VuZFBhaW50TWVzc2FnZSwxLFwiI2FjYVwiKTtpZihsKWNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCxsKTtcblxuICAgICAgICBpZihtZS5mbGFnQ29ubmVjdGVkPT0wKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWUuc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoe3R5cGU6XCJwYWludFwiLGRhdGE6bXNnfSkpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJFUlJPUjogVW5hYmxlIHRvIHNlbmRQYWludE1lc3NhZ2VcIixleCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiByZWNlaXZlUGFpbnRNZXNzYWdlXG4gICAgICogQGRlc2MgUmVjZWl2ZSBwYWludCBldmVudHMgZnJvbSBvdGhlciBjb25uZWN0ZWQgdXNlcnNcbiAgICAgKi9cbiAgICByZWNlaXZlUGFpbnRNZXNzYWdlOiBmdW5jdGlvbiByZWNlaXZlUGFpbnRNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKHJlY2VpdmVQYWludE1lc3NhZ2UsMyxcIiNhY2FcIik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG5cbiAgICAgICAgdmFyICAgIG1zZz1kYXRhLmRhdGE7XG4gICAgICAgIHZhciB1PWRhdGEudWlkOyAgICAvLyB1c2VyXG4gICAgICAgIHZhciBjPW1zZy5jOyAgICAvLyBjb21tYW5kXG4gICAgICAgIHZhciB4PXBhcnNlSW50KG1zZy54KTsgICAgLy8geCBjb29yZGluYXRlXG4gICAgICAgIHZhciB5PXBhcnNlSW50KG1zZy55KTsgICAgLy8geSBjb29yZGluYXRlXG5cbiAgICAgICAgaWYobWUuQ29sbGFiW3VdKVxuICAgICAgICAgICAgbWUucGFpbnR4eSh1LGMseCx5LG1lLkNvbGxhYlt1XSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gc2VuZFNob3dNZXNzYWdlXG4gICAgICogQGRlc2MgT24gdXNlciBzaG93aW5nLCB0aGlzIGZ1bmN0aW9uIGJyb2FkY2FzdHMgdGhlIHNob3dpbmcgZXZlbnQgdG8gYWxsIG90aGVyIGNvbm5lY3RlZCB1c2Vyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2cgU2hvd2luZyBldmVudCBvYmplY3Q6IHtcInhcIjp4LFwieVwiOnl9LCB3aGVyZSB4IGFuZCB5IGFyZSB0aGUgY29vcmRpbmF0ZXMgaW4gc2xpY2Ugc3BhY2VcbiAgICAgKi9cbiAgICBzZW5kU2hvd01lc3NhZ2U6IGZ1bmN0aW9uIHNlbmRTaG93TWVzc2FnZShtc2cpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKHNlbmRTaG93TWVzc2FnZSwxLFwiI2FjYVwiKTtpZihsKWNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCxsKTtcblxuICAgICAgICBpZihtZS5mbGFnQ29ubmVjdGVkPT0wKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWUuc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoe3R5cGU6XCJzaG93XCIsZGF0YTptc2d9KSk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVSUk9SOiBVbmFibGUgdG8gc2VuZFNob3dNZXNzYWdlXCIsZXgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gcmVjZWl2ZVNob3dNZXNzYWdlXG4gICAgICogQGRlc2MgUmVjZWl2ZSBzaG93IGV2ZW50cyBmcm9tIG90aGVyIGNvbm5lY3RlZCB1c2Vyc1xuICAgICAqL1xuICAgIHJlY2VpdmVTaG93TWVzc2FnZTogZnVuY3Rpb24gcmVjZWl2ZVNob3dNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKHJlY2VpdmVTaG93TWVzc2FnZSwzLFwiI2FjYVwiKTtpZihsKWNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCxsKTtcblxuICAgICAgICB2YXIgICAgbXNnPWRhdGEuZGF0YTtcbiAgICAgICAgdmFyIHU9ZGF0YS51aWQ7ICAgIC8vIHVzZXJcbiAgICAgICAgdmFyIGM9bXNnLmM7ICAgIC8vIGNvbW1hbmRcbiAgICAgICAgdmFyIHg9cGFyc2VJbnQobXNnLngpOyAgICAvLyB4IGNvb3JkaW5hdGVcbiAgICAgICAgdmFyIHk9cGFyc2VJbnQobXNnLnkpOyAgICAvLyB5IGNvb3JkaW5hdGVcblxuICAgICAgICBpZihtZS5Db2xsYWJbdV0pXG4gICAgICAgICAgICBtZS5zaG93eHkodSxjLHgseSxtZS5Db2xsYWJbdV0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIHJlY2VpdmVQYWludFZvbHVtZU1lc3NhZ2VcbiAgICAgKi9cbiAgICByZWNlaXZlUGFpbnRWb2x1bWVNZXNzYWdlOiBmdW5jdGlvbiByZWNlaXZlUGFpbnRWb2x1bWVNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKHJlY2VpdmVQYWludFZvbHVtZU1lc3NhZ2UsMCxcIiNhY2FcIik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG5cbiAgICAgICAgdmFyICAgIGksaW5kLHZhbCx2b3hlbHM7XG5cbiAgICAgICAgdm94ZWxzPWRhdGEuZGF0YTtcbiAgICAgICAgbWUucGFpbnR2b2wodm94ZWxzLmRhdGEpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAgICBURVNUXG4gICAgICAgICovXG4gICAgICAgIG1lLnNlbmRSZXF1ZXN0U2xpY2VNZXNzYWdlKCk7XG4gICAgfSxcbiAgICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIHNlbmRVbmRvTWVzc2FnZVxuICAgICAqL1xuICAgIHNlbmRVbmRvTWVzc2FnZTogZnVuY3Rpb24gc2VuZFVuZG9NZXNzYWdlKCkge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2coc2VuZFVuZG9NZXNzYWdlLDAsXCIjYWNhXCIpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuXG4gICAgICAgIGlmKG1lLmZsYWdDb25uZWN0ZWQ9PTApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZS5zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7dHlwZTpcInBhaW50XCIsZGF0YTp7YzpcInVcIn19KSk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVSUk9SOiBVbmFibGUgdG8gc2VuZFVuZG9NZXNzYWdlXCIsZXgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIHNlbmRTYXZlTWVzc2FnZVxuICAgICAqL1xuICAgIHNlbmRTYXZlTWVzc2FnZTogZnVuY3Rpb24gc2VuZFNhdmVNZXNzYWdlKCkge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2coc2VuZFNhdmVNZXNzYWdlLDAsXCIjYWNhXCIpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuXG4gICAgICAgIGlmKG1lLmZsYWdDb25uZWN0ZWQ9PTApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZS5zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7dHlwZTpcInNhdmVcIn0pKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1I6IFVuYWJsZSB0byBzZW5kU2F2ZU1lc3NhZ2VcIixleCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBzZW5kUmVxdWVzdE1SSU1lc3NhZ2VcbiAgICAgKi9cbiAgICBzZW5kUmVxdWVzdE1SSU1lc3NhZ2U6IGZ1bmN0aW9uIHNlbmRSZXF1ZXN0TVJJTWVzc2FnZShzb3VyY2UpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKHNlbmRSZXF1ZXN0TVJJTWVzc2FnZSwxLFwiI2FjYVwiKTtpZihsKWNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCxsKTtcblxuICAgICAgICBpZihtZS5mbGFnQ29ubmVjdGVkPT0wKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZS5zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTpcInJlcXVlc3RNUklcIixcbiAgICAgICAgICAgICAgICBzb3VyY2U6XCJzZW5kUmVxdWVzdE1SSU1lc3NhZ2VcIlxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJFUlJPUjogVW5hYmxlIHRvIHNlbmRSZXF1ZXN0TVJJTWVzc2FnZVwiLGV4KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIHNlbmRSZXF1ZXN0U2xpY2VNZXNzYWdlXG4gICAgICovXG4gICAgc2VuZFJlcXVlc3RTbGljZU1lc3NhZ2U6IGZ1bmN0aW9uIHNlbmRSZXF1ZXN0U2xpY2VNZXNzYWdlKCkge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2coc2VuZFJlcXVlc3RTbGljZU1lc3NhZ2UsMSxcIiNhY2FcIik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG5cbiAgICAgICAgaWYobWUuZmxhZ0Nvbm5lY3RlZD09MClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYobWUuZmxhZ0xvYWRpbmdJbWcubG9hZGluZz09dHJ1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1lLnNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHtcblxuICAgICAgICAgICAgICAgIHR5cGU6XCJyZXF1ZXN0U2xpY2VcIixcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICBURVNUXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAvL3R5cGU6XCJyZXF1ZXN0U2xpY2UyXCIsXG5cbiAgICAgICAgICAgICAgICB2aWV3Om1lLlVzZXIudmlldyxcbiAgICAgICAgICAgICAgICBzbGljZTptZS5Vc2VyLnNsaWNlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBtZS5mbGFnTG9hZGluZ0ltZy5sb2FkaW5nPXRydWU7XG4gICAgICAgICAgICBtZS5mbGFnTG9hZGluZ0ltZy52aWV3PW1lLlVzZXIudmlldztcbiAgICAgICAgICAgIG1lLmZsYWdMb2FkaW5nSW1nLnNsaWNlPW1lLlVzZXIuc2xpY2U7XG5cbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1I6IFVuYWJsZSB0byBzZW5kUmVxdWVzdFNsaWNlTWVzc2FnZVwiLGV4KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHRvZG8gVGhpcyBpcyByZWFsbHkgbm90IHRoZSBwbGFjZSBmb3Igc29tZSBvZiB0aGlzIGNvZGUuIFRoZSByZWNlaXZlTWV0YWRhdGFcbiAgICAgKiAgICAgICBmdW5jdGlvbiBpcyBvaywgYnV0IHRoZSBkaXJlY3QgcmVmZXJlbmNlcyB0byBwcm9qZWN0SW5mbyAtLSBhIHN0cnVjdHVyZVxuICAgICAqICAgICAgIGV4Y2x1c2l2ZWx5IHVzZWQgYnkgcHJvamVjdC5tdXN0YWNoZSAtLSBzaG91bGQgZ28gdG8gdGhhdCBmaWxlLiBOb3csIHRoZVxuICAgICAqICAgICAgIG1lY2hhbmlzbSBmb3IgdW5jb3VwbGluZyB0aGUgMiBwaWVjZXMgb2YgY29kZSBpcyBub3QgY2xlYXIuIEl0IGNvdWxkIGJlXG4gICAgICogICAgICAgYSBzdWJzY3JpcHRpb24sIGZvciBleGFtcGxlLlxuICAgICAqL1xuICAgIHJlY2VpdmVNZXRhZGF0YTogZnVuY3Rpb24gcmVjZWl2ZU1ldGFkYXRhKGRhdGEpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKHJlY2VpdmVNZXRhZGF0YSwxLFwiI2FjYVwiKTtpZihsKWNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCxsKTtcbiAgICAgICAgdmFyIHByb2pTaG9ydG5hbWUgPSBwcm9qZWN0SW5mby5zaG9ydG5hbWU7XG4gICAgICAgIGZvciAodmFyIGkgaW4gcHJvamVjdEluZm8uZmlsZXMubGlzdCkge1xuICAgICAgICAgICAgaWYgKHByb2plY3RJbmZvLmZpbGVzLmxpc3RbaV0uc291cmNlID09IGRhdGEubWV0YWRhdGEuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHByb2plY3RJbmZvLmZpbGVzLmxpc3RbaV0ubXJpLmFubm90YXRpb25zW3Byb2pTaG9ydG5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZm9fcHJveHlbXCJmaWxlcy5saXN0LlwiICsgaSArIFwiLm1yaS5hbm5vdGF0aW9ucy5cIiArIHByb2pTaG9ydG5hbWUgKyBcIi5cIiArIGtleV0gPSBkYXRhLm1ldGFkYXRhLm1yaS5hbm5vdGF0aW9uc1twcm9qU2hvcnRuYW1lXVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmZvX3Byb3h5W1wiZmlsZXMubGlzdC5cIiArIGkgKyBcIi5uYW1lXCJdID0gZGF0YS5tZXRhZGF0YS5uYW1lO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gc2VuZFNhdmVNZXRhZGF0YU1lc3NhZ2VcbiAgICAgKi9cbiAgICBzZW5kU2F2ZU1ldGFkYXRhTWVzc2FnZTogZnVuY3Rpb24gc2VuZFNhdmVNZXRhZGF0YU1lc3NhZ2UoaW5mbywgbWV0aG9kLCBwYXRjaCkge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2coc2VuZFNhdmVNZXRhZGF0YU1lc3NhZ2UsMSxcIiNhY2FcIik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaWYobWUuZmxhZ0Nvbm5lY3RlZD09MCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV0FSTklORzogTm90IGNvbm5lY3RlZDogd2lsbCBub3Qgc2F2ZSBtZXRhZGF0YVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHJuZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIwKTtcbiAgICAgICAgICAgICAgICB2YXIgbWV0ID0gbWV0aG9kIHx8IFwiYXBwZW5kXCI7XG4gICAgICAgICAgICAgICAgaWYobWV0aG9kID09IFwicGF0Y2hcIikge1xuICAgICAgICAgICAgICAgICAgICBtZS5zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOlwic2F2ZU1ldGFkYXRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogaW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2g6IHBhdGNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm5kOiBybmRcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lLnNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6XCJzYXZlTWV0YWRhdGFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBpbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBybmQ6IHJuZFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKG1lLmRlYnVnPjEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cocm5kKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coaW5mbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcblxuICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVSUk9SOiBVbmFibGUgdG8gc2VuZFNhdmVNZXRhZGF0YU1lc3NhZ2VcIixleCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIHJlY2VpdmVEaXNjb25uZWN0TWVzc2FnZVxuICAgICAqL1xuICAgIHJlY2VpdmVEaXNjb25uZWN0TWVzc2FnZTogZnVuY3Rpb24gcmVjZWl2ZURpc2Nvbm5lY3RNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKHJlY2VpdmVEaXNjb25uZWN0TWVzc2FnZSwwLFwiI2FjYVwiKTtpZihsKWNvbnNvbGUubG9nLmFwcGx5KHVuZGVmaW5lZCxsKTtcblxuICAgICAgICB2YXIgdT1kYXRhLnVpZDsgICAgLy8gdXNlclxuICAgICAgICBpZihtZS5Db2xsYWJbdV0pIHtcbiAgICAgICAgICAgIHZhciAgICBtc2c7XG4gICAgICAgICAgICBpZihtZS5Db2xsYWJbdV0udXNlcm5hbWUgPT09IHVuZGVmaW5lZCB8fCBtZS5Db2xsYWJbdV0udXNlcm5hbWUgPT09IFwiQW5vbnltb3VzXCIpXG4gICAgICAgICAgICAgICAgbXNnID0gXCI8Yj5cIittZS5Db2xsYWJbdV0udWlkK1wiPC9iPiBsZWZ0PGJyIC8+XCI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbXNnID0gXCI8Yj5cIittZS5Db2xsYWJbdV0udXNlcm5hbWUrXCI8L2I+IGxlZnQ8YnIgLz5cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2YXIgICAgbXNnPVwiPGI+XCIrdStcIjwvYj4gbGVmdDxiciAvPlwiO1xuICAgICAgICBkZWxldGUgbWUuQ29sbGFiW3VdO1xuICAgICAgICB2YXIgICAgdixudXNlcnM9MTsgZm9yKHYgaW4gbWUuQ29sbGFiKSBudXNlcnMrKztcbiAgICAgICAgJChcIiNjaGF0XCIpLnRleHQoXCJDaGF0IChcIitudXNlcnMrXCIgY29ubmVjdGVkKVwiKTtcbiAgICAgICAgJChcIiNsb2dcIikuYXBwZW5kKG1zZyk7XG4gICAgICAgICQoXCIjbG9nXCIpLnNjcm9sbFRvcCgkKFwiI2xvZ1wiKVswXS5zY3JvbGxIZWlnaHQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIHJlY2VpdmVTZXJ2ZXJNZXNzYWdlXG4gICAgICovXG4gICAgcmVjZWl2ZVNlcnZlck1lc3NhZ2U6IGZ1bmN0aW9uIHJlY2VpdmVTZXJ2ZXJNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKHJlY2VpdmVTZXJ2ZXJNZXNzYWdlLDAsXCIjYWNhXCIpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuXG4gICAgICAgIHZhciBtc2c9ZGF0YS5tc2c7XG4gICAgICAgIHZhciBwcmV2TXNnPSQoXCIjY2hhdFwiKS50ZXh0KCk7XG4gICAgICAgICQoXCIjY2hhdFwiKS50ZXh0KG1zZyk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXskKFwiI2NoYXRcIikudGV4dChwcmV2TXNnKX0sNTAwMCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gcmVwbGF5V1NUcmFmZmljXG4gICAgICogQGRlc2MgUmVwbGF5cyB3ZWJzb2NrZXQgdHJhZmZpYyByZWNvcmRlZCBhdCB0aGUgc2VydmVkLiBVc2VkIGZvciBkZWJ1Z2dpbmdcbiAgICAgKiBAcGFyYW0gQXJyYXkgcmVjb3JkZWQgQW4gYXJyYXkgb2Ygd2Vic29ja2V0IG1lc3NhZ2VzIHJlY29yZGVkIGluIHRoZSBzZXJ2ZXJcbiAgICAgKi9cbiAgICByZXBsYXlXU1RyYWZmaWM6IGZ1bmN0aW9uIHJlcGxheVdTVHJhZmZpYyhyZWNvcmRlZCkge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2cocmVwbGF5V1NUcmFmZmljLDAsXCIjYWNhXCIpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yKGk9MDtpPHJlY29yZGVkLmxlbmd0aDtpKyspIHtcbiAgICAgICAgICAgIG1lLnNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHJlY29yZGVkW2ldKSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vPT09PT09PT09PVxuICAgIC8vIERhdGFiYXNlXG4gICAgLy89PT09PT09PT09XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIGxvZ1RvRGF0YWJhc2VcbiAgICAgKi9cbiAgICBsb2dUb0RhdGFiYXNlOiBmdW5jdGlvbiBsb2dUb0RhdGFiYXNlKGtleSx2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKGxvZ1RvRGF0YWJhc2UsMSxcIiNiYmRcIik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG4gICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgIHVybDogbWUuaG9zdG5hbWUgKyBcIi9hcGkvbG9nXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICB1c2VybmFtZTogbWUuVXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfX0pXG4gICAgICAgICAgICAuZG9uZShmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmFpbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoXCJFcnJvclwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59IiwiZXhwb3J0IHZhciBBdGxhc01ha2VyUmVzb3VyY2VzID0ge1xuICBcImh0bWxcIjoge1xuICAgIFwiYWRqdXN0XCI6IFwiPGRpdiBpZD0nYWRqdXN0JyBzdHlsZT0nd2lkdGg6Y2FsYygxMDAlIC0gMjBweCApO3Bvc2l0aW9uOmFic29sdXRlO2JvdHRvbTowO2xlZnQ6MDtwYWRkaW5nOjEwcHg7Jz5cXG4gICAgXFxuICAgIDwhLS0gVHJhbnNwYXJlbmN5IC0tPlxcbiAgICA8ZGl2PlxcbiAgICAgICAgPGltZyBzcmM9Jy9pbWcvYWxwaGEuc3ZnJyBzdHlsZT0nd2lkdGg6MjBweDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGUnLz5cXG4gICAgICAgIDxkaXYgaWQ9J2FscGhhTGV2ZWwnIGNsYXNzPSdzbGlkZXInIGRhdGEtbWF4PTEwMCBkYXRhLXZhbD0wIHN0eWxlPSdkaXNwbGF5OmlubGluZS1ibG9jaztwb3NpdGlvbjpyZWxhdGl2ZTttYXJnaW4tbGVmdDoxMHB4O3dpZHRoOmNhbGMoMTAwJSAtIDMwcHggLSAyMHB4KTtoZWlnaHQ6MTAwJTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGUnPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9J3RyYWNrJ1xcbiAgICAgICAgICAgICAgICAgc3R5bGU9J3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6NTAlO3dpZHRoOjEwMCU7Ym9yZGVyLXRvcDoxcHggc29saWQgI2ZmZjtkaXNwbGF5OmlubGluZS1ibG9jayc+PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz0ndGh1bWInXFxuICAgICAgICAgICAgICAgICBzdHlsZT0ndHJhbnNmb3JtOnRyYW5zbGF0ZSgtMTBweCwtMTBweCk7Ym9yZGVyLXJhZGl1czoxMHB4O3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6NTAlO3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHg7YmFja2dyb3VuZC1jb2xvcjojZmZmO2Rpc3BsYXk6aW5saW5lLWJsb2NrJz48L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPCEtLSBCcmlnaHRuZXNzIC0tPlxcbiAgICA8ZGl2PlxcbiAgICAgICAgPGltZyBzcmM9Jy9pbWcvc3VuLW8uc3ZnJyBzdHlsZT0nd2lkdGg6MjBweDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGUnLz5cXG4gICAgICAgIDxkaXYgaWQ9J21pbkxldmVsJyBjbGFzcz0nc2xpZGVyJyBkYXRhLW1heD0xMDAgZGF0YS12YWw9MCBzdHlsZT0nZGlzcGxheTppbmxpbmUtYmxvY2s7cG9zaXRpb246cmVsYXRpdmU7bWFyZ2luLWxlZnQ6MTBweDt3aWR0aDpjYWxjKDEwMCUgLSAzMHB4IC0gMjBweCk7aGVpZ2h0OjEwMCU7dmVydGljYWwtYWxpZ246bWlkZGxlJz5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPSd0cmFjaydcXG4gICAgICAgICAgICAgICAgIHN0eWxlPSdwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOjUwJTt3aWR0aDoxMDAlO2JvcmRlci10b3A6MXB4IHNvbGlkICNmZmY7ZGlzcGxheTppbmxpbmUtYmxvY2snPjwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9J3RodW1iJ1xcbiAgICAgICAgICAgICAgICAgc3R5bGU9J3RyYW5zZm9ybTp0cmFuc2xhdGUoLTEwcHgsLTEwcHgpO2JvcmRlci1yYWRpdXM6MTBweDtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOjUwJTt3aWR0aDoyMHB4O2hlaWdodDoyMHB4O2JhY2tncm91bmQtY29sb3I6I2ZmZjtkaXNwbGF5OmlubGluZS1ibG9jayc+PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIFxcbiAgICA8IS0tIENvbnRyYXN0IC0tPlxcbiAgICA8ZGl2PlxcbiAgICAgICAgPGltZyBzcmM9Jy9pbWcvYWRqdXN0LnN2Zycgc3R5bGU9J3dpZHRoOjIwcHg7dmVydGljYWwtYWxpZ246bWlkZGxlJy8+XFxuICAgICAgICA8ZGl2IGlkPSdtYXhMZXZlbCcgY2xhc3M9J3NsaWRlcicgZGF0YS1tYXg9MTAwIGRhdGEtdmFsPTAgc3R5bGU9J2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlO21hcmdpbi1sZWZ0OjEwcHg7d2lkdGg6Y2FsYygxMDAlIC0gMzBweCAtIDIwcHgpO2hlaWdodDoxMDAlO3ZlcnRpY2FsLWFsaWduOm1pZGRsZSc+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz0ndHJhY2snXFxuICAgICAgICAgICAgICAgICBzdHlsZT0ncG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDo1MCU7d2lkdGg6MTAwJTtib3JkZXItdG9wOjFweCBzb2xpZCAjZmZmO2Rpc3BsYXk6aW5saW5lLWJsb2NrJz48L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPSd0aHVtYidcXG4gICAgICAgICAgICAgICAgIHN0eWxlPSd0cmFuc2Zvcm06dHJhbnNsYXRlKC0xMHB4LC0xMHB4KTtib3JkZXItcmFkaXVzOjEwcHg7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDo1MCU7d2lkdGg6MjBweDtoZWlnaHQ6MjBweDtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7ZGlzcGxheTppbmxpbmUtYmxvY2snPjwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8c2NyaXB0PlxcbiAgICAgICAgLy8gVHJhbnNwYXJlbmN5XFxuICAgICAgICBBdGxhc01ha2VyV2lkZ2V0LnNsaWRlcigkKCcuc2xpZGVyI2FscGhhTGV2ZWwnKSxmdW5jdGlvbih4KSB7XFxuICAgICAgICAgICAgJCgnI2FscGhhTGV2ZWwnKS5kYXRhKCd2YWwnLHgpO1xcbiAgICAgICAgICAgICQoJyNhbHBoYUxldmVsIC50aHVtYicpWzBdLnN0eWxlLmxlZnQ9eCsnJSc7XFxuICAgICAgICAgICAgQXRsYXNNYWtlcldpZGdldC5hbHBoYUxldmVsPXgvMTAwO1xcbiAgICAgICAgICAgIEF0bGFzTWFrZXJXaWRnZXQuZHJhd0ltYWdlcygpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICAkKCcuc2xpZGVyI2FscGhhTGV2ZWwnKS5kYXRhKHttYXg6MTAwLHZhbDo1MH0pO1xcbiAgICAgICAgJCgnI2FscGhhTGV2ZWwgLnRodW1iJylbMF0uc3R5bGUubGVmdD0oQXRsYXNNYWtlcldpZGdldC5hbHBoYUxldmVsKjEwMCkrJyUnO1xcblxcbiAgICAgICAgLy8gQnJpZ2h0bmVzc1xcbiAgICAgICAgQXRsYXNNYWtlcldpZGdldC5zbGlkZXIoJCgnLnNsaWRlciNtaW5MZXZlbCcpLGZ1bmN0aW9uKHgpIHtcXG4gICAgICAgICAgICAkKCcjbWluTGV2ZWwnKS5kYXRhKCd2YWwnLHgpO1xcbiAgICAgICAgICAgICQoJyNtaW5MZXZlbCAudGh1bWInKVswXS5zdHlsZS5sZWZ0PXgrJyUnO1xcbiAgICAgICAgXFxuICAgICAgICAgICAgdmFyIGI9KDIqeC8xMDApO1xcbiAgICAgICAgICAgIHZhciBjPSgyKiQoJyNtYXhMZXZlbCcpLmRhdGEoJ3ZhbCcpLzEwMCk7XFxuICAgICAgICAgICAgJCgnI2NhbnZhcycpLmNzcyh7XFxuICAgICAgICAgICAgICAgICd3ZWJraXQtZmlsdGVyJzonYnJpZ2h0bmVzcygnK2IrJykgY29udHJhc3QoJytjKycpJyxcXG4gICAgICAgICAgICAgICAgJ2ZpbHRlcic6J2JyaWdodG5lc3MoJytiKycpIGNvbnRyYXN0KCcrYysnKSdcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgJCgnLnNsaWRlciNtaW5MZXZlbCcpLmRhdGEoe21heDoxMDAsdmFsOjUwfSk7XFxuICAgICAgICAkKCcjbWluTGV2ZWwgLnRodW1iJylbMF0uc3R5bGUubGVmdD0nNTAlJztcXG5cXG4gICAgICAgIC8vIENvbnRyYXN0XFxuICAgICAgICBBdGxhc01ha2VyV2lkZ2V0LnNsaWRlcigkKCcuc2xpZGVyI21heExldmVsJyksZnVuY3Rpb24oeCkge1xcbiAgICAgICAgICAgICQoJyNtYXhMZXZlbCcpLmRhdGEoJ3ZhbCcseCk7XFxuICAgICAgICAgICAgJCgnI21heExldmVsIC50aHVtYicpWzBdLnN0eWxlLmxlZnQ9eCsnJSc7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgdmFyIGI9KDIqJCgnI21pbkxldmVsJykuZGF0YSgndmFsJykvMTAwKTtcXG4gICAgICAgICAgICB2YXIgYz0oMip4LzEwMCk7XFxuICAgICAgICAgICAgJCgnI2NhbnZhcycpLmNzcyh7XFxuICAgICAgICAgICAgICAgICd3ZWJraXQtZmlsdGVyJzonYnJpZ2h0bmVzcygnK2IrJykgY29udHJhc3QoJytjKycpJyxcXG4gICAgICAgICAgICAgICAgJ2ZpbHRlcic6J2JyaWdodG5lc3MoJytiKycpIGNvbnRyYXN0KCcrYysnKSdcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgJCgnLnNsaWRlciNtYXhMZXZlbCcpLmRhdGEoe21heDoxMDAsdmFsOjUwfSk7XFxuICAgICAgICAkKCcjbWF4TGV2ZWwgLnRodW1iJylbMF0uc3R5bGUubGVmdD0nNTAlJztcXG5cXG4gICAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKG11dGF0aW9ucykge1xcbiAgICAgICAgICAgIG11dGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKG11dGF0aW9uKSB7XFxuICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lID09PSAnY2xhc3MnKSB7XFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbXV0YXRpb24nLG11dGF0aW9uKTtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVWYWx1ZSA9ICQobXV0YXRpb24udGFyZ2V0KS5wcm9wKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYoYXR0cmlidXRlVmFsdWU9PSdhJylcXG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcjYWRqdXN0JykucmVtb3ZlKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYnNlcnZlcjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSk7XFxuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKCQoJyNwYWludFRvb2wgW3RpdGxlPVxcXCJBZGp1c3RcXFwiXScpWzBdLCB7XFxuICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZVxcbiAgICAgICAgfSk7XFxuICAgIDwvc2NyaXB0PlxcbjwvZGl2PlxcblwiLFxuICAgIFwidG9vbHNGdWxsXCI6IFwiPGRpdiBpZD0ndG9vbHMtc2lkZScgc3R5bGU9J2Rpc3BsYXk6YmxvY2snPlxcbiAgICA8ZGl2IGlkPSd0b29scy1taW5pbWl6ZWQnPlxcbiAgICAgICAgPGRpdj5cXG4gICAgICAgICAgICA8aW1nIHN0eWxlPSd3aWR0aDoyOHB4O3Bvc2l0aW9uOmFic29sdXRlO3RvcDoxMHB4O2xlZnQ6MTBweCcgc3JjPScvaW1nL2JhcnMuc3ZnJyAvPlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGlkPSd0b29scy1tYXhpbWl6ZWQnIHN0eWxlPSdkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2hlaWdodDoxMDAlJz5cXG5cXG4gICAgICAgIDwhLS0gdG9vbHMgaGlkZS9zaG93LCBkaXNwbGF5IGxlZnQvcmlnaHQgLS0+XFxuICAgICAgICA8ZGl2IGlkPSdoZWFkZXJCbG9jaycgc3R5bGU9J2ZsZXg6MCAxIDI4cHg7YmFja2dyb3VuZDojMzMzJz5cXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPSdkaXNwbGF5OmZsZXgnPlxcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdmbGV4OjAgMCAyOHB4Jz48ZGl2IGlkPSdkaXNwbGF5LW1pbmltaXplJyB0aXRsZT0nTWluaW1pemUgdG9vbGJhcicgY2xhc3M9J2EgcHVzaCBub0JvcmRlcic+PGltZyBjbGFzcz0naWNvbicgc3JjPScvaW1nL3RpbWVzLWNpcmNsZS5zdmcnIC8+PC9kaXY+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9J2ZsZXg6MSAxIGF1dG8nPjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdmbGV4OjAgMCAyOHB4Jz48ZGl2IGlkPSdkaXNwbGF5LWxlZnQnIHRpdGxlPSdEaXNwbGF5IHRvIHRoZSBsZWZ0JyBjbGFzcz0nYSBwdXNoIG5vQm9yZGVyJz48aW1nIGNsYXNzPSdpY29uJyBzcmM9Jy9pbWcvY2FyZXQtc3F1YXJlLW8tbGVmdC5zdmcnIC8+PC9kaXY+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9J2ZsZXg6MCAwIDI4cHgnPjxkaXYgaWQ9J2Rpc3BsYXktcmlnaHQnIHRpdGxlPSdEaXNwbGF5IHRvIHRoZSByaWdodCcgY2xhc3M9J2EgcHVzaCBub0JvcmRlcic+PGltZyBjbGFzcz0naWNvbicgc3JjPScvaW1nL2NhcmV0LXNxdWFyZS1vLXJpZ2h0LnN2ZycgLz48L2Rpdj48L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPCEtLSBzbGlkZXIgLS0+XFxuICAgICAgICA8ZGl2IGlkPSdzbGlkZXJCbG9jaycgc3R5bGU9J2ZsZXg6MCAwIDI4cHgnPlxcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9J2Rpc3BsYXk6ZmxleCc+XFxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9J2ZsZXg6MCAwIDI4cHgnPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD0ncHJldicgY2xhc3M9J2EgcHVzaCc+LTwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0nZmxleDoxIDAgMjhweDtkaXNwbGF5OmZsZXgnPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0nZmxleDoxO3Bvc2l0aW9uOnJlbGF0aXZlJz5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPSdzbGljZScgY2xhc3M9J3NsaWRlcicgZGF0YS1tYXg9MTAwIGRhdGEtdmFsPTAgc3R5bGU9J3Bvc2l0aW9uOmFic29sdXRlO2hlaWdodDoxMDAlO21hcmdpbi1sZWZ0OjEwcHg7d2lkdGg6Y2FsYygxMDAlIC0gMjBweCknPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSd0cmFjaycgc3R5bGU9J3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6NTAlO3dpZHRoOjEwMCU7Ym9yZGVyLXRvcDoxcHggc29saWQgI2ZmZjtwYWRkaW5nOjA7ZGlzcGxheTppbmxpbmUtYmxvY2snPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSd0aHVtYicgc3R5bGU9J3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGUoLTEwcHgsLTEwcHgpO2JvcmRlci1yYWRpdXM6MTBweDtwYWRkaW5nOjA7d2lkdGg6MjBweDtoZWlnaHQ6MjBweDtiYWNrZ3JvdW5kOiNmZmY7ZGlzcGxheTppbmxpbmUtYmxvY2snPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdmbGV4OjAgMCAyOHB4Jz5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9J25leHQnIGNsYXNzPSdhIHB1c2gnPis8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDwhLS0gYnV0dG9ucyAtLT5cXG4gICAgICAgIDxkaXYgaWQ9J2J1dHRvbnNCbG9jaycgc3R5bGU9J2ZsZXg6MCAwIGF1dG8nPlxcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9J2Rpc3BsYXk6ZmxleDtmbGV4LXdyYXA6d3JhcCc+XFxuXFxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9J2ZsZXg6MSAwIDI1MHB4O3dpZHRoOjUwcHgnPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD0ncGxhbmUnIHN0eWxlPSdkaXNwbGF5OmZsZXgnIGNsYXNzPSdjaG9zZSc+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0nZmxleDoxJz48ZGl2IHRpdGxlPSdzYWcnIGNsYXNzPSdhIHByZXNzZWQnPlNhZzwvZGl2PjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9J2ZsZXg6MSc+PGRpdiB0aXRsZT0nY29yJyBjbGFzcz0nYSc+Q29yPC9kaXY+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0nZmxleDoxJz48ZGl2IHRpdGxlPSdheGknIGNsYXNzPSdhJz5BeGk8L2Rpdj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0nZGlzcGxheTpmbGV4Jz5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdmbGV4OjEnPjxkaXYgaWQ9J2Z1bGxzY3JlZW4nIHRpdGxlPSdGdWxsIHNjcmVlbicgY2xhc3M9J2EgdG9nZ2xlJz48aW1nIGNsYXNzPSdpY29uJyBzcmM9Jy9pbWcvZnVsbHNjcmVlbi5zdmcnIC8+PC9kaXY+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0nZmxleDoxJz48ZGl2IGlkPSczZHJlbmRlcicgdGl0bGU9JzNEIHJlbmRlcicgY2xhc3M9J2EgcHVzaCc+PGltZyBjbGFzcz0naWNvbicgc3JjPScvaW1nLzNkcmVuZGVyLnN2ZycgLz48L2Rpdj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdmbGV4OjEnPjxkaXYgaWQ9J2xpbmsnIHRpdGxlPSdMaW5rJyBjbGFzcz0nYSBwdXNoJz48aW1nIGNsYXNzPSdpY29uJyBzcmM9Jy9pbWcvbGluay5zdmcnIC8+PC9kaXY+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0nZmxleDoxJz48ZGl2IGlkPSdidWJibGUnIHRpdGxlPSdDaGF0JyBjbGFzcz0nYSB0b2dnbGUgcHJlc3NlZCc+PGltZyBjbGFzcz0naWNvbicgc3JjPScvaW1nL2NoYXQuc3ZnJyAvPjwvZGl2PjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9J2ZsZXg6MSc+PGRpdiBpZD0ndXBsb2FkJyB0aXRsZT0nVXBsb2FkJyBjbGFzcz0nYSBwdXNoJz48aW1nIGNsYXNzPSdpY29uJyBzcmM9Jy9pbWcvdXBsb2FkLnN2ZycgLz48L2Rpdj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdmbGV4OjEnPjxkaXYgaWQ9J2Rvd25sb2FkJyB0aXRsZT0nRG93bmxvYWQnIGNsYXNzPSdhIHB1c2gnPjxpbWcgY2xhc3M9J2ljb24nIHNyYz0nL2ltZy9kb3dubG9hZC5zdmcnIC8+PC9kaXY+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0nZmxleDoxJz48ZGl2IGlkPSdwcmVjaXNlJyB0aXRsZT0nUHJlY2lzZSBjdXJzb3InIGNsYXNzPSdhIHRvZ2dsZSc+PGltZyBjbGFzcz0naWNvbicgc3JjPScvaW1nL3ByZWNpc2VDdXJzb3Iuc3ZnJyAvPjwvZGl2PjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdmbGV4OjEgMCAyNTBweDt3aWR0aDo1MHB4Jz5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9J3BhaW50VG9vbCcgc3R5bGU9J2Rpc3BsYXk6ZmxleCcgY2xhc3M9J2Nob3NlJz5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdmbGV4OjEnPjxkaXYgdGl0bGU9J1Nob3cnIGNsYXNzPSdhIHByZXNzZWQnPjxpbWcgY2xhc3M9J2ljb24nIHNyYz0nL2ltZy9zaG93LnN2ZycgLz48L2Rpdj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdmbGV4OjEnPjxkaXYgdGl0bGU9J1BhaW50JyBjbGFzcz0nYSc+PGltZyBjbGFzcz0naWNvbicgc3JjPScvaW1nL3BhaW50LnN2ZycgLz48L2Rpdj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdmbGV4OjEnPjxkaXYgdGl0bGU9J0VyYXNlJyBjbGFzcz0nYSc+PGltZyBjbGFzcz0naWNvbicgc3JjPScvaW1nL2VyYXNlLnN2ZycgLz48L2Rpdj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdmbGV4OjEnPjxkaXYgdGl0bGU9J01lYXN1cmUnIGNsYXNzPSdhJz48aW1nIGNsYXNzPSdpY29uJyBzcmM9Jy9pbWcvcnVsZXIuc3ZnJyAvPjwvZGl2PjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9J2ZsZXg6MSc+PGRpdiB0aXRsZT0nQWRqdXN0JyBjbGFzcz0nYSc+PGltZyBjbGFzcz0naWNvbicgc3JjPScvaW1nL2FkanVzdC5zdmcnIC8+PC9kaXY+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0nZmxleDoxJz48ZGl2IHRpdGxlPSdFeWVkcm9wJyBjbGFzcz0nYSc+PGltZyBjbGFzcz0naWNvbicgc3JjPScvaW1nL2V5ZWRyb3BwZXIuc3ZnJyAvPjwvZGl2PjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdkaXNwbGF5OmZsZXgnPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9J2ZsZXg6MSc+PGRpdiBpZD0nY29sb3InPjxkaXYgaWQ9J2NvbG9yJyB0aXRsZT0nQ29sb3InIHN0eWxlPSdoZWlnaHQ6MjRweDtiYWNrZ3JvdW5kOiNmMDAnIGNsYXNzPSdhIHB1c2gnPjwvZGl2PjwvZGl2PjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9J2ZsZXg6MSc+PGRpdiBpZD0nZmlsbCcgY2xhc3M9J2EgdG9nZ2xlJz48aW1nIGNsYXNzPSdpY29uJyBzcmM9Jy9pbWcvZmlsbC5zdmcnIC8+PC9kaXY+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0nZmxleDoxJz48ZGl2IGlkPSd1bmRvJyB0aXRsZT0nVW5kbycgY2xhc3M9J2EgcHVzaCc+PGltZyBjbGFzcz0naWNvbicgc3JjPScvaW1nL3VuZG8uc3ZnJyAvPjwvZGl2PjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9J2ZsZXg6MSc+PGRpdiBpZD0nc2F2ZScgdGl0bGU9J1NhdmUnIGNsYXNzPSdhIHB1c2gnPjxpbWcgY2xhc3M9J2ljb24nIHNyYz0nL2ltZy9mbG9wcHkuc3ZnJyAvPjwvZGl2PjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICA8IS0tIHBlbiBzaXplIC0tPlxcbiAgICAgICAgPGRpdiBpZD0ncGVuU2l6ZUJsb2NrJyBzdHlsZT0nZmxleDowIDAgMjhweCc+XFxuICAgICAgICAgICAgPGRpdiBzdHlsZT0nZGlzcGxheTpmbGV4JyBjbGFzcz0nY2hvc2UnIGlkPSdwZW5TaXplJz5cXG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0nZmxleDoxJz48ZGl2IHRpdGxlPScxJyBjbGFzcz0nYSBwcmVzc2VkJz4xPC9kaXY+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9J2ZsZXg6MSc+PGRpdiB0aXRsZT0nMicgY2xhc3M9J2EnPjI8L2Rpdj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0nZmxleDoxJz48ZGl2IHRpdGxlPSczJyBjbGFzcz0nYSc+MzwvZGl2PjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdmbGV4OjEnPjxkaXYgdGl0bGU9JzUnIGNsYXNzPSdhJz41PC9kaXY+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9J2ZsZXg6MSc+PGRpdiB0aXRsZT0nMTAnIGNsYXNzPSdhJz4xMDwvZGl2PjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdmbGV4OjEnPjxkaXYgdGl0bGU9JzE1JyBjbGFzcz0nYSc+MTU8L2Rpdj48L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPCEtLSBjaGF0IC0tPlxcbiAgICAgICAgPGRpdiBpZD0nY2hhdEJsb2NrJyBzdHlsZT0nZmxleDoxIDEgYXV0bztwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmZsZXgnPlxcbiAgICAgICAgICAgIDxkaXYgaWQ9J2NoYXRCbG9ja0NvbnRlbnQnIHN0eWxlPSdmbGV4OjE7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbic+XFxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9J2ZsZXg6MCAwIDI4cHgnPjxkaXYgaWQ9J2NoYXQnIGNsYXNzPSdsYWJlbCc+Q2hhdCAoZGlzY29ubmVjdGVkKTwvZGl2PjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdmbGV4OjEgMSA1OHB4O2Rpc3BsYXk6ZmxleCc+PGRpdiBpZD0nbG9nJyBjbGFzcz0nYScgc3R5bGU9J2ZsZXg6MTtoZWlnaHQ6YXV0byc+PC9kaXY+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9J2ZsZXg6MCAwIDI4cHgnPjxpbnB1dCBpZD0nbXNnJyB0eXBlPSd0ZXh0JyBzdHlsZT0nd2lkdGg6MTAwJSc+PC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuPC9kaXY+XFxuXFxuPCEtLSBMb2FkaW5nIGluZGljYXRvciAtLT5cXG48ZGl2IGlkPSdsb2FkaW5nSW5kaWNhdG9yJz5cXG4gICAgPHA+TG9hZGluZy4uLjwvcD5cXG4gICAgPGRpdiBjbGFzcz0nZGlzYyc+PC9kaXY+XFxuPC9kaXY+XFxuPCEtLSBFbmQgTG9hZGluZyBpbmRpY2F0b3IgLS0+XFxuXFxuPCEtLSBMYWJlbHMgLS0+XFxuPGRpdiBpZD0nbGFiZWxzZXQnPlxcbiAgICA8ZGl2IHN0eWxlPSd6LWluZGV4OjIzO3RleHQtYWxpZ246cmlnaHQnPlxcbiAgICAgICAgPGltZyBpZD0nbGFiZWxzLWNsb3NlJyBjbGFzcz0nYnV0dG9uJyBzcmM9Jy9pbWcvdGltZXMtY2lyY2xlLnN2ZycvPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPHVsIHN0eWxlPSdwYWRkaW5nLWxlZnQ6MXJlbSc+XFxuICAgICAgICA8bGk+XFxuICAgICAgICAgICAgPGI+TGFiZWwgU2V0PC9iPjxici8+XFxuICAgICAgICAgICAgPHNwYW4gaWQ9J2xhYmVscy1uYW1lJz48L3NwYW4+XFxuICAgICAgICA8L2xpPlxcbiAgICAgICAgPGxpPlxcbiAgICAgICAgICAgIDxiPkxhYmVsczwvYj48YnIvPlxcbiAgICAgICAgICAgIDxkaXYgaWQ9J2xhYmVsLWxpc3QnPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgaWQ9J2xhYmVsLXRlbXBsYXRlJz5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0nbGFiZWwtY29sb3InPjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0nbGFiZWwtbmFtZSc+TGFiZWwgTmFtZTwvbmFtZT5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvbGk+XFxuICAgIDwvdWw+XFxuPC9kaXY+XFxuPCEtLSBFbmQgTGFiZWxzIC0tPlxcblwiLFxuICAgIFwidG9vbHNMaWdodFwiOiBcIjxkaXYgaWQ9J3Rvb2xzLXNpZGUnIHN0eWxlPSdkaXNwbGF5OmJsb2NrJz5cXG4gICAgPGRpdiBpZD0ndG9vbHMtbWluaW1pemVkJz5cXG4gICAgICAgIDxkaXY+XFxuICAgICAgICAgICAgPGltZyBzdHlsZT0nd2lkdGg6MjhweDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MTBweDtsZWZ0OjEwcHgnIHNyYz0nL2ltZy9iYXJzLnN2ZycgLz5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgXFxuICAgIDxkaXYgaWQ9J3Rvb2xzLW1heGltaXplZCcgc3R5bGU9J2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47aGVpZ2h0OjEwMCUnPlxcbiAgICAgICAgPCEtLSB0b29scyBoaWRlL3Nob3csIGRpc3BsYXkgbGVmdC9yaWdodCAtLT5cXG4gICAgICAgIDxkaXYgaWQ9J2hlYWRlckJsb2NrJyBzdHlsZT0nZmxleDowIDEgMjhweDtiYWNrZ3JvdW5kOiMzMzMnPlxcblxcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9J2Rpc3BsYXk6ZmxleCc+XFxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9J2ZsZXg6MCAwIDI4cHgnPjxkaXYgaWQ9J2Rpc3BsYXktbWluaW1pemUnIHRpdGxlPSdNaW5pbWl6ZSB0b29sYmFyJyBjbGFzcz0nYSBwdXNoIG5vQm9yZGVyJz48aW1nIGNsYXNzPSdpY29uJyBzcmM9Jy9pbWcvdGltZXMtY2lyY2xlLnN2ZycgLz48L2Rpdj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0nZmxleDoxIDEgYXV0byc+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9J2ZsZXg6MCAwIDI4cHgnPjxkaXYgaWQ9J2Rpc3BsYXktbGVmdCcgdGl0bGU9J0Rpc3BsYXkgdG8gdGhlIGxlZnQnIGNsYXNzPSdhIHB1c2ggbm9Cb3JkZXInPjxpbWcgY2xhc3M9J2ljb24nIHNyYz0nL2ltZy9jYXJldC1zcXVhcmUtby1sZWZ0LnN2ZycgLz48L2Rpdj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0nZmxleDowIDAgMjhweCc+PGRpdiBpZD0nZGlzcGxheS1yaWdodCcgdGl0bGU9J0Rpc3BsYXkgdG8gdGhlIHJpZ2h0JyBjbGFzcz0nYSBwdXNoIG5vQm9yZGVyJz48aW1nIGNsYXNzPSdpY29uJyBzcmM9Jy9pbWcvY2FyZXQtc3F1YXJlLW8tcmlnaHQuc3ZnJyAvPjwvZGl2PjwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICA8IS0tIHNsaWRlciAtLT5cXG4gICAgICAgIDxkaXYgaWQ9J3NsaWRlckJsb2NrJyBzdHlsZT0nZmxleDowIDAgMjhweCc+XFxuICAgICAgICAgICAgPGRpdiBzdHlsZT0nZGlzcGxheTpmbGV4Jz5cXG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0nZmxleDowIDAgMjhweCc+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPSdwcmV2JyBjbGFzcz0nYSBwdXNoJz4tPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdmbGV4OjEgMCAyOHB4O2Rpc3BsYXk6ZmxleCc+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdmbGV4OjE7cG9zaXRpb246cmVsYXRpdmUnPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9J3NsaWNlJyBjbGFzcz0nc2xpZGVyJyBkYXRhLW1heD0xMDAgZGF0YS12YWw9MCBzdHlsZT0ncG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjEwMCU7bWFyZ2luLWxlZnQ6MTBweDt3aWR0aDpjYWxjKDEwMCUgLSAyMHB4KSc+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9J3RyYWNrJyBzdHlsZT0ncG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDo1MCU7d2lkdGg6MTAwJTtib3JkZXItdG9wOjFweCBzb2xpZCAjZmZmO3BhZGRpbmc6MDtkaXNwbGF5OmlubGluZS1ibG9jayc+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9J3RodW1iJyBzdHlsZT0ncG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDo1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtMTBweCwtMTBweCk7Ym9yZGVyLXJhZGl1czoxMHB4O3BhZGRpbmc6MDt3aWR0aDoyMHB4O2hlaWdodDoyMHB4O2JhY2tncm91bmQ6I2ZmZjtkaXNwbGF5OmlubGluZS1ibG9jayc+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9J2ZsZXg6MCAwIDI4cHgnPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD0nbmV4dCcgY2xhc3M9J2EgcHVzaCc+KzwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPCEtLSBidXR0b25zIC0tPlxcbiAgICAgICAgPGRpdiBpZD0nYnV0dG9uc0Jsb2NrJyBzdHlsZT0nZmxleDowIDAgYXV0byc+XFxuICAgICAgICAgICAgPGRpdiBzdHlsZT0nZGlzcGxheTpmbGV4O2ZsZXgtd3JhcDp3cmFwJz5cXG5cXG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0nZmxleDoxIDAgMTUwcHg7d2lkdGg6NTBweCc+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPSdwbGFuZScgc3R5bGU9J2Rpc3BsYXk6ZmxleCcgY2xhc3M9J2Nob3NlJz5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdmbGV4OjEnPjxkaXYgdGl0bGU9J3NhZycgY2xhc3M9J2EgcHJlc3NlZCc+U2FnPC9kaXY+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0nZmxleDoxJz48ZGl2IHRpdGxlPSdjb3InIGNsYXNzPSdhJz5Db3I8L2Rpdj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdmbGV4OjEnPjxkaXYgdGl0bGU9J2F4aScgY2xhc3M9J2EnPkF4aTwvZGl2PjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdmbGV4OjEgMCAxNTBweDt3aWR0aDo1MHB4Jz5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9J2Rpc3BsYXk6ZmxleCc+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0nZmxleDoxJz48ZGl2IGlkPSdmdWxsc2NyZWVuJyB0aXRsZT0nRnVsbCBzY3JlZW4nIGNsYXNzPSdhIHRvZ2dsZSc+PGltZyBjbGFzcz0naWNvbicgc3JjPScvaW1nL2Z1bGxzY3JlZW4uc3ZnJyAvPjwvZGl2PjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9J2ZsZXg6MSc+PGRpdiBpZD0nM2RyZW5kZXInIHRpdGxlPSczRCByZW5kZXInIGNsYXNzPSdhIHB1c2gnPjxpbWcgY2xhc3M9J2ljb24nIHNyYz0nL2ltZy8zZHJlbmRlci5zdmcnIC8+PC9kaXY+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0nZmxleDoxJz48ZGl2IGlkPSdsaW5rJyB0aXRsZT0nTGluaycgY2xhc3M9J2EgcHVzaCc+PGltZyBjbGFzcz0naWNvbicgc3JjPScvaW1nL2xpbmsuc3ZnJyAvPjwvZGl2PjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdmbGV4OjEgMCAxNTBweDt3aWR0aDo1MHB4Jz5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9J3BhaW50VG9vbCcgc3R5bGU9J2Rpc3BsYXk6ZmxleCcgY2xhc3M9J2Nob3NlJz5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdmbGV4OjEnPjxkaXYgdGl0bGU9J1Nob3cnIGNsYXNzPSdhIHByZXNzZWQnPjxpbWcgY2xhc3M9J2ljb24nIHNyYz0nL2ltZy9zaG93LnN2ZycgLz48L2Rpdj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSdmbGV4OjEnPjxkaXYgdGl0bGU9J0FkanVzdCcgY2xhc3M9J2EnPjxpbWcgY2xhc3M9J2ljb24nIHNyYz0nL2ltZy9hZGp1c3Quc3ZnJyAvPjwvZGl2PjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9J2ZsZXg6MSc+PGRpdiB0aXRsZT0nRXllZHJvcCcgY2xhc3M9J2EnPjxpbWcgY2xhc3M9J2ljb24nIHNyYz0nL2ltZy9leWVkcm9wcGVyLnN2ZycgLz48L2Rpdj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG48L2Rpdj5cXG5cXG48IS0tIExvYWRpbmcgaW5kaWNhdG9yIC0tPlxcbjxkaXYgaWQ9J2xvYWRpbmdJbmRpY2F0b3InPlxcbiAgICA8cD5Mb2FkaW5nLi4uPC9wPlxcbiAgICA8ZGl2IGNsYXNzPSdkaXNjJz48L2Rpdj5cXG48L2Rpdj5cXG48IS0tIEVuZCBMb2FkaW5nIGluZGljYXRvciAtLT5cXG5cIlxuICB9LFxuICBcImNzc1wiOiB7XG4gICAgXCJhdGxhc01ha2VyXCI6IFwiLyogYXRsYXNNYWtlclxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG4jYXRsYXNNYWtlciB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjojMjIyO1xcbiAgICBjb2xvcjp3aGl0ZTtcXG4gICAgaGVpZ2h0OjEwMCU7XFxuICAgIG1hcmdpbjowcHg7XFxuICAgIGZvbnQ6IDE0cHggXFxcIkx1Y2lkYSBHcmFuZGVcXFwiLCBcXFwiTHVjaWRhIFNhbnMgVW5pY29kZVxcXCIsIEhlbHZldGljYSwgQXJpYWwsIFZlcmRhbmEsIHNhbnMtc2VyaWY7XFxuICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcbiAgICAtbW96LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG59XFxuI3Jlc2l6YWJsZSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuI3RleHQtbGF5ZXIge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGJvdHRvbTowcHg7XFxuICAgIHJpZ2h0OjBweDtcXG4gICAgd2lkdGg6MTAwJTtcXG4gICAgaGVpZ2h0OjEwMCU7XFxuICAgIHotaW5kZXg6MTE7XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgIHBhZGRpbmc6IDVweDtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcbiN2ZWN0b3ItbGF5ZXIge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGJvdHRvbTowcHg7XFxuICAgIHJpZ2h0OjBweDtcXG4gICAgd2lkdGg6MTAwJTtcXG4gICAgaGVpZ2h0OjEwMCU7XFxuICAgIHotaW5kZXg6MTE7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG4jY2FudmFzIHtcXG4gICAgd2lkdGg6MTAwJTtcXG4gICAgaGVpZ2h0OjEwMCU7XFxuICAgIGJhY2tncm91bmQtY29sb3I6YmxhY2s7XFxuICAgIGN1cnNvcjpub25lO1xcblxcbiAgICBpbWFnZS1yZW5kZXJpbmc6b3B0aW1pemVTcGVlZDsgICAgICAgICAgICAgLyogTGVnYWwgZmFsbGJhY2sgKi9cXG4gICAgaW1hZ2UtcmVuZGVyaW5nOi1tb3otY3Jpc3AtZWRnZXM7ICAgICAgICAgIC8qIEZpcmVmb3ggICAgICAgICovXFxuICAgIGltYWdlLXJlbmRlcmluZzotby1jcmlzcC1lZGdlczsgICAgICAgICAgICAvKiBPcGVyYSAgICAgICAgICAqL1xcbiAgICBpbWFnZS1yZW5kZXJpbmc6LXdlYmtpdC1vcHRpbWl6ZS1jb250cmFzdDsgLyogU2FmYXJpICAgICAgICAgKi9cXG4gICAgaW1hZ2UtcmVuZGVyaW5nOm9wdGltaXplLWNvbnRyYXN0OyAgICAgICAgIC8qIENTUzMgUHJvcG9zZWQgICovXFxuICAgIGltYWdlLXJlbmRlcmluZzpjcmlzcC1lZGdlczsgICAgICAgICAgICAgICAvKiBDU1M0IFByb3Bvc2VkICAqL1xcbiAgICBpbWFnZS1yZW5kZXJpbmc6cGl4ZWxhdGVkOyAgICAgICAgICAgICAgICAgLyogQ1NTNCBQcm9wb3NlZCAgKi9cXG4gICAgLW1zLWludGVycG9sYXRpb24tbW9kZTpuZWFyZXN0LW5laWdoYm9yOyAgIC8qIElFOCsgICAgICAgICAgICovXFxufVxcbiN0b29scy1zaWRlIHtcXG4gICAgd2lkdGg6MTAwJTtcXG4gICAgcG9zaXRpb246cmVsYXRpdmU7XFxuICAgIHBvaW50ZXItZXZlbnRzOm5vbmU7XFxufVxcbiN0b29scy1zaWRlICN0b29scy1taW5pbWl6ZWQsXFxuI3Rvb2xzLXNpZGUgI3Rvb2xzLW1heGltaXplZCB7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XFxufVxcbi5hdGxhc01ha2VyLWZ1bGxzY3JlZW4gI2F0bGFzTWFrZXIge1xcbiAgICBwb3NpdGlvbjpmaXhlZDtcXG4gICAgdG9wOjBweDtcXG4gICAgbGVmdDowcHg7XFxuICAgIC8qd2lkdGg6IGNhbGMoIDEwMCUgLSAyNDBweCApOyovXFx0Lyogd2lkdGggb2YgdG9vbHMgKi9cXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDoxMDAlO1xcbiAgICB6LWluZGV4OjEwO1xcbn1cXG4uYXRsYXNNYWtlci1mdWxsc2NyZWVuICN0b29scy1zaWRlIHtcXG4gICAgcG9zaXRpb246Zml4ZWQ7XFxuICAgIHRvcDowcHg7XFxuICAgIHdpZHRoOjI1MHB4O1xcbiAgICBoZWlnaHQ6MTAwJTtcXG4gICAgei1pbmRleDoxMTtcXG59XFxuLmF0bGFzTWFrZXItZnVsbHNjcmVlbltkYXRhLXRvb2xiYXJEaXNwbGF5PWxlZnRdICN0b29scy1zaWRlIHtcXG4gICAgbGVmdDogMDtcXG59XFxuLmF0bGFzTWFrZXItZnVsbHNjcmVlbltkYXRhLXRvb2xiYXJEaXNwbGF5PXJpZ2h0XSAjdG9vbHMtc2lkZSB7XFxuICAgIHJpZ2h0OiAwO1xcbn1cXG4uYXRsYXNNYWtlci1mdWxsc2NyZWVuW2RhdGEtdG9vbGJhckRpc3BsYXk9bGVmdF0gI3RleHQtbGF5ZXIge1xcbiAgICB0ZXh0LWFsaWduOiByaWdodDtcXG59XFxuLmF0bGFzTWFrZXItZnVsbHNjcmVlbltkYXRhLXRvb2xiYXJEaXNwbGF5PXJpZ2h0XSAjdGV4dC1sYXllciB7XFxuICAgIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcblxcbiN0b29scy1zaWRlICN0b29scy1taW5pbWl6ZWQgZGl2IHtcXG4gICAgZGlzcGxheTppbmxpbmUtYmxvY2s7XFxuICAgIHdpZHRoOjQ4cHg7XFxuICAgIGhlaWdodDo0OHB4O1xcbiAgICBib3JkZXI6IHRoaW4gc29saWQgIzc3NztcXG4gICAgYm9yZGVyLXJhZGl1czo0OHB4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiMzMzM7XFxuICAgIHBvc2l0aW9uOmZpeGVkO1xcbiAgICBtYXJnaW46IDEwcHg7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuLmF0bGFzTWFrZXItZnVsbHNjcmVlbltkYXRhLXRvb2xiYXJEaXNwbGF5PWxlZnRdICN0b29scy1taW5pbWl6ZWQgZGl2IHtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbn1cXG4uYXRsYXNNYWtlci1mdWxsc2NyZWVuW2RhdGEtdG9vbGJhckRpc3BsYXk9cmlnaHRdICN0b29scy1taW5pbWl6ZWQgZGl2IHtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogMDtcXG59XFxuXFxuI2hlYWRlckJsb2NrIHtcXG4gICAgZGlzcGxheTogbm9uZTtcXG59XFxuLmF0bGFzTWFrZXItZnVsbHNjcmVlbiAjaGVhZGVyQmxvY2sge1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG59XFxuXFxuI2xvZyB7XFxuICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6YWxsO1xcbiAgICAtbW96LXVzZXItc2VsZWN0OmFsbDtcXG4gICAgdXNlci1zZWxlY3Q6YWxsO1xcbn1cXG4jaGVhZGVyQmxvY2sge1xcbiAgICBtYXJnaW4tYm90dG9tOjVweDtcXG59XFxuI2hlYWRlckJsb2NrIC5hIHtcXG4gICAgYm9yZGVyOm5vbmU7XFxufVxcblxcbi8qIGN1cnNvclxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cXG4jYXRsYXNNYWtlciAuZHJhd2luZ2N1cnNvciB7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNGMDA7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgcG9pbnRlci1ldmVudHM6bm9uZTtcXG59XFxuI2F0bGFzTWFrZXIgLmhpZGVwYWludGN1cnNvciB7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbiNjdXJzb3Ige1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gICAgcG9zaXRpb246YWJzb2x1dGU7XFxuICAgIHRvcDoyMDBweDtcXG4gICAgbGVmdDoyMDBweDtcXG4gICAgYm9yZGVyOnRoaW4gc29saWQgd2hpdGU7XFxuICAgIGNvbG9yOnJlZDtcXG4gICAgei1pbmRleDoyMDtcXG59XFxuI2ZpbmdlciB7XFxuICAgIGRpc3BsYXk6bm9uZTtcXG59XFxuLmRpc3BsYXktbW9kZSAjZmluZ2VyIHtcXG4gICAgZGlzcGxheTpub25lO1xcbn1cXG4uZWRpdC1tb2RlICNmaW5nZXIudG91Y2hEZXZpY2Uge1xcbiAgICBwb3NpdGlvbjphYnNvbHV0ZTtcXG4gICAgdG9wOjIwMHB4O1xcbiAgICBsZWZ0OjI1MHB4O1xcbiAgICB3aWR0aDo0MHB4O1xcbiAgICBoZWlnaHQ6NDBweDtcXG4gICAgYm9yZGVyLXN0eWxlOnNvbGlkO1xcbiAgICBib3JkZXItd2lkdGg6NHB4O1xcbiAgICBib3JkZXItcmFkaXVzOjUwJTtcXG4gICAgZGlzcGxheTppbmxpbmU7XFxufVxcbiNmaW5nZXIubW92ZSB7XFxuICAgIGJvcmRlci1jb2xvcjp5ZWxsb3c7XFxufVxcbiNmaW5nZXIuZHJhdyB7XFxuICAgIGJvcmRlci1jb2xvcjpncmVlbjtcXG59XFxuI2Zpbmdlci5jb25maWd1cmUge1xcbiAgICBib3JkZXItY29sb3I6b3JhbmdlO1xcbn1cXG5cXG4vKiBjaGF0IGxvZ1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuI2xvZyB7XFxuICAgIHRleHQtYWxpZ246bGVmdDtcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgIGJhY2tncm91bmQ6IzMzMztcXG59XFxuI21zZyB7XFxuICAgIGNvbG9yOiBibGFjaztcXG59XFxuXFxuLyogTGFiZWwgc2V0XFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuI2xhYmVsc2V0IHtcXG4gICAgZGlzcGxheTpub25lO1xcbiAgICBvdmVyZmxvdzpzY3JvbGw7XFxuICAgIHBvc2l0aW9uOmZpeGVkO1xcbiAgICB0b3A6MHB4O1xcbiAgICBsZWZ0OjBweDtcXG4gICAgd2lkdGg6MTAwJTtcXG4gICAgaGVpZ2h0OjEwMCU7XFxuICAgIHRleHQtYWxpZ246bGVmdDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjojMzMzO1xcbiAgICB6LWluZGV4OjIxO1xcbn1cXG4ubGFiZWwtY29sb3Ige1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7XFxuICAgIG1hcmdpbjo2cHg7XFxuICAgIGRpc3BsYXk6aW5saW5lLWJsb2NrO1xcbiAgICB3aWR0aDo0MHB4O1xcbiAgICBoZWlnaHQ6MzBweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjpyZ2IoMCwwLDApO1xcbn1cXG4jbGFiZWwtdGVtcGxhdGUge1xcbiAgICBkaXNwbGF5Om5vbmU7XFxufVxcbiNsYWJlbC1saXN0IHtcXG4gICAgZGlzcGxheTpmbGV4O1xcbiAgICBmbGV4LXdyYXA6d3JhcDtcXG4gICAgIHRleHQtYWxpZ246bGVmdDtcXG4gfVwiLFxuICAgIFwibG9hZGluZy1zdHlsZVwiOiBcIi8qIExvYWRpbmcgaW5kaWNhdG9yICovXFxuQC13ZWJraXQta2V5ZnJhbWVzIGxvYWRpbmcge1xcbiAgICAwJSB7bGVmdDogNDAlO31cXG4gICAgNTAlIHtsZWZ0OiA2MCU7fVxcbiAgICAxMDAlIHtsZWZ0OiA0MCU7fVxcbn1cXG4jbG9hZGluZ0luZGljYXRvciB7XFxuICAgIGRpc3BsYXk6bm9uZTtcXG4gICAgcG9zaXRpb246YWJzb2x1dGU7XFxuICAgIGxlZnQ6MDtcXG4gICAgdG9wOjA7XFxuICAgIHdpZHRoOjEwMCU7XFxuICAgIGhlaWdodDoxMDAlO1xcbiAgICBiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsMC41KTtcXG59XFxuI2xvYWRpbmdJbmRpY2F0b3IgLmRpc2Mge1xcbiAgICBwb3NpdGlvbjphYnNvbHV0ZTtcXG4gICAgbGVmdDo1MCU7XFxuICAgIHRyYW5zZm9ybTp0cmFuc2xhdGUoIC01MCUgLCAwICk7XFxuICAgIHdpZHRoOjhweDtcXG4gICAgaGVpZ2h0OjhweDtcXG4gICAgYm9yZGVyLXJhZGl1czo4cHg7XFxuICAgIGJhY2tncm91bmQ6d2hpdGU7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGxvYWRpbmc7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAxcztcXG4gICAgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiBpbmZpbml0ZTtcXG4gICAgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLWluLW91dDtcXG4gICAgYW5pbWF0aW9uLW5hbWU6IGxvYWRpbmc7XFxuICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogMXM7XFxuICAgIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6IGluZmluaXRlO1xcbiAgICBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLWluLW91dDtcXG59XFxuXCIsXG4gICAgXCJ1aVwiOiBcIi8qIFVzZXIgaW50ZXJmYWNlIHdpZGdldHM6IGJ1dHRvbnMsIHNsaWRlcnNcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuKiB7XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcbi5hIHtcXG4gICAgYm9yZGVyOnRoaW4gc29saWQgIzc3NztcXG4gICAgYm9yZGVyLXJhZGl1czozcHg7XFxuICAgIG1hcmdpbjoxcHg7XFxuICAgIHRleHQtYWxpZ246Y2VudGVyO1xcbiAgICBoZWlnaHQ6IDI0cHg7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgY29sb3I6IHdoaXRlO1xcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuLmE6aG92ZXIge1xcbiAgICBvcGFjaXR5OjAuNTtcXG4gICAgLXdlYmtpdC11c2VyLXNlbGVjdDpub25lO1xcbiAgICAtbW96LXVzZXItc2VsZWN0Om5vbmU7XFxuICAgIHVzZXItc2VsZWN0Om5vbmU7XFxufVxcbi5sYWJlbCB7XFxuICAgIGNvbG9yOiB3aGl0ZTtcXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxufVxcbi5wcmVzc2VkIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjojNTU1ICFpbXBvcnRhbnQ7XFxufVxcbi5pY29uIHtcXG4gICAgd2lkdGg6MTZweDtcXG4gICAgdmVydGljYWwtYWxpZ246bWlkZGxlO1xcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuXFxuLyogc3ZnIGJ1dHRvbnNcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xcbi5wdXNoQnV0dG9uIHtcXG4gICAgYm9yZGVyOjFweCBzb2xpZCAjZGRkO1xcbiAgICBib3JkZXItcmFkaXVzOjZweDtcXG4gICAgY29sb3I6I2RkZDtcXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7XFxuICAgIC13ZWJraXQtYXBwZWFyYW5jZTpub25lO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcbi5jaG9zZSB7XFxuICAgIGJvcmRlci1yYWRpdXM6M3B4O1xcbiAgICBiYWNrZ3JvdW5kOiM3Nzc7XFxuICAgIG1hcmdpbjoycHg7XFxufVxcbi5jaG9zZSAuYSB7XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgYm9yZGVyLXJhZGl1czowcHg7XFxuICAgIGhlaWdodDoyMnB4O1xcbiAgICBiYWNrZ3JvdW5kOiAjMjIyO1xcbn1cXG5pbWcuYnV0dG9uIHtcXG4gICAgd2lkdGg6MC45cmVtO1xcbiAgICBoZWlnaHQ6MC45cmVtO1xcbiAgICBtYXJnaW46OHB4IDJweDtcXG4gICAgdmVydGljYWwtYWxpZ246bWlkZGxlO1xcbiAgICBjdXJzb3I6cG9pbnRlcjtcXG59XFxuaW1nLmJ1dHRvbjpob3ZlciB7XFxuICAgIG9wYWNpdHk6MC41O1xcbn1cXG5pbWcuaWNvbiB7XFxuICAgIHdpZHRoOjFyZW07XFxuICAgIGhlaWdodDoxcmVtO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDo1MCU7XFxuICAgIGxlZnQ6NTAlO1xcbiAgICB0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUsIC01MCUpO1xcbiAgICBjdXJzb3I6cG9pbnRlcjtcXG59XFxuXFxuLm5vQm9yZGVyIHtcXG4gICAgYm9yZGVyOiBub25lO1xcbn1cXG5cXG4ubXVpLXNlbGVjdCB7XFxuICAgIGJvcmRlcjpub25lO1xcbiAgICBiYWNrZ3JvdW5kOm5vbmU7IC8qIG5vIGNvbG9yLCBubyBkZWNvcmF0aW9uICovXFxuICAgIGNvbG9yOndoaXRlO1xcbiAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgIC1tb3otYXBwZWFyYW5jZTogbm9uZTtcXG4gICAgYXBwZWFyYW5jZTogbm9uZTtcXG4gICAgb3V0bGluZTogbm9uZTtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cIlxuICB9LFxuICBcInN2Z1wiOiB7XG4gICAgXCIzZHJlbmRlclwiOiBcIjw/eG1sIHZlcnNpb249XFxcIjEuMFxcXCIgZW5jb2Rpbmc9XFxcIlVURi04XFxcIiBzdGFuZGFsb25lPVxcXCJub1xcXCI/PlxcbjxzdmdcXG4gICB4bWxuczpkYz1cXFwiaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS9cXFwiXFxuICAgeG1sbnM6Y2M9XFxcImh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zI1xcXCJcXG4gICB4bWxuczpyZGY9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyNcXFwiXFxuICAgeG1sbnM6c3ZnPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgeG1sbnM6c29kaXBvZGk9XFxcImh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkXFxcIlxcbiAgIHhtbG5zOmlua3NjYXBlPVxcXCJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlXFxcIlxcbiAgIGlkPVxcXCJzdmcyXFxcIlxcbiAgIHZlcnNpb249XFxcIjEuMVxcXCJcXG4gICBpbmtzY2FwZTp2ZXJzaW9uPVxcXCIwLjkxIHIxMzcyNVxcXCJcXG4gICBzb2RpcG9kaTpkb2NuYW1lPVxcXCIzZHJlbmRlci5zdmdcXFwiXFxuICAgd2lkdGg9XFxcIjE1MzZcXFwiXFxuICAgaGVpZ2h0PVxcXCIxNTM2XFxcIj5cXG4gIDxtZXRhZGF0YVxcbiAgICAgaWQ9XFxcIm1ldGFkYXRhMTBcXFwiPlxcbiAgICA8cmRmOlJERj5cXG4gICAgICA8Y2M6V29ya1xcbiAgICAgICAgIHJkZjphYm91dD1cXFwiXFxcIj5cXG4gICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PlxcbiAgICAgICAgPGRjOnR5cGVcXG4gICAgICAgICAgIHJkZjpyZXNvdXJjZT1cXFwiaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2VcXFwiIC8+XFxuICAgICAgICA8ZGM6dGl0bGUgLz5cXG4gICAgICA8L2NjOldvcms+XFxuICAgIDwvcmRmOlJERj5cXG4gIDwvbWV0YWRhdGE+XFxuICA8ZGVmc1xcbiAgICAgaWQ9XFxcImRlZnM4XFxcIiAvPlxcbiAgPHNvZGlwb2RpOm5hbWVkdmlld1xcbiAgICAgcGFnZWNvbG9yPVxcXCIjZmZmZmZmXFxcIlxcbiAgICAgYm9yZGVyY29sb3I9XFxcIiM2NjY2NjZcXFwiXFxuICAgICBib3JkZXJvcGFjaXR5PVxcXCIxXFxcIlxcbiAgICAgb2JqZWN0dG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGdyaWR0b2xlcmFuY2U9XFxcIjEwXFxcIlxcbiAgICAgZ3VpZGV0b2xlcmFuY2U9XFxcIjEwXFxcIlxcbiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PVxcXCIyXFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPVxcXCIxNjcyXFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD1cXFwiMTEzMlxcXCJcXG4gICAgIGlkPVxcXCJuYW1lZHZpZXc2XFxcIlxcbiAgICAgc2hvd2dyaWQ9XFxcImZhbHNlXFxcIlxcbiAgICAgZml0LW1hcmdpbi10b3A9XFxcIjBcXFwiXFxuICAgICBmaXQtbWFyZ2luLWxlZnQ9XFxcIjBcXFwiXFxuICAgICBmaXQtbWFyZ2luLXJpZ2h0PVxcXCIwXFxcIlxcbiAgICAgZml0LW1hcmdpbi1ib3R0b209XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTp6b29tPVxcXCIwLjMzMzEyNTU2XFxcIlxcbiAgICAgaW5rc2NhcGU6Y3g9XFxcIjY3NC4yMzM4MlxcXCJcXG4gICAgIGlua3NjYXBlOmN5PVxcXCI4NTIuMzcyMzRcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3cteD1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy15PVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LW1heGltaXplZD1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9XFxcInN2ZzJcXFwiIC8+XFxuICA8cGF0aFxcbiAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT1cXFwiMFxcXCJcXG4gICAgIGlkPVxcXCJwYXRoNDE2NVxcXCJcXG4gICAgIHN0eWxlPVxcXCJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmVcXFwiXFxuICAgICBkPVxcXCJNIDE0MTUuNzUwNSwxMTQ4LjI1NzIgNzY4LjAxOTA1LDE1MjguNTA1IDEyMC4yNDQzLDExNDguMjU3MiBsIDAsLTc2MC40ODEzMiA2NDcuNzc0NzUsLTM4MC4yOTA0MzYgNjQ3LjczMTQ1LDM4MC4yOTA0MzYgMCw3NjAuNDgxMzIgelxcXCIgLz5cXG4gIDxwYXRoXFxuICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPVxcXCIwXFxcIlxcbiAgICAgaWQ9XFxcInBhdGg0MTY5XFxcIlxcbiAgICAgc3R5bGU9XFxcImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MC42OTgwMzg5ODtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZVxcXCJcXG4gICAgIGQ9XFxcIm0gMTQxNS43NTA1LDExNDguMjU3MiAwLC03NjAuNDgxMzIgLTY0Ny43MzE0NSwzODAuMjQ3NzYgMCw3NjAuNDgxMzYgNjQ3LjczMTQ1LC0zODAuMjQ3OCB6XFxcIiAvPlxcbiAgPHBhdGhcXG4gICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9XFxcIjBcXFwiXFxuICAgICBpZD1cXFwicGF0aDQxNzFcXFwiXFxuICAgICBzdHlsZT1cXFwiZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eTowLjM5NjA3ODAxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lXFxcIlxcbiAgICAgZD1cXFwibSAxMjAuMjQ0MywxMTQ4LjI1NzIgMCwtNzYwLjQ4MTMyIDY0Ny43NzQ3NSwzODAuMjQ3NzYgMCw3NjAuNDgxMzYgLTY0Ny43NzQ3NSwtMzgwLjI0NzggelxcXCIgLz5cXG4gIDxnXFxuICAgICB0cmFuc2Zvcm09XFxcIm1hdHJpeCgxNC4yMjcxMDIsMCwwLDE0LjIyNzEwMiwtMTM0OS4yNTg0LC0yMzEuMDk4MDUpXFxcIlxcbiAgICAgaWQ9XFxcImc0MTc3XFxcIj5cXG4gICAgPHBhdGhcXG4gICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT1cXFwiMFxcXCJcXG4gICAgICAgaWQ9XFxcInBhdGg0MTc5XFxcIlxcbiAgICAgICBzdHlsZT1cXFwiZmlsbDpub25lO3N0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDoxLjYwMDAwMDAyO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjFcXFwiXFxuICAgICAgIGQ9XFxcIk0gMTk0LjM0OCw0My41IDE0OC44Miw3MC4yMjcgMTAzLjI4OSw0My41XFxcIiAvPlxcbiAgPC9nPlxcbjwvc3ZnPlxcblwiLFxuICAgIFwiYWRqdXN0XCI6IFwiPD94bWwgdmVyc2lvbj1cXFwiMS4wXFxcIiBlbmNvZGluZz1cXFwiVVRGLThcXFwiIHN0YW5kYWxvbmU9XFxcIm5vXFxcIj8+XFxuPHN2Z1xcbiAgIHhtbG5zOmRjPVxcXCJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xL1xcXCJcXG4gICB4bWxuczpjYz1cXFwiaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjXFxcIlxcbiAgIHhtbG5zOnJkZj1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zI1xcXCJcXG4gICB4bWxuczpzdmc9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICB4bWxuczpzb2RpcG9kaT1cXFwiaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGRcXFwiXFxuICAgeG1sbnM6aW5rc2NhcGU9XFxcImh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGVcXFwiXFxuICAgd2lkdGg9XFxcIjE3OTJcXFwiXFxuICAgaGVpZ2h0PVxcXCIxNzkyXFxcIlxcbiAgIHZpZXdCb3g9XFxcIjAgMCAxNzkyIDE3OTJcXFwiXFxuICAgaWQ9XFxcInN2ZzJcXFwiXFxuICAgdmVyc2lvbj1cXFwiMS4xXFxcIlxcbiAgIGlua3NjYXBlOnZlcnNpb249XFxcIjAuOTEgcjEzNzI1XFxcIlxcbiAgIHNvZGlwb2RpOmRvY25hbWU9XFxcImFkanVzdF8uc3ZnXFxcIj5cXG4gIDxtZXRhZGF0YVxcbiAgICAgaWQ9XFxcIm1ldGFkYXRhMTBcXFwiPlxcbiAgICA8cmRmOlJERj5cXG4gICAgICA8Y2M6V29ya1xcbiAgICAgICAgIHJkZjphYm91dD1cXFwiXFxcIj5cXG4gICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PlxcbiAgICAgICAgPGRjOnR5cGVcXG4gICAgICAgICAgIHJkZjpyZXNvdXJjZT1cXFwiaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2VcXFwiIC8+XFxuICAgICAgICA8ZGM6dGl0bGU+PC9kYzp0aXRsZT5cXG4gICAgICA8L2NjOldvcms+XFxuICAgIDwvcmRmOlJERj5cXG4gIDwvbWV0YWRhdGE+XFxuICA8ZGVmc1xcbiAgICAgaWQ9XFxcImRlZnM4XFxcIiAvPlxcbiAgPHNvZGlwb2RpOm5hbWVkdmlld1xcbiAgICAgcGFnZWNvbG9yPVxcXCIjZmZmZmZmXFxcIlxcbiAgICAgYm9yZGVyY29sb3I9XFxcIiM2NjY2NjZcXFwiXFxuICAgICBib3JkZXJvcGFjaXR5PVxcXCIxXFxcIlxcbiAgICAgb2JqZWN0dG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGdyaWR0b2xlcmFuY2U9XFxcIjEwXFxcIlxcbiAgICAgZ3VpZGV0b2xlcmFuY2U9XFxcIjEwXFxcIlxcbiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PVxcXCIyXFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPVxcXCIxMzA5XFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD1cXFwiODgwXFxcIlxcbiAgICAgaWQ9XFxcIm5hbWVkdmlldzZcXFwiXFxuICAgICBzaG93Z3JpZD1cXFwiZmFsc2VcXFwiXFxuICAgICBpbmtzY2FwZTp6b29tPVxcXCIwLjEyNjk1MzQ0XFxcIlxcbiAgICAgaW5rc2NhcGU6Y3g9XFxcIjQxMS40MjYzNVxcXCJcXG4gICAgIGlua3NjYXBlOmN5PVxcXCI4OTZcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3cteD1cXFwiNzFcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3cteT1cXFwiMTA4XFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LW1heGltaXplZD1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9XFxcInN2ZzJcXFwiIC8+XFxuICA8Z1xcbiAgICAgaWQ9XFxcImc0MTU0XFxcIj5cXG4gICAgPHBhdGhcXG4gICAgICAgc3R5bGU9XFxcImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MVxcXCJcXG4gICAgICAgaWQ9XFxcInBhdGg0XFxcIlxcbiAgICAgICBkPVxcXCJtIDkwNC4zNTQ3MiwxNTI4LjI3NzMgLTcuODc2OSwtMTI2MS4wOTM5NiBjIC0xNDguNzk0OTgsMCAtMjI3LjY3MzUxLDI3LjAyNTE4IC0zMjQuMDAxOTYsODMuMTgzOTkgLTk1LjAwNzI0LDU1LjM4ODU1IC0xNzQuMjYxODgsMTQyLjE4NDY3IC0yMjguODMxODgsMjM3LjY2NDQyIC00Ny4wNzYzMyw4Mi4zNjgyNiAtNzQuMDY1ODgsMTc5LjMxMTY5IC03Ni40NjA2NSwyNzQuMTUzNTQgLTIuODQwMDYsMTEyLjQ3NjgyIDIxLjI2MDMzLDIyOS45ODczMSA3NC4xNTM1NSwzMjkuMjkxOTEgNTMuMDk1NDcsOTkuNjg0MyAxMzUuOTMyMiwxODguMDkyNCAyMzIuNzcwMzQsMjQ2LjIxNyA5Ny44NzE3Nyw1OC43NDUgMjMxLjU4MDgzLDkwLjU4MzEgMzMwLjI0NzUsOTAuNTgzMSB6IE0gMTY2NCw4OTYgYyAwLDEzOS4zMzMzIC0zNC4zMzMzLDI2Ny44MzMzIC0xMDMsMzg1LjUgLTY4LjY2NjcsMTE3LjY2NjcgLTE2MS44MzMzLDIxMC44MzMzIC0yNzkuNSwyNzkuNSAtMTE3LjY2NjcsNjguNjY2NyAtMjQ2LjE2NjcsMTAzIC0zODUuNSwxMDMgLTEzOS4zMzMzMywwIC0yNjcuODMzMzMsLTM0LjMzMzMgLTM4NS41LC0xMDMgQyAzOTIuODMzMzMsMTQ5Mi4zMzMzIDI5OS42NjY2NywxMzk5LjE2NjcgMjMxLDEyODEuNSAxNjIuMzMzMzMsMTE2My44MzMzIDEyOCwxMDM1LjMzMzMgMTI4LDg5NiAxMjgsNzU2LjY2NjY3IDE2Mi4zMzMzMyw2MjguMTY2NjcgMjMxLDUxMC41IDI5OS42NjY2NywzOTIuODMzMzMgMzkyLjgzMzMzLDI5OS42NjY2NyA1MTAuNSwyMzEgNjI4LjE2NjY3LDE2Mi4zMzMzMyA3NTYuNjY2NjcsMTI4IDg5NiwxMjggYyAxMzkuMzMzMywwIDI2Ny44MzMzLDM0LjMzMzMzIDM4NS41LDEwMyAxMTcuNjY2Nyw2OC42NjY2NyAyMTAuODMzMywxNjEuODMzMzMgMjc5LjUsMjc5LjUgNjguNjY2NywxMTcuNjY2NjcgMTAzLDI0Ni4xNjY2NyAxMDMsMzg1LjUgelxcXCJcXG4gICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT1cXFwiMFxcXCJcXG4gICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPVxcXCJjY2FhYWFhY3Nzc3Nzc3Nzc3Nzc3NcXFwiIC8+XFxuICA8L2c+XFxuPC9zdmc+XFxuXCIsXG4gICAgXCJhbHBoYVwiOiBcIjw/eG1sIHZlcnNpb249XFxcIjEuMFxcXCIgZW5jb2Rpbmc9XFxcIlVURi04XFxcIiBzdGFuZGFsb25lPVxcXCJub1xcXCI/PlxcbjxzdmdcXG4gICB4bWxuczpkYz1cXFwiaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS9cXFwiXFxuICAgeG1sbnM6Y2M9XFxcImh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zI1xcXCJcXG4gICB4bWxuczpyZGY9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyNcXFwiXFxuICAgeG1sbnM6c3ZnPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgeG1sbnM6eGxpbms9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcXFwiXFxuICAgeG1sbnM6c29kaXBvZGk9XFxcImh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkXFxcIlxcbiAgIHhtbG5zOmlua3NjYXBlPVxcXCJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlXFxcIlxcbiAgIGlkPVxcXCJzdmcyXFxcIlxcbiAgIHZlcnNpb249XFxcIjEuMVxcXCJcXG4gICBpbmtzY2FwZTp2ZXJzaW9uPVxcXCIwLjkxIHIxMzcyNVxcXCJcXG4gICBzb2RpcG9kaTpkb2NuYW1lPVxcXCJhbHBoYTMuc3ZnXFxcIlxcbiAgIHdpZHRoPVxcXCIxNTM2XFxcIlxcbiAgIGhlaWdodD1cXFwiMTUzNlxcXCI+XFxuICA8bWV0YWRhdGFcXG4gICAgIGlkPVxcXCJtZXRhZGF0YTEwXFxcIj5cXG4gICAgPHJkZjpSREY+XFxuICAgICAgPGNjOldvcmtcXG4gICAgICAgICByZGY6YWJvdXQ9XFxcIlxcXCI+XFxuICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD5cXG4gICAgICAgIDxkYzp0eXBlXFxuICAgICAgICAgICByZGY6cmVzb3VyY2U9XFxcImh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlXFxcIiAvPlxcbiAgICAgICAgPGRjOnRpdGxlIC8+XFxuICAgICAgPC9jYzpXb3JrPlxcbiAgICA8L3JkZjpSREY+XFxuICA8L21ldGFkYXRhPlxcbiAgPGRlZnNcXG4gICAgIGlkPVxcXCJkZWZzOFxcXCI+XFxuICAgIDxsaW5lYXJHcmFkaWVudFxcbiAgICAgICBpbmtzY2FwZTpjb2xsZWN0PVxcXCJhbHdheXNcXFwiXFxuICAgICAgIGlkPVxcXCJsaW5lYXJHcmFkaWVudDQxNzBcXFwiPlxcbiAgICAgIDxzdG9wXFxuICAgICAgICAgc3R5bGU9XFxcInN0b3AtY29sb3I6I2ZmZmZmZjtzdG9wLW9wYWNpdHk6MTtcXFwiXFxuICAgICAgICAgb2Zmc2V0PVxcXCIwXFxcIlxcbiAgICAgICAgIGlkPVxcXCJzdG9wNDE3MlxcXCIgLz5cXG4gICAgICA8c3RvcFxcbiAgICAgICAgIHN0eWxlPVxcXCJzdG9wLWNvbG9yOiNmZmZmZmY7c3RvcC1vcGFjaXR5OjA7XFxcIlxcbiAgICAgICAgIG9mZnNldD1cXFwiMVxcXCJcXG4gICAgICAgICBpZD1cXFwic3RvcDQxNzRcXFwiIC8+XFxuICAgIDwvbGluZWFyR3JhZGllbnQ+XFxuICAgIDxsaW5lYXJHcmFkaWVudFxcbiAgICAgICBpbmtzY2FwZTpjb2xsZWN0PVxcXCJhbHdheXNcXFwiXFxuICAgICAgIHhsaW5rOmhyZWY9XFxcIiNsaW5lYXJHcmFkaWVudDQxNzBcXFwiXFxuICAgICAgIGlkPVxcXCJsaW5lYXJHcmFkaWVudDQxNzZcXFwiXFxuICAgICAgIHgxPVxcXCItNTk5LjQ0NzgxXFxcIlxcbiAgICAgICB5MT1cXFwiNzU3LjAwMTgzXFxcIlxcbiAgICAgICB4Mj1cXFwiMTE3MS41NDUyXFxcIlxcbiAgICAgICB5Mj1cXFwiNzYyLjgzNzY1XFxcIlxcbiAgICAgICBncmFkaWVudFVuaXRzPVxcXCJ1c2VyU3BhY2VPblVzZVxcXCJcXG4gICAgICAgZ3JhZGllbnRUcmFuc2Zvcm09XFxcIm1hdHJpeCgwLjg3MDcxMjEsMCwwLDAuODc0MjE1OTgsLTE0NDMuMDk3OSwtMTQ0My45NDEzKVxcXCIgLz5cXG4gIDwvZGVmcz5cXG4gIDxzb2RpcG9kaTpuYW1lZHZpZXdcXG4gICAgIHBhZ2Vjb2xvcj1cXFwiI2ZmZmZmZlxcXCJcXG4gICAgIGJvcmRlcmNvbG9yPVxcXCIjNjY2NjY2XFxcIlxcbiAgICAgYm9yZGVyb3BhY2l0eT1cXFwiMVxcXCJcXG4gICAgIG9iamVjdHRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBncmlkdG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGd1aWRldG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz1cXFwiMlxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD1cXFwiMTY3MlxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9XFxcIjExMzJcXFwiXFxuICAgICBpZD1cXFwibmFtZWR2aWV3NlxcXCJcXG4gICAgIHNob3dncmlkPVxcXCJmYWxzZVxcXCJcXG4gICAgIGZpdC1tYXJnaW4tdG9wPVxcXCIwXFxcIlxcbiAgICAgZml0LW1hcmdpbi1sZWZ0PVxcXCIwXFxcIlxcbiAgICAgZml0LW1hcmdpbi1yaWdodD1cXFwiMFxcXCJcXG4gICAgIGZpdC1tYXJnaW4tYm90dG9tPVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6em9vbT1cXFwiMC4xNjY1NjI3OFxcXCJcXG4gICAgIGlua3NjYXBlOmN4PVxcXCItNDczLjIxMjQzXFxcIlxcbiAgICAgaW5rc2NhcGU6Y3k9XFxcIjg1Mi4zNzIzNFxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy14PVxcXCIxNDlcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3cteT1cXFwiMjA5XFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LW1heGltaXplZD1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9XFxcInN2ZzJcXFwiIC8+XFxuICA8ZWxsaXBzZVxcbiAgICAgc3R5bGU9XFxcIm9wYWNpdHk6MTtmaWxsOnVybCgjbGluZWFyR3JhZGllbnQ0MTc2KTtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6I2ZmZmZmZjtzdHJva2Utd2lkdGg6OTAuNzQ4O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDozLjI3NTkwMDEzO3N0cm9rZS1vcGFjaXR5OjFcXFwiXFxuICAgICBpZD1cXFwicGF0aDQxNThcXFwiXFxuICAgICBjeT1cXFwiLTc2OS4wMjU3XFxcIlxcbiAgICAgY3g9XFxcIi03NzIuNjY3MTFcXFwiXFxuICAgICB0cmFuc2Zvcm09XFxcInNjYWxlKC0xLC0xKVxcXCJcXG4gICAgIHJ4PVxcXCI2NTQuNzQ4MjlcXFwiXFxuICAgICByeT1cXFwiNjU3LjM4MzA2XFxcIiAvPlxcbjwvc3ZnPlxcblwiLFxuICAgIFwiYmFyc1wiOiBcIjw/eG1sIHZlcnNpb249XFxcIjEuMFxcXCIgZW5jb2Rpbmc9XFxcIlVURi04XFxcIiBzdGFuZGFsb25lPVxcXCJub1xcXCI/PlxcbjxzdmdcXG4gICB4bWxuczpkYz1cXFwiaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS9cXFwiXFxuICAgeG1sbnM6Y2M9XFxcImh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zI1xcXCJcXG4gICB4bWxuczpyZGY9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyNcXFwiXFxuICAgeG1sbnM6c3ZnPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgeG1sbnM6c29kaXBvZGk9XFxcImh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkXFxcIlxcbiAgIHhtbG5zOmlua3NjYXBlPVxcXCJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlXFxcIlxcbiAgIHdpZHRoPVxcXCIxNzkyXFxcIlxcbiAgIGhlaWdodD1cXFwiMTc5MlxcXCJcXG4gICB2aWV3Qm94PVxcXCIwIDAgMTc5MiAxNzkyXFxcIlxcbiAgIGlkPVxcXCJzdmcyXFxcIlxcbiAgIHZlcnNpb249XFxcIjEuMVxcXCJcXG4gICBpbmtzY2FwZTp2ZXJzaW9uPVxcXCIwLjkxIHIxMzcyNVxcXCJcXG4gICBzb2RpcG9kaTpkb2NuYW1lPVxcXCJiYXJzLnN2Z1xcXCI+XFxuICA8bWV0YWRhdGFcXG4gICAgIGlkPVxcXCJtZXRhZGF0YTEwXFxcIj5cXG4gICAgPHJkZjpSREY+XFxuICAgICAgPGNjOldvcmtcXG4gICAgICAgICByZGY6YWJvdXQ9XFxcIlxcXCI+XFxuICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD5cXG4gICAgICAgIDxkYzp0eXBlXFxuICAgICAgICAgICByZGY6cmVzb3VyY2U9XFxcImh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlXFxcIiAvPlxcbiAgICAgICAgPGRjOnRpdGxlIC8+XFxuICAgICAgPC9jYzpXb3JrPlxcbiAgICA8L3JkZjpSREY+XFxuICA8L21ldGFkYXRhPlxcbiAgPGRlZnNcXG4gICAgIGlkPVxcXCJkZWZzOFxcXCIgLz5cXG4gIDxzb2RpcG9kaTpuYW1lZHZpZXdcXG4gICAgIHBhZ2Vjb2xvcj1cXFwiI2ZmZmZmZlxcXCJcXG4gICAgIGJvcmRlcmNvbG9yPVxcXCIjNjY2NjY2XFxcIlxcbiAgICAgYm9yZGVyb3BhY2l0eT1cXFwiMVxcXCJcXG4gICAgIG9iamVjdHRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBncmlkdG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGd1aWRldG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz1cXFwiMlxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD1cXFwiMTM2N1xcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9XFxcIjkxMlxcXCJcXG4gICAgIGlkPVxcXCJuYW1lZHZpZXc2XFxcIlxcbiAgICAgc2hvd2dyaWQ9XFxcImZhbHNlXFxcIlxcbiAgICAgaW5rc2NhcGU6em9vbT1cXFwiMC4yNjU1NDczXFxcIlxcbiAgICAgaW5rc2NhcGU6Y3g9XFxcIjIwMy40Njk5MVxcXCJcXG4gICAgIGlua3NjYXBlOmN5PVxcXCI4OTZcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3cteD1cXFwiNFxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy15PVxcXCIyM1xcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPVxcXCJzdmcyXFxcIiAvPlxcbiAgPHBhdGhcXG4gICAgIHN0eWxlPVxcXCJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjFcXFwiXFxuICAgICBkPVxcXCJtIDI1Ny44MjY2Myw1MTQuNDU0NDggcSAwLC0xMS40OTA3OSAyNy4wNjUzOCwtMTkuODg3OSAyNy4wNjUzOCwtOC4zOTcxMSA2NC4xMDIyMywtOC4zOTcxMSBsIDEwOTQuMDExNTYsMCBxIDM3LjAzNjgsMCA2NC4xMDIyLDguMzk3MSAyNy4wNjU0LDguMzk3MTEgMjcuMDY1NCwxOS44ODc5IGwgMCw1Ni41NzAwMSBxIDAsMTEuNDkwNzkgLTI3LjA2NTQsMTkuODg3OSAtMjcuMDY1NCw4LjM5NzExIC02NC4xMDIyLDguMzk3MTEgbCAtMTA5NC4wMTE1NiwwIHEgLTM3LjAzNjg1LDAgLTY0LjEwMjIzLC04LjM5NzExIC0yNy4wNjUzOCwtOC4zOTcxMSAtMjcuMDY1MzgsLTE5Ljg4NzkgbCAwLC01Ni41NzAwMSB6XFxcIlxcbiAgICAgaWQ9XFxcInBhdGg0LTVcXFwiXFxuICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPVxcXCIwXFxcIiAvPlxcbiAgPHBhdGhcXG4gICAgIHN0eWxlPVxcXCJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjFcXFwiXFxuICAgICBkPVxcXCJtIDI1Ny44MjY2MywxMjI4LjUwNzQgcSAwLC0xMS40OTA4IDI3LjA2NTM4LC0xOS44ODc5IDI3LjA2NTM4LC04LjM5NzEgNjQuMTAyMjMsLTguMzk3MSBsIDEwOTQuMDExNTYsMCBxIDM3LjAzNjgsMCA2NC4xMDIyLDguMzk3MSAyNy4wNjU0LDguMzk3MSAyNy4wNjU0LDE5Ljg4NzkgbCAwLDU2LjU3IHEgMCwxMS40OTA4IC0yNy4wNjU0LDE5Ljg4NzkgLTI3LjA2NTQsOC4zOTcxIC02NC4xMDIyLDguMzk3MSBsIC0xMDk0LjAxMTU1LDAgcSAtMzcuMDM2ODQsMCAtNjQuMTAyMjMsLTguMzk3MSAtMjcuMDY1MzgsLTguMzk3MSAtMjcuMDY1MzgsLTE5Ljg4NzkgbCAwLC01Ni41NyB6XFxcIlxcbiAgICAgaWQ9XFxcInBhdGg0LTUtOFxcXCJcXG4gICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9XFxcIjBcXFwiIC8+XFxuICA8cGF0aFxcbiAgICAgc3R5bGU9XFxcImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MVxcXCJcXG4gICAgIGQ9XFxcIm0gMjU3LjgyNjY2LDg3MS40ODA5OSBxIDAsLTExLjQ5MDc5IDI3LjA2NTM4LC0xOS44ODc4OSAyNy4wNjU0LC04LjM5NzEyIDY0LjEwMjIzLC04LjM5NzEyIGwgMTA5NC4wMTE0MywwIHEgMzcuMDM2NywwIDY0LjEwMjIsOC4zOTcxMSAyNy4wNjU0LDguMzk3MTEgMjcuMDY1NCwxOS44ODc4OSBsIDAsNTYuNTcwMDIgcSAwLDExLjQ5MDggLTI3LjA2NTQsMTkuODg3OSAtMjcuMDY1NSw4LjM5NzEgLTY0LjEwMjIsOC4zOTcxIGwgLTEwOTQuMDExNDIsMCBxIC0zNy4wMzY4NCwwIC02NC4xMDIyNCwtOC4zOTcxIC0yNy4wNjUzOCwtOC4zOTcxIC0yNy4wNjUzOCwtMTkuODg3OSBsIDAsLTU2LjU3MDAyIHpcXFwiXFxuICAgICBpZD1cXFwicGF0aDQtNS03XFxcIlxcbiAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT1cXFwiMFxcXCIgLz5cXG48L3N2Zz5cXG5cIixcbiAgICBcImNhcmV0LXNxdWFyZS1vLWxlZnRcIjogXCI8P3htbCB2ZXJzaW9uPVxcXCIxLjBcXFwiIGVuY29kaW5nPVxcXCJVVEYtOFxcXCIgc3RhbmRhbG9uZT1cXFwibm9cXFwiPz5cXG48c3ZnXFxuICAgeG1sbnM6ZGM9XFxcImh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvXFxcIlxcbiAgIHhtbG5zOmNjPVxcXCJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyNcXFwiXFxuICAgeG1sbnM6cmRmPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjXFxcIlxcbiAgIHhtbG5zOnN2Zz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgIHhtbG5zOnNvZGlwb2RpPVxcXCJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZFxcXCJcXG4gICB4bWxuczppbmtzY2FwZT1cXFwiaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZVxcXCJcXG4gICB3aWR0aD1cXFwiMTc5MlxcXCJcXG4gICBoZWlnaHQ9XFxcIjE3OTJcXFwiXFxuICAgdmlld0JveD1cXFwiMCAwIDE3OTIgMTc5MlxcXCJcXG4gICBpZD1cXFwic3ZnMlxcXCJcXG4gICB2ZXJzaW9uPVxcXCIxLjFcXFwiXFxuICAgaW5rc2NhcGU6dmVyc2lvbj1cXFwiMC45MSByMTM3MjVcXFwiXFxuICAgc29kaXBvZGk6ZG9jbmFtZT1cXFwiY2FyZXQtc3F1YXJlLW8tbGVmdC5zdmdcXFwiPlxcbiAgPG1ldGFkYXRhXFxuICAgICBpZD1cXFwibWV0YWRhdGExMFxcXCI+XFxuICAgIDxyZGY6UkRGPlxcbiAgICAgIDxjYzpXb3JrXFxuICAgICAgICAgcmRmOmFib3V0PVxcXCJcXFwiPlxcbiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+XFxuICAgICAgICA8ZGM6dHlwZVxcbiAgICAgICAgICAgcmRmOnJlc291cmNlPVxcXCJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZVxcXCIgLz5cXG4gICAgICAgIDxkYzp0aXRsZT48L2RjOnRpdGxlPlxcbiAgICAgIDwvY2M6V29yaz5cXG4gICAgPC9yZGY6UkRGPlxcbiAgPC9tZXRhZGF0YT5cXG4gIDxkZWZzXFxuICAgICBpZD1cXFwiZGVmczhcXFwiIC8+XFxuICA8c29kaXBvZGk6bmFtZWR2aWV3XFxuICAgICBwYWdlY29sb3I9XFxcIiNmZmZmZmZcXFwiXFxuICAgICBib3JkZXJjb2xvcj1cXFwiIzY2NjY2NlxcXCJcXG4gICAgIGJvcmRlcm9wYWNpdHk9XFxcIjFcXFwiXFxuICAgICBvYmplY3R0b2xlcmFuY2U9XFxcIjEwXFxcIlxcbiAgICAgZ3JpZHRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBndWlkZXRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9XFxcIjJcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9XFxcIjE3ODVcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PVxcXCIxMDgyXFxcIlxcbiAgICAgaWQ9XFxcIm5hbWVkdmlldzZcXFwiXFxuICAgICBzaG93Z3JpZD1cXFwiZmFsc2VcXFwiXFxuICAgICBpbmtzY2FwZTp6b29tPVxcXCIwLjM3ODExMjc5XFxcIlxcbiAgICAgaW5rc2NhcGU6Y3g9XFxcIjEyMTEuMDgzNVxcXCJcXG4gICAgIGlua3NjYXBlOmN5PVxcXCI5MjIuMTkzNjRcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3cteD1cXFwiNFxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy15PVxcXCI0NlxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPVxcXCJzdmcyXFxcIiAvPlxcbiAgPGdcXG4gICAgIGlkPVxcXCJnNDIxMFxcXCJcXG4gICAgIHRyYW5zZm9ybT1cXFwibWF0cml4KDAuOTM4MDE0NTMsMCwwLDAuODcyNTg1NDIsNTUuNTM4OTgxLDExNC4xNjM0NilcXFwiPlxcbiAgICA8cGF0aFxcbiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9XFxcInNzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3NzXFxcIlxcbiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPVxcXCIwXFxcIlxcbiAgICAgICBzdHlsZT1cXFwiZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxXFxcIlxcbiAgICAgICBpZD1cXFwicGF0aDRcXFwiXFxuICAgICAgIGQ9XFxcIm0gMTUyMS40OTk0LDE1MTYuNDEyOSAtMy44MzQyLC0xMjQ1Ljc5NDI5IGMgLTAuMDI3LC04LjY2NjYzIC0zLjE2NjcsLTE2LjE2NjY3IC05LjUsLTIyLjUgLTYuMzMzMywtNi4zMzMzMyAtMTMuODMzNCwtOS40NzYxOCAtMjIuNSwtOS41IGwgLTgwMi45MjE0MiwtMi4yMDcwOCBjIC04LjY2NjYzLC0wLjAyMzggLTE4LjA1OTU3LDEuNzI3NTMgLTI0LjM5MjksOC4wNjA4NiAtNi4zMzMzMyw2LjMzMzMzIC03LjU4MDc2LDQuMjAwMTMgLTcuNjA3MSwyMy45MzkxNCBsIC0xLjY2NiwxMjQ4Ljc3NTg3IGMgLTAuMDExNiw4LjY2NjggMy4xNjY2NywxNi4xNjY3IDkuNSwyMi41IDYuMzMzMzMsNi4zMzMzIDEzLjgzMzMyLDkuNTA4MyAyMi41LDkuNSBsIDgwOC40MjE2MiwtMC43NzQ1IGMgOC42NjY2LC0wLjAxIDE2LjE2NjcsLTMuMTY2NyAyMi41LC05LjUgNi4zMzMzLC02LjMzMzMgOS41MjY3LC0xMy44MzM0IDkuNSwtMjIuNSB6IE0gMTY2NCw0MTYgbCAwLDk2MCBjIDAsNzkuMzMzMyAtMjguMTY2NywxNDcuMTY2NyAtODQuNSwyMDMuNSAtNTYuMzMzMyw1Ni4zMzMzIC0xMjQuMTY2Nyw4NC41IC0yMDMuNSw4NC41IGwgLTk2MCwwIGMgLTc5LjMzMzMzLDAgLTE0Ny4xNjY2NywtMjguMTY2NyAtMjAzLjUsLTg0LjUgQyAxNTYuMTY2NjcsMTUyMy4xNjY3IDEyOCwxNDU1LjMzMzMgMTI4LDEzNzYgbCAwLC05NjAgQyAxMjgsMzM2LjY2NjY3IDE1Ni4xNjY2NywyNjguODMzMzMgMjEyLjUsMjEyLjUgMjY4LjgzMzMzLDE1Ni4xNjY2NyAzMzYuNjY2NjcsMTI4IDQxNiwxMjggbCA5NjAsMCBjIDc5LjMzMzMsMCAxNDcuMTY2NywyOC4xNjY2NyAyMDMuNSw4NC41IDU2LjMzMzMsNTYuMzMzMzMgODQuNSwxMjQuMTY2NjcgODQuNSwyMDMuNSB6XFxcIiAvPlxcbiAgPC9nPlxcbjwvc3ZnPlxcblwiLFxuICAgIFwiY2FyZXQtc3F1YXJlLW8tcmlnaHRcIjogXCI8P3htbCB2ZXJzaW9uPVxcXCIxLjBcXFwiIGVuY29kaW5nPVxcXCJVVEYtOFxcXCIgc3RhbmRhbG9uZT1cXFwibm9cXFwiPz5cXG48c3ZnXFxuICAgeG1sbnM6ZGM9XFxcImh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvXFxcIlxcbiAgIHhtbG5zOmNjPVxcXCJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyNcXFwiXFxuICAgeG1sbnM6cmRmPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjXFxcIlxcbiAgIHhtbG5zOnN2Zz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgIHhtbG5zOnNvZGlwb2RpPVxcXCJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZFxcXCJcXG4gICB4bWxuczppbmtzY2FwZT1cXFwiaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZVxcXCJcXG4gICB3aWR0aD1cXFwiMTc5MlxcXCJcXG4gICBoZWlnaHQ9XFxcIjE3OTJcXFwiXFxuICAgdmlld0JveD1cXFwiMCAwIDE3OTIgMTc5MlxcXCJcXG4gICBpZD1cXFwic3ZnMlxcXCJcXG4gICB2ZXJzaW9uPVxcXCIxLjFcXFwiXFxuICAgaW5rc2NhcGU6dmVyc2lvbj1cXFwiMC45MSByMTM3MjVcXFwiXFxuICAgc29kaXBvZGk6ZG9jbmFtZT1cXFwiY2FyZXQtc3F1YXJlLW8tcmlnaHQuc3ZnXFxcIj5cXG4gIDxtZXRhZGF0YVxcbiAgICAgaWQ9XFxcIm1ldGFkYXRhMTBcXFwiPlxcbiAgICA8cmRmOlJERj5cXG4gICAgICA8Y2M6V29ya1xcbiAgICAgICAgIHJkZjphYm91dD1cXFwiXFxcIj5cXG4gICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PlxcbiAgICAgICAgPGRjOnR5cGVcXG4gICAgICAgICAgIHJkZjpyZXNvdXJjZT1cXFwiaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2VcXFwiIC8+XFxuICAgICAgICA8ZGM6dGl0bGU+PC9kYzp0aXRsZT5cXG4gICAgICA8L2NjOldvcms+XFxuICAgIDwvcmRmOlJERj5cXG4gIDwvbWV0YWRhdGE+XFxuICA8ZGVmc1xcbiAgICAgaWQ9XFxcImRlZnM4XFxcIiAvPlxcbiAgPHNvZGlwb2RpOm5hbWVkdmlld1xcbiAgICAgcGFnZWNvbG9yPVxcXCIjZmZmZmZmXFxcIlxcbiAgICAgYm9yZGVyY29sb3I9XFxcIiM2NjY2NjZcXFwiXFxuICAgICBib3JkZXJvcGFjaXR5PVxcXCIxXFxcIlxcbiAgICAgb2JqZWN0dG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGdyaWR0b2xlcmFuY2U9XFxcIjEwXFxcIlxcbiAgICAgZ3VpZGV0b2xlcmFuY2U9XFxcIjEwXFxcIlxcbiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PVxcXCIyXFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPVxcXCIxNzg1XFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD1cXFwiMTA4MlxcXCJcXG4gICAgIGlkPVxcXCJuYW1lZHZpZXc2XFxcIlxcbiAgICAgc2hvd2dyaWQ9XFxcImZhbHNlXFxcIlxcbiAgICAgaW5rc2NhcGU6em9vbT1cXFwiMC4zNzgxMTI3OVxcXCJcXG4gICAgIGlua3NjYXBlOmN4PVxcXCIxMjExLjA4MzVcXFwiXFxuICAgICBpbmtzY2FwZTpjeT1cXFwiOTIyLjE5MzY0XFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LXg9XFxcIjRcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3cteT1cXFwiNDZcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj1cXFwic3ZnMlxcXCIgLz5cXG4gIDxnXFxuICAgICBpZD1cXFwiZzQyMTBcXFwiXFxuICAgICB0cmFuc2Zvcm09XFxcIm1hdHJpeCgtMC45MzgwMTQ1MywwLDAsLTAuODcyNTg1NDIsMTczNi40NjEsMTY3Ny44MzY1KVxcXCI+XFxuICAgIDxwYXRoXFxuICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz1cXFwic3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3NcXFwiXFxuICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9XFxcIjBcXFwiXFxuICAgICAgIHN0eWxlPVxcXCJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjFcXFwiXFxuICAgICAgIGlkPVxcXCJwYXRoNFxcXCJcXG4gICAgICAgZD1cXFwibSAxNTIxLjQ5OTQsMTUxNi40MTI5IC0zLjgzNDIsLTEyNDUuNzk0MjkgYyAtMC4wMjcsLTguNjY2NjMgLTMuMTY2NywtMTYuMTY2NjcgLTkuNSwtMjIuNSAtNi4zMzMzLC02LjMzMzMzIC0xMy44MzM0LC05LjQ3NjE4IC0yMi41LC05LjUgbCAtODAyLjkyMTQyLC0yLjIwNzA4IGMgLTguNjY2NjMsLTAuMDIzOCAtMTguMDU5NTcsMS43Mjc1MyAtMjQuMzkyOSw4LjA2MDg2IC02LjMzMzMzLDYuMzMzMzMgLTcuNTgwNzYsNC4yMDAxMyAtNy42MDcxLDIzLjkzOTE0IGwgLTEuNjY2LDEyNDguNzc1ODcgYyAtMC4wMTE2LDguNjY2OCAzLjE2NjY3LDE2LjE2NjcgOS41LDIyLjUgNi4zMzMzMyw2LjMzMzMgMTMuODMzMzIsOS41MDgzIDIyLjUsOS41IGwgODA4LjQyMTYyLC0wLjc3NDUgYyA4LjY2NjYsLTAuMDEgMTYuMTY2NywtMy4xNjY3IDIyLjUsLTkuNSA2LjMzMzMsLTYuMzMzMyA5LjUyNjcsLTEzLjgzMzQgOS41LC0yMi41IHogTSAxNjY0LDQxNiBsIDAsOTYwIGMgMCw3OS4zMzMzIC0yOC4xNjY3LDE0Ny4xNjY3IC04NC41LDIwMy41IC01Ni4zMzMzLDU2LjMzMzMgLTEyNC4xNjY3LDg0LjUgLTIwMy41LDg0LjUgbCAtOTYwLDAgYyAtNzkuMzMzMzMsMCAtMTQ3LjE2NjY3LC0yOC4xNjY3IC0yMDMuNSwtODQuNSBDIDE1Ni4xNjY2NywxNTIzLjE2NjcgMTI4LDE0NTUuMzMzMyAxMjgsMTM3NiBsIDAsLTk2MCBDIDEyOCwzMzYuNjY2NjcgMTU2LjE2NjY3LDI2OC44MzMzMyAyMTIuNSwyMTIuNSAyNjguODMzMzMsMTU2LjE2NjY3IDMzNi42NjY2NywxMjggNDE2LDEyOCBsIDk2MCwwIGMgNzkuMzMzMywwIDE0Ny4xNjY3LDI4LjE2NjY3IDIwMy41LDg0LjUgNTYuMzMzMyw1Ni4zMzMzMyA4NC41LDEyNC4xNjY2NyA4NC41LDIwMy41IHpcXFwiIC8+XFxuICA8L2c+XFxuPC9zdmc+XFxuXCIsXG4gICAgXCJjaGF0XCI6IFwiPD94bWwgdmVyc2lvbj1cXFwiMS4wXFxcIiBlbmNvZGluZz1cXFwiVVRGLThcXFwiIHN0YW5kYWxvbmU9XFxcIm5vXFxcIj8+XFxuPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPlxcblxcbjxzdmdcXG4gICB4bWxuczpkYz1cXFwiaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS9cXFwiXFxuICAgeG1sbnM6Y2M9XFxcImh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zI1xcXCJcXG4gICB4bWxuczpyZGY9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyNcXFwiXFxuICAgeG1sbnM6c3ZnPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgeG1sbnM6c29kaXBvZGk9XFxcImh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkXFxcIlxcbiAgIHhtbG5zOmlua3NjYXBlPVxcXCJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlXFxcIlxcbiAgIHZlcnNpb249XFxcIjEuMVxcXCJcXG4gICBpZD1cXFwiQ2FwYV8xXFxcIlxcbiAgIHg9XFxcIjBweFxcXCJcXG4gICB5PVxcXCIwcHhcXFwiXFxuICAgd2lkdGg9XFxcIjUxMS42MjZweFxcXCJcXG4gICBoZWlnaHQ9XFxcIjUxMS42MjZweFxcXCJcXG4gICB2aWV3Qm94PVxcXCIwIDAgNTExLjYyNiA1MTEuNjI2XFxcIlxcbiAgIHN0eWxlPVxcXCJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDUxMS42MjYgNTExLjYyNjtcXFwiXFxuICAgeG1sOnNwYWNlPVxcXCJwcmVzZXJ2ZVxcXCJcXG4gICBpbmtzY2FwZTp2ZXJzaW9uPVxcXCIwLjkxIHIxMzcyNVxcXCJcXG4gICBzb2RpcG9kaTpkb2NuYW1lPVxcXCJjaGF0LnN2Z1xcXCI+PG1ldGFkYXRhXFxuICAgICBpZD1cXFwibWV0YWRhdGE0NVxcXCI+PHJkZjpSREY+PGNjOldvcmtcXG4gICAgICAgICByZGY6YWJvdXQ9XFxcIlxcXCI+PGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+PGRjOnR5cGVcXG4gICAgICAgICAgIHJkZjpyZXNvdXJjZT1cXFwiaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2VcXFwiIC8+PC9jYzpXb3JrPjwvcmRmOlJERj48L21ldGFkYXRhPjxkZWZzXFxuICAgICBpZD1cXFwiZGVmczQzXFxcIiAvPjxzb2RpcG9kaTpuYW1lZHZpZXdcXG4gICAgIHBhZ2Vjb2xvcj1cXFwiI2ZmZmZmZlxcXCJcXG4gICAgIGJvcmRlcmNvbG9yPVxcXCIjNjY2NjY2XFxcIlxcbiAgICAgYm9yZGVyb3BhY2l0eT1cXFwiMVxcXCJcXG4gICAgIG9iamVjdHRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBncmlkdG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGd1aWRldG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz1cXFwiMlxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD1cXFwiMTMxNVxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9XFxcIjg1MlxcXCJcXG4gICAgIGlkPVxcXCJuYW1lZHZpZXc0MVxcXCJcXG4gICAgIHNob3dncmlkPVxcXCJmYWxzZVxcXCJcXG4gICAgIGlua3NjYXBlOnpvb209XFxcIjAuNDYxMjc0NDRcXFwiXFxuICAgICBpbmtzY2FwZTpjeD1cXFwiMjU1LjgxM1xcXCJcXG4gICAgIGlua3NjYXBlOmN5PVxcXCIyNTUuODEzXFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LXg9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3cteT1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPVxcXCJDYXBhXzFcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnM1xcXCJcXG4gICAgIHN0eWxlPVxcXCJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjFcXFwiPjxnXFxuICAgICAgIGlkPVxcXCJnNVxcXCJcXG4gICAgICAgc3R5bGU9XFxcImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MVxcXCI+PHBhdGhcXG4gICAgICAgICBkPVxcXCJNMzAxLjkyNywzMjcuNjA1YzMwLjkyNi0xMy4wMzgsNTUuMzQtMzAuNzg1LDczLjIzLTUzLjI0OGMxNy44ODgtMjIuNDU4LDI2LjgzMy00Ni45MTUsMjYuODMzLTczLjM3MiAgICBjMC0yNi40NTgtOC45NDUtNTAuOTE3LTI2Ljg0LTczLjM3NmMtMTcuODg4LTIyLjQ1OS00Mi4yOTgtNDAuMjA4LTczLjIyOC01My4yNDljLTMwLjkzLTEzLjAzOS02NC41NzEtMTkuNTU2LTEwMC45MjgtMTkuNTU2ICAgIGMtMzYuMzU0LDAtNjkuOTk1LDYuNTIxLTEwMC45MjcsMTkuNTU2Yy0zMC45MjksMTMuMDQtNTUuMzQsMzAuNzg5LTczLjIyOSw1My4yNDlDOC45NDcsMTUwLjA3MiwwLDE3NC41MjcsMCwyMDAuOTg2ICAgIGMwLDIyLjY0OCw2Ljc2Nyw0My45NzUsMjAuMjgsNjMuOTZjMTMuNTEyLDE5Ljk4MSwzMi4wNzEsMzYuODI5LDU1LjY3MSw1MC41MzFjLTEuOTAyLDQuNTcyLTMuODUzLDguNzU0LTUuODUyLDEyLjU2NiAgICBjLTIsMy44MDYtNC4zNzcsNy40NjctNy4xMzksMTAuOTkxYy0yLjc2LDMuNTI1LTQuODk5LDYuMjgzLTYuNDIzLDguMjc1Yy0xLjUyMywxLjk5OC0zLjk5Nyw0LjgxMi03LjQyNSw4LjQyMiAgICBjLTMuNDI3LDMuNjE3LTUuNjE3LDUuOTk2LTYuNTY3LDcuMTM1YzAtMC4xOTEtMC4zODEsMC4yNC0xLjE0MywxLjI4N2MtMC43NjMsMS4wNDctMS4xOTEsMS41Mi0xLjI4NSwxLjQzMSAgICBjLTAuMDk2LTAuMTAzLTAuNDc3LDAuMzczLTEuMTQzLDEuNDJjLTAuNjY2LDEuMDQ4LTEsMS41NzEtMSwxLjU3MWwtMC43MTUsMS40MjNjLTAuMjgyLDAuNTc1LTAuNDc2LDEuMTM3LTAuNTcsMS43MTIgICAgYy0wLjA5NiwwLjU2Ny0wLjE0NCwxLjE5LTAuMTQ0LDEuODU0czAuMDk0LDEuMjgsMC4yODgsMS44NTRjMC4zODEsMi40NzEsMS40NzUsNC40NjYsMy4yODMsNS45OTYgICAgYzEuODA3LDEuNTIsMy43NTYsMi4yNzksNS44NTIsMi4yNzloMC44NTdjOS41MTUtMS4zMzIsMTcuNzAxLTIuODU0LDI0LjU1Mi00LjU2OWMyOS4zMTItNy42MSw1NS43NzEtMTkuNzk3LDc5LjM3Mi0zNi41NDUgICAgYzE3LjEyOSwzLjA0NiwzMy44NzksNC41NjgsNTAuMjQ3LDQuNTY4QzIzNy4zNTMsMzQ3LjE2LDI3MC45OTgsMzQwLjY0NSwzMDEuOTI3LDMyNy42MDV6XFxcIlxcbiAgICAgICAgIGlkPVxcXCJwYXRoN1xcXCJcXG4gICAgICAgICBzdHlsZT1cXFwiZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxXFxcIiAvPjxwYXRoXFxuICAgICAgICAgZD1cXFwiTTQ5MS4zNTQsMzM4LjE2NmMxMy41MTgtMTkuODg5LDIwLjI3Mi00MS4yNDcsMjAuMjcyLTY0LjA5YzAtMjMuNDE0LTcuMTQ2LTQ1LjMxNi0yMS40MTYtNjUuNjggICAgYy0xNC4yNzctMjAuMzYyLTMzLjY5NC0zNy4zMDUtNTguMjQ1LTUwLjgxOWM0LjM3NCwxNC4yNzQsNi41NjMsMjguNzM5LDYuNTYzLDQzLjM5OGMwLDI1LjUwMy02LjM2OCw0OS42NzYtMTkuMTI5LDcyLjUxOSAgICBjLTEyLjc1MiwyMi44MzYtMzEuMDI1LDQzLjAxLTU0LjgxNiw2MC41MjRjLTIyLjA4LDE1Ljk4OC00Ny4yMDUsMjguMjYxLTc1LjM3NywzNi44MjkgICAgYy0yOC4xNjQsOC41NjItNTcuNTczLDEyLjg0OC04OC4yMTgsMTIuODQ4Yy01LjcwOCwwLTE0LjA4NC0wLjM3Ny0yNS4xMjItMS4xMzdjMzguMjU2LDI1LjExOSw4My4xNzcsMzcuNjg1LDEzNC43NTYsMzcuNjg1ICAgIGMxNi4zNzEsMCwzMy4xMTktMS41MjYsNTAuMjUxLTQuNTcxYzIzLjYsMTYuNzU1LDUwLjA2LDI4LjkzMSw3OS4zNywzNi41NDljNi44NTIsMS43MTgsMTUuMDM3LDMuMjM3LDI0LjU1NCw0LjU2OCAgICBjMi4yODMsMC4xOTEsNC4zODEtMC40NzYsNi4yODMtMS45OTljMS45MDMtMS41MjIsMy4xNDItMy42MSwzLjcxLTYuMjcyYy0wLjA4OS0xLjE0MywwLTEuNzcsMC4yODctMS44NjEgICAgYzAuMjgxLTAuMDksMC4yMzMtMC43MTItMC4xNDQtMS44NTJjLTAuMzc2LTEuMTQ0LTAuNTY4LTEuNzE1LTAuNTY4LTEuNzE1bC0wLjcxMi0xLjQyNGMtMC4xOTgtMC4zNzYtMC41Mi0wLjkwMy0wLjk5OS0xLjU2NyAgICBjLTAuNDc2LTAuNjYtMC44NTUtMS4xNDMtMS4xNDMtMS40MjdjLTAuMjgtMC4yODQtMC43MDUtMC43NjMtMS4yOC0xLjQyNGMtMC41NjgtMC42Ni0wLjk1MS0xLjA5Mi0xLjE0My0xLjI4MyAgICBjLTAuOTUxLTEuMTQzLTMuMTM5LTMuNTIxLTYuNTY0LTcuMTM5Yy0zLjQyOS0zLjYxMy01Ljg5OS02LjQyLTcuNDIyLTguNDE4Yy0xLjUyMy0xLjk5OS0zLjY2NS00Ljc1Ny02LjQyNC04LjI4MiAgICBjLTIuNzU4LTMuNTE4LTUuMTQtNy4xODMtNy4xMzktMTAuOTkxYy0xLjk5OC0zLjgwNi0zLjk0OS03Ljk5NS01Ljg1Mi0xMi41NkM0NTkuMjg5LDM3NC44NTksNDc3Ljg0MywzNTguMDYyLDQ5MS4zNTQsMzM4LjE2NnpcXFwiXFxuICAgICAgICAgaWQ9XFxcInBhdGg5XFxcIlxcbiAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjFcXFwiIC8+PC9nPjwvZz48Z1xcbiAgICAgaWQ9XFxcImcxMVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcxM1xcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcxNVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcxN1xcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcxOVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcyMVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcyM1xcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcyNVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcyN1xcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcyOVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImczMVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImczM1xcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImczNVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImczN1xcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImczOVxcXCIgLz48L3N2Zz5cIixcbiAgICBcImRvd25sb2FkXCI6IFwiPD94bWwgdmVyc2lvbj1cXFwiMS4wXFxcIiBlbmNvZGluZz1cXFwiVVRGLThcXFwiIHN0YW5kYWxvbmU9XFxcIm5vXFxcIj8+XFxuPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPlxcblxcbjxzdmdcXG4gICB4bWxuczpkYz1cXFwiaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS9cXFwiXFxuICAgeG1sbnM6Y2M9XFxcImh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zI1xcXCJcXG4gICB4bWxuczpyZGY9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyNcXFwiXFxuICAgeG1sbnM6c3ZnPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgeG1sbnM6c29kaXBvZGk9XFxcImh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkXFxcIlxcbiAgIHhtbG5zOmlua3NjYXBlPVxcXCJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlXFxcIlxcbiAgIHZlcnNpb249XFxcIjEuMVxcXCJcXG4gICBpZD1cXFwiQ2FwYV8xXFxcIlxcbiAgIHg9XFxcIjBweFxcXCJcXG4gICB5PVxcXCIwcHhcXFwiXFxuICAgd2lkdGg9XFxcIjQzOC41MzNweFxcXCJcXG4gICBoZWlnaHQ9XFxcIjQzOC41MzNweFxcXCJcXG4gICB2aWV3Qm94PVxcXCIwIDAgNDM4LjUzMyA0MzguNTMzXFxcIlxcbiAgIHN0eWxlPVxcXCJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDQzOC41MzMgNDM4LjUzMztcXFwiXFxuICAgeG1sOnNwYWNlPVxcXCJwcmVzZXJ2ZVxcXCJcXG4gICBpbmtzY2FwZTp2ZXJzaW9uPVxcXCIwLjkxIHIxMzcyNVxcXCJcXG4gICBzb2RpcG9kaTpkb2NuYW1lPVxcXCJkb3dubG9hZC5zdmdcXFwiPjxtZXRhZGF0YVxcbiAgICAgaWQ9XFxcIm1ldGFkYXRhNDVcXFwiPjxyZGY6UkRGPjxjYzpXb3JrXFxuICAgICAgICAgcmRmOmFib3V0PVxcXCJcXFwiPjxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PjxkYzp0eXBlXFxuICAgICAgICAgICByZGY6cmVzb3VyY2U9XFxcImh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlXFxcIiAvPjxkYzp0aXRsZSAvPjwvY2M6V29yaz48L3JkZjpSREY+PC9tZXRhZGF0YT48ZGVmc1xcbiAgICAgaWQ9XFxcImRlZnM0M1xcXCIgLz48c29kaXBvZGk6bmFtZWR2aWV3XFxuICAgICBwYWdlY29sb3I9XFxcIiNmZmZmZmZcXFwiXFxuICAgICBib3JkZXJjb2xvcj1cXFwiIzY2NjY2NlxcXCJcXG4gICAgIGJvcmRlcm9wYWNpdHk9XFxcIjFcXFwiXFxuICAgICBvYmplY3R0b2xlcmFuY2U9XFxcIjEwXFxcIlxcbiAgICAgZ3JpZHRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBndWlkZXRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9XFxcIjJcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9XFxcIjE1MjBcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PVxcXCI5MzFcXFwiXFxuICAgICBpZD1cXFwibmFtZWR2aWV3NDFcXFwiXFxuICAgICBzaG93Z3JpZD1cXFwiZmFsc2VcXFwiXFxuICAgICBpbmtzY2FwZTp6b29tPVxcXCIwLjM4MDUzNTExXFxcIlxcbiAgICAgaW5rc2NhcGU6Y3g9XFxcIjE5LjE0MzY1MVxcXCJcXG4gICAgIGlua3NjYXBlOmN5PVxcXCItMjAxLjE5NDA1XFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LXg9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3cteT1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPVxcXCJDYXBhXzFcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMTFcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMTNcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMTVcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMTdcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMTlcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMjFcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMjNcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMjVcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMjdcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMjlcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMzFcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMzNcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMzVcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMzdcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMzlcXFwiIC8+PHBhdGhcXG4gICAgIGQ9XFxcIm0gMzEyLjI0MzUzLDE0OC41MTQyIC01NS43MTQ3NiwwIDAsLTEwNS42MTQzNDEgYyAwLC0yLjgwMTU1IC0wLjg3NjE3LC01LjA5OTc2IC0yLjYxNTMzLC02LjkwMDkxIC0xLjczMjAyLC0xLjc5NTkgLTMuOTU5MDgsLTIuNjk4NTggLTYuNjY0ODYsLTIuNjk4NTggbCAtNTUuNzI0OSwwIGMgLTIuNzA3ODMsMCAtNC45MzM4NSwwLjkwMjY4IC02LjY3NTA0LDIuNjk4NTggLTEuNzQyMTksMS44MDIyIC0yLjYxMjI3LDQuMDk5MzYgLTIuNjEyMjcsNi45MDA5MSBsIDAsMTA1LjYxMDE0MSAtNTUuNzIwODQsMCBjIC00LjI1NDg3LDAgLTcuMTU3ODQsMi4wMDE4NiAtOC43MDY5Miw1Ljk5OTI4IC0xLjU0OTA3LDMuODA1MTIgLTAuODY4MDUsNy4zMDAyNCAyLjAzMTg4LDEwLjUwNDI3IEwgMjEyLjcwNjUzLDI2MS4wMiBjIDIuMTMwNDYsMS43OTggNC4zNTM0NSwyLjY5NzUzIDYuNjc1MDIsMi42OTc1MyAyLjMxODU0LDAgNC41NDQ1NiwtMC44OTk1MyA2LjY3NzA2LC0yLjY5NzUzIGwgOTIuNTc1MzQsLTk1LjcwMzgxIGMgMS45MzMyOSwtMi4zOTkwOCAyLjg5NzksLTQuODA4NjcgMi44OTc5LC03LjIwMDQgMCwtMi43OTczNiAtMC44NjkwNywtNS4wOTk3NiAtMi42MTUzNCwtNi45MDQwNyAtMS43MzcxMSwtMS43OTkwNSAtMy45NjMxMywtMi42OTc1MiAtNi42NzI5OCwtMi42OTc1MiB6XFxcIlxcbiAgICAgaWQ9XFxcInBhdGg5XFxcIlxcbiAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT1cXFwiMFxcXCJcXG4gICAgIHN0eWxlPVxcXCJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjFcXFwiIC8+PHBhdGhcXG4gICAgIHN0eWxlPVxcXCJvcGFjaXR5OjE7ZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDozNTtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6My4yNzU5MDAxMztzdHJva2Utb3BhY2l0eToxXFxcIlxcbiAgICAgZD1cXFwibSAzNi4yMzUyNSwzMDUuODE0NDUgMCw5OC40ODQzOCAzNjYuMDYyNSwwIDAsLTk4LjQ4NDM4IC00Mi43MzgyOCwwIDAsNTUuNzQ2MSAtMjgwLjU4NTk0LDAgMCwtNTUuNzQ2MSB6XFxcIlxcbiAgICAgaWQ9XFxcInJlY3Q0MTUwXFxcIlxcbiAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT1cXFwiMFxcXCJcXG4gICAgIHNvZGlwb2RpOm5vZGV0eXBlcz1cXFwiY2NjY2NjY2NjXFxcIiAvPjwvc3ZnPlwiLFxuICAgIFwiZXJhc2VcIjogXCI8P3htbCB2ZXJzaW9uPVxcXCIxLjBcXFwiIGVuY29kaW5nPVxcXCJVVEYtOFxcXCIgc3RhbmRhbG9uZT1cXFwibm9cXFwiPz5cXG48c3ZnXFxuICAgeG1sbnM6ZGM9XFxcImh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvXFxcIlxcbiAgIHhtbG5zOmNjPVxcXCJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyNcXFwiXFxuICAgeG1sbnM6cmRmPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjXFxcIlxcbiAgIHhtbG5zOnN2Zz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgIHhtbG5zOnNvZGlwb2RpPVxcXCJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZFxcXCJcXG4gICB4bWxuczppbmtzY2FwZT1cXFwiaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZVxcXCJcXG4gICBpZD1cXFwic3ZnMlxcXCJcXG4gICB2ZXJzaW9uPVxcXCIxLjFcXFwiXFxuICAgaW5rc2NhcGU6dmVyc2lvbj1cXFwiMC45MSByMTM3MjVcXFwiXFxuICAgc29kaXBvZGk6ZG9jbmFtZT1cXFwiZmEtZXJhc2Uuc3ZnXFxcIlxcbiAgIHdpZHRoPVxcXCIxOTE5Ljk1MTJcXFwiXFxuICAgaGVpZ2h0PVxcXCIxOTE5Ljk1MTJcXFwiPlxcbiAgPG1ldGFkYXRhXFxuICAgICBpZD1cXFwibWV0YWRhdGExMFxcXCI+XFxuICAgIDxyZGY6UkRGPlxcbiAgICAgIDxjYzpXb3JrXFxuICAgICAgICAgcmRmOmFib3V0PVxcXCJcXFwiPlxcbiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+XFxuICAgICAgICA8ZGM6dHlwZVxcbiAgICAgICAgICAgcmRmOnJlc291cmNlPVxcXCJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZVxcXCIgLz5cXG4gICAgICAgIDxkYzp0aXRsZT48L2RjOnRpdGxlPlxcbiAgICAgIDwvY2M6V29yaz5cXG4gICAgPC9yZGY6UkRGPlxcbiAgPC9tZXRhZGF0YT5cXG4gIDxkZWZzXFxuICAgICBpZD1cXFwiZGVmczhcXFwiIC8+XFxuICA8c29kaXBvZGk6bmFtZWR2aWV3XFxuICAgICBwYWdlY29sb3I9XFxcIiNmZmZmZmZcXFwiXFxuICAgICBib3JkZXJjb2xvcj1cXFwiIzY2NjY2NlxcXCJcXG4gICAgIGJvcmRlcm9wYWNpdHk9XFxcIjFcXFwiXFxuICAgICBvYmplY3R0b2xlcmFuY2U9XFxcIjEwXFxcIlxcbiAgICAgZ3JpZHRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBndWlkZXRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9XFxcIjJcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9XFxcIjE1MTNcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PVxcXCI4MTBcXFwiXFxuICAgICBpZD1cXFwibmFtZWR2aWV3NlxcXCJcXG4gICAgIHNob3dncmlkPVxcXCJmYWxzZVxcXCJcXG4gICAgIGZpdC1tYXJnaW4tdG9wPVxcXCIwXFxcIlxcbiAgICAgZml0LW1hcmdpbi1sZWZ0PVxcXCIwXFxcIlxcbiAgICAgZml0LW1hcmdpbi1yaWdodD1cXFwiMFxcXCJcXG4gICAgIGZpdC1tYXJnaW4tYm90dG9tPVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6em9vbT1cXFwiMC4xMDQyOTgyNVxcXCJcXG4gICAgIGlua3NjYXBlOmN4PVxcXCI0OS45NzU2MVxcXCJcXG4gICAgIGlua3NjYXBlOmN5PVxcXCIxMjMwXFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LXg9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3cteT1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPVxcXCJzdmcyXFxcIiAvPlxcbiAgPHBhdGhcXG4gICAgIGQ9XFxcIm0gODk1Ljk3NTU5LDE0NzEuOTc1NiAzMzYuMDAwMDEsLTM4NCAtNzY4LjAwMDAxLDAgLTMzNiwzODQgNzY4LDAgeiBNIDE5MDguOTc1NiwzOTQuOTc1NTcgcSAxNSwzNCA5LjUsNzEuNSAtNS41LDM3LjUgLTMwLjUsNjUuNSBMIDk5MS45NzU1OSwxNTU1Ljk3NTYgcSAtMzgsNDQgLTk2LDQ0IGwgLTc2OCwwIHEgLTM3Ljk5OTk5OSwwIC02OS40OTk5OTksLTIwLjUgLTMxLjUsLTIwLjUgLTQ3LjUsLTU0LjUgLTE1LjAwMDAwMDIsLTM0IC05LjUwMDAwMDIsLTcxLjUgNS41LC0zNy41IDMwLjUwMDAwMDIsLTY1LjUgTCA5MjcuOTc1NTksMzYzLjk3NTU3IHEgMzgsLTQ0IDk2LjAwMDAxLC00NCBsIDc2OCwwIHEgMzgsMCA2OS41LDIwLjUgMzEuNSwyMC41IDQ3LjUsNTQuNSB6XFxcIlxcbiAgICAgaWQ9XFxcInBhdGg0XFxcIlxcbiAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT1cXFwiMFxcXCJcXG4gICAgIHN0eWxlPVxcXCJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjFcXFwiIC8+XFxuPC9zdmc+XFxuXCIsXG4gICAgXCJleWVkcm9wcGVyXCI6IFwiPD94bWwgdmVyc2lvbj1cXFwiMS4wXFxcIiBlbmNvZGluZz1cXFwiVVRGLThcXFwiIHN0YW5kYWxvbmU9XFxcIm5vXFxcIj8+XFxuPHN2Z1xcbiAgIHhtbG5zOmRjPVxcXCJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xL1xcXCJcXG4gICB4bWxuczpjYz1cXFwiaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjXFxcIlxcbiAgIHhtbG5zOnJkZj1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zI1xcXCJcXG4gICB4bWxuczpzdmc9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICB4bWxuczpzb2RpcG9kaT1cXFwiaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGRcXFwiXFxuICAgeG1sbnM6aW5rc2NhcGU9XFxcImh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGVcXFwiXFxuICAgaWQ9XFxcInN2ZzJcXFwiXFxuICAgdmVyc2lvbj1cXFwiMS4xXFxcIlxcbiAgIGlua3NjYXBlOnZlcnNpb249XFxcIjAuOTEgcjEzNzI1XFxcIlxcbiAgIHNvZGlwb2RpOmRvY25hbWU9XFxcImV5ZWRyb3BwZXIuc3ZnXFxcIlxcbiAgIHdpZHRoPVxcXCIxNTM2XFxcIlxcbiAgIGhlaWdodD1cXFwiMTUzNlxcXCI+XFxuICA8bWV0YWRhdGFcXG4gICAgIGlkPVxcXCJtZXRhZGF0YTEwXFxcIj5cXG4gICAgPHJkZjpSREY+XFxuICAgICAgPGNjOldvcmtcXG4gICAgICAgICByZGY6YWJvdXQ9XFxcIlxcXCI+XFxuICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD5cXG4gICAgICAgIDxkYzp0eXBlXFxuICAgICAgICAgICByZGY6cmVzb3VyY2U9XFxcImh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlXFxcIiAvPlxcbiAgICAgICAgPGRjOnRpdGxlPjwvZGM6dGl0bGU+XFxuICAgICAgPC9jYzpXb3JrPlxcbiAgICA8L3JkZjpSREY+XFxuICA8L21ldGFkYXRhPlxcbiAgPGRlZnNcXG4gICAgIGlkPVxcXCJkZWZzOFxcXCIgLz5cXG4gIDxzb2RpcG9kaTpuYW1lZHZpZXdcXG4gICAgIHBhZ2Vjb2xvcj1cXFwiI2ZmZmZmZlxcXCJcXG4gICAgIGJvcmRlcmNvbG9yPVxcXCIjNjY2NjY2XFxcIlxcbiAgICAgYm9yZGVyb3BhY2l0eT1cXFwiMVxcXCJcXG4gICAgIG9iamVjdHRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBncmlkdG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGd1aWRldG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz1cXFwiMlxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD1cXFwiMTM4N1xcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9XFxcIjEwMTdcXFwiXFxuICAgICBpZD1cXFwibmFtZWR2aWV3NlxcXCJcXG4gICAgIHNob3dncmlkPVxcXCJmYWxzZVxcXCJcXG4gICAgIGZpdC1tYXJnaW4tdG9wPVxcXCIwXFxcIlxcbiAgICAgZml0LW1hcmdpbi1sZWZ0PVxcXCIwXFxcIlxcbiAgICAgZml0LW1hcmdpbi1yaWdodD1cXFwiMFxcXCJcXG4gICAgIGZpdC1tYXJnaW4tYm90dG9tPVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6em9vbT1cXFwiMC4zMlxcXCJcXG4gICAgIGlua3NjYXBlOmN4PVxcXCI2MDIuMTk2ODdcXFwiXFxuICAgICBpbmtzY2FwZTpjeT1cXFwiNzE0LjQ4MzM3XFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LXg9XFxcIjI2MlxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy15PVxcXCI5NFxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPVxcXCJzdmcyXFxcIiAvPlxcbiAgPHBhdGhcXG4gICAgIHN0eWxlPVxcXCJmaWxsOiNmZmZmZmZcXFwiXFxuICAgICBkPVxcXCJtIC00ODIuNzE3ODYsMTI2NC43OTY0IGMgNDcuMzA5NzMsMTI0Ljg4NjkgMTEyLjQ0ODkzLDEwNy40NzI5IDExMi42ODQ1NSwxODAuNjIgMC4xNDIyOCw0NC4xNzcyIC00OS45Njc4LDgwLjA1NDQgLTExMS44NDIwNSw4MC4xNTYgLTYxLjg3MTc2LDAuMTAxNiAtMTEyLjIwOTkyLC0zNS42MTI1IC0xMTIuMzUyMjMsLTc5Ljc4OTcgLTAuMjU0MzcsLTc4Ljk2NTIgNjQuMTg1MTgsLTUzLjcxODggMTExLjUxNDczLC0xODAuOTg4MSB6XFxcIlxcbiAgICAgaWQ9XFxcInBhdGg2XFxcIlxcbiAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT1cXFwiMFxcXCIgLz5cXG4gIDxnXFxuICAgICBpZD1cXFwiZzQzNDVcXFwiXFxuICAgICB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSg5LjU5MDQ1MjUsMjguMjQxNTg0KVxcXCI+XFxuICAgIDxlbGxpcHNlXFxuICAgICAgIHRyYW5zZm9ybT1cXFwibWF0cml4KDAuNjk2NzY3MTYsMC43MTcyOTczOCwtMC43MDg2NDM5LDAuNzA1NTY2MzEsMCwwKVxcXCJcXG4gICAgICAgcnk9XFxcIjI5OC44MjI1MVxcXCJcXG4gICAgICAgcng9XFxcIjIyMC4zNzUzNVxcXCJcXG4gICAgICAgY3k9XFxcIi02ODYuMTIyOTJcXFwiXFxuICAgICAgIGN4PVxcXCIxMDc2LjgwMzJcXFwiXFxuICAgICAgIGlkPVxcXCJwYXRoNDIyMVxcXCJcXG4gICAgICAgc3R5bGU9XFxcIm9wYWNpdHk6MTtmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjkwLjc0ODAwMTE7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1kYXNob2Zmc2V0OjMuMjc1OTAwMTM7c3Ryb2tlLW9wYWNpdHk6MVxcXCIgLz5cXG4gICAgPHBhdGhcXG4gICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT1cXFwiMFxcXCJcXG4gICAgICAgaWQ9XFxcInJlY3Q0MjQyXFxcIlxcbiAgICAgICBkPVxcXCJtIDg4Ni44NTE2LDE1OC42NjQwNiBjIC0wLjY4ODYsLTAuMDA1IC0xLjM4MDUsMC4yNTM4MiAtMS45MTIxLDAuNzc3MzUgTCA3NzIuMzk4NDQsMjcwLjI1NTg2IGMgLTEuMDYzMzYsMS4wNDcwNSAtMS4wNzYzNSwyLjc0NzE5IC0wLjAyOTMsMy44MTA1NSBsIDQwNC4xNzc3Niw0MTAuNDcyNjUgYyAwLjQ5NzYsMC41MDU0MiAxLjE0MjksMC43NjcwNSAxLjc5NjksMC43OTY4OCBsIDY0LjIwMzEsNjUuMjAzMTIgYyAxLjA0NywxLjA2MzM2IDIuNzQ3MiwxLjA3NjM1IDMuODEwNSwwLjAyOTMgbCAxMTIuNTQxLC0xMTAuODE0NDUgYyAxLjA2MzQsLTEuMDQ3MDUgMS4wNzY0LC0yLjc0NTI0IDAuMDI5LC0zLjgwODYgTCA5NTQuNzUsMjI1LjQ3MDcgYyAtMC40OTcyLC0wLjUwNDkxIC0xLjE0MTYsLTAuNzY0NjUgLTEuNzk0OSwtMC43OTQ5MiBMIDg4OC43NSwxNTkuNDcwNyBjIC0wLjUyMzUsLTAuNTMxNjggLTEuMjA5OSwtMC44MDEzMiAtMS44OTg0LC0wLjgwNjY0IHpcXFwiXFxuICAgICAgIHN0eWxlPVxcXCJvcGFjaXR5OjE7ZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDo5MC43NDgwMDExO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDozLjI3NTkwMDEzO3N0cm9rZS1vcGFjaXR5OjFcXFwiIC8+XFxuICAgIDxwYXRoXFxuICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz1cXFwiY2Njc3NzY2NcXFwiXFxuICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9XFxcIjBcXFwiXFxuICAgICAgIGlkPVxcXCJwYXRoNDMyM1xcXCJcXG4gICAgICAgZD1cXFwibSA4MDAsNDY0LjEyNSA5My43NSw5My43NSAtODc1LDg3OC4xMjUgYyAwLDAgMTcuNjQ4MjA5LC04NS41MzM3IDI4LjEyNSwtMTA5LjM3NSAxOC42MTQ1MiwtNDIuMzU5NyA3OC43MjcyNSwtMTIyLjE4MTcgMTA2LjI1LC0xNTkuMzc1IDI5Ljg0MzE0LC00MC4zMjkgNTguNTQ4OTEsLTY0LjkyMzUgODEuMjUsLTExMi41IDcuODM0MTUsLTE2LjQxODcgNDMuNzUsLTEyNSA0My43NSwtMTI1IHpcXFwiXFxuICAgICAgIHN0eWxlPVxcXCJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjFweDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxXFxcIiAvPlxcbiAgICA8cGF0aFxcbiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9XFxcImNjc3Nzc3NjY2NcXFwiXFxuICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9XFxcIjBcXFwiXFxuICAgICAgIGlkPVxcXCJwYXRoNDMyNVxcXCJcXG4gICAgICAgZD1cXFwiTSA5NTYuMjUsNjIzLjUgNDAuNjI1LDE0NTQuNzUgYyAwLDAgNjYuODAxNDEsLTYuNjE4OSAxMDMuMTI1LC0xOC43NSA0NC41OTQ4LC0xNC44OTM1IDc0LjA0MTA0LC0zMi4xOTY5IDkzLjc1LC00My43NSAzMC4xOTUyMiwtMTcuNzAwMSA3OC44MTM2NCwtNTAuMTQyOCAxMDYuMjUsLTcxLjg3NSAyNy44MTA0OCwtMjIuMDI4NiAyOC42ODQyOCwtMjkuMDc3MiA1OS4zNzUsLTQ2Ljg3NSAyMS4wOTQ0NiwtMTIuMjMyOCA2Ni40NDMsLTQzLjczNjcgOTAuNjI1LC00Ni44NzUgMTEuNDA5OSwtMS40ODA3IDU5LjM3NSwtMTguNzUgNTkuMzc1LC0xOC43NSBMIDEwNTAsNzExIFpcXFwiXFxuICAgICAgIHN0eWxlPVxcXCJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjFweDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2Utb3BhY2l0eToxXFxcIiAvPlxcbiAgPC9nPlxcbjwvc3ZnPlxcblwiLFxuICAgIFwiZmlsbFwiOiBcIjw/eG1sIHZlcnNpb249XFxcIjEuMFxcXCIgZW5jb2Rpbmc9XFxcIlVURi04XFxcIiBzdGFuZGFsb25lPVxcXCJub1xcXCI/PlxcbjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxNi4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT5cXG5cXG48c3ZnXFxuICAgeG1sbnM6ZGM9XFxcImh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvXFxcIlxcbiAgIHhtbG5zOmNjPVxcXCJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyNcXFwiXFxuICAgeG1sbnM6cmRmPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjXFxcIlxcbiAgIHhtbG5zOnN2Zz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgIHhtbG5zOnNvZGlwb2RpPVxcXCJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZFxcXCJcXG4gICB4bWxuczppbmtzY2FwZT1cXFwiaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZVxcXCJcXG4gICB2ZXJzaW9uPVxcXCIxLjFcXFwiXFxuICAgaWQ9XFxcIkNhcGFfMVxcXCJcXG4gICB4PVxcXCIwcHhcXFwiXFxuICAgeT1cXFwiMHB4XFxcIlxcbiAgIHdpZHRoPVxcXCI0MzguNTM2cHhcXFwiXFxuICAgaGVpZ2h0PVxcXCI0MzguNTM2cHhcXFwiXFxuICAgdmlld0JveD1cXFwiMCAwIDQzOC41MzYgNDM4LjUzNlxcXCJcXG4gICBzdHlsZT1cXFwiZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0MzguNTM2IDQzOC41MzY7XFxcIlxcbiAgIHhtbDpzcGFjZT1cXFwicHJlc2VydmVcXFwiXFxuICAgaW5rc2NhcGU6dmVyc2lvbj1cXFwiMC45MSByMTM3MjVcXFwiXFxuICAgc29kaXBvZGk6ZG9jbmFtZT1cXFwiZmlsbC5zdmdcXFwiPjxtZXRhZGF0YVxcbiAgICAgaWQ9XFxcIm1ldGFkYXRhNDFcXFwiPjxyZGY6UkRGPjxjYzpXb3JrXFxuICAgICAgICAgcmRmOmFib3V0PVxcXCJcXFwiPjxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PjxkYzp0eXBlXFxuICAgICAgICAgICByZGY6cmVzb3VyY2U9XFxcImh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlXFxcIiAvPjxkYzp0aXRsZSAvPjwvY2M6V29yaz48L3JkZjpSREY+PC9tZXRhZGF0YT48ZGVmc1xcbiAgICAgaWQ9XFxcImRlZnMzOVxcXCIgLz48c29kaXBvZGk6bmFtZWR2aWV3XFxuICAgICBwYWdlY29sb3I9XFxcIiNmZmZmZmZcXFwiXFxuICAgICBib3JkZXJjb2xvcj1cXFwiIzY2NjY2NlxcXCJcXG4gICAgIGJvcmRlcm9wYWNpdHk9XFxcIjFcXFwiXFxuICAgICBvYmplY3R0b2xlcmFuY2U9XFxcIjEwXFxcIlxcbiAgICAgZ3JpZHRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBndWlkZXRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9XFxcIjJcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9XFxcIjE0OTZcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PVxcXCI4ODBcXFwiXFxuICAgICBpZD1cXFwibmFtZWR2aWV3MzdcXFwiXFxuICAgICBzaG93Z3JpZD1cXFwiZmFsc2VcXFwiXFxuICAgICBpbmtzY2FwZTp6b29tPVxcXCIxLjAzNzU0NTZcXFwiXFxuICAgICBpbmtzY2FwZTpjeD1cXFwiMjQyLjU3NzgxXFxcIlxcbiAgICAgaW5rc2NhcGU6Y3k9XFxcIjIxNC42ODc5OFxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy14PVxcXCIyNFxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy15PVxcXCI0M1xcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPVxcXCJDYXBhXzFcXFwiPjxpbmtzY2FwZTpncmlkXFxuICAgICAgIHR5cGU9XFxcInh5Z3JpZFxcXCJcXG4gICAgICAgaWQ9XFxcImdyaWQ0MjY3XFxcIiAvPjwvc29kaXBvZGk6bmFtZWR2aWV3PjxwYXRoXFxuICAgICBzdHlsZT1cXFwiZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDoxLjA2Mjg2MTQ0cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MVxcXCJcXG4gICAgIGQ9XFxcIm0gMjQ1LjI1MTg0LDQ3LjA1NDY4OCAxNTMuMDYyNSwxNTMuNTU2NjQyIGMgMCwwIDEuNTI1NTUsMjguNTkzMTEgLTEuNjAxNTYsNDYuMDM5MDYgLTMuMTQ2NzMsMTcuNTU1NDUgLTEzLjk5NDI5LDM5LjQ4NTA1IC0yNy44MTQ0NSw1NS45MjE4OCAtMTQuMDYzNTUsMTYuNzI2MjggLTMxLjgwODYsMzAuODU5MzcgLTMxLjgwODYsMzAuODU5MzcgLTExLjYyNDY4LDguNTYyNTQgLTIxLjIxMTksMTMuNjYzMzggLTM0Ljg5MDYyLDE4LjkzMTY0IC0yMC45MjI5Miw3LjE3NjkyIC0zNi42ODkzOSw4LjYxNjAzIC01OC4wNjI1LDEwLjU2NjQxIGwgLTExMS40NjA5NCwtMTA1LjUzNTE2IDEuOTc0NjEsLTQ2LjQxNDA2IGMgMjAuNTYzOTgsLTE0LjM1NzIgMzcuOTA0NTgsLTIzLjk4MTQxIDU1LjYzMjgxLC0zNy4yMzI0MiAxNS4yNDkzLC0xMy4wMzQxOCAzMS44Nzg3OSwtMjkuNTU2OTYgNDMuMjA4OTksLTQ3LjgwNDY5IDUuNTU2ODMsLTguOTQ5NDggOS45MTM3NCwtMTcuMjY4OSAxMS42MTUyMywtMjkuMzkwNjI2IDEuMDIwNTMsLTcuMjcwMzk4IDAuMjY5MzgsLTEyLjI5MzYyNyAtMy44MDY2NCwtMTUuOTIxODc1IC00LjMyNzA5LC0zLjg1MTc0NCAtMTEuMzc0MzcsLTIuOTE2NzAxIC0xNy4yNTU4NiwtMi4wNTY2NCAtMTUuOTYxNTgsMi4zMzQwODcgLTM0Ljk2ODI3LDExLjk5ODI0NiAtNDcuNDg2MzMsMjMuMjYxNzIxIC05LjA4Njc2LDcuNTAzMjUgLTE1LjIyMjgyLDE0LjA1MDMgLTIwLjcyNDYsMjEuMTYwMTUgbCAtMTIuMjk0OTMsMTYuODg0NzcgLTMwLjYxMzI4LDEuNDgwNDcgYyAtMS4zMjk0NSwxLjMyOTQ2IDEuOTg3MTEsLTcuMTYxNDIgMTIuODM3ODksLTIyLjcxMjg5IDkuMjgwMTEsLTEzLjMwMDM4IDEyLjIzODYzLC0xNi44NDAxMyAyNy45NDE0MSwtMzAuMjQ0MTQzIDYuNTkxODUsLTUuNjI2ODUzIDExLjcyNjI2LC05LjMzMzAwOSAzMC4yMDg5OCwtMTkuNjIzMDQ3IDEzLjU1Njc5LC03LjU0NzU4NSAzMC40MTEwMiwtMTQuMDM3NTc1IDQ1LjcxMDk0LC0xNy44NDE3OTcgbCAxNS42MjY5NSwtMy44ODQ3NjUgeiBNIDE2NC41NDY3NywxNjAuNDQxNDEgYyAxNy43ODA1NCwtMC4zNzc0OSAtMTIuNjk2MDcsNi41MjQ0IC0yMC4wNzAzMiw5LjkzMTY0IC0xMS4wNDQ3Miw1LjEwMzE4IC0xNy4wNjMxOCw5LjQ3NzA4IC0yMC4xNjk5MiwxMS45MTAxNSAtNy40MDI5OSw1Ljc5NzcxIC0xMS41MTUxOSwxMi4zMzQ1OCAtMTMuMTg3NSwyMC42Mjg5MSAtMS4yNzgyLDYuMzM5NTcgLTEuNTY1NDMsOS41Mjc1OSAtMi4xNDQ1MywxNS45Njg3NSAtMi45MDU4NiwzMi4zMjExNyAtMi44ODIxOSw2NC4xNzgwMyAtMi4zODI4MSw5Ni40MjU3OCAwLjExMjI1LDcuMjQ4MzMgMC4yNTk1NywxNS4wNzcwMiAyLjE1NDI5LDIyLjA3NDIyIDEuNzQyMDgsNi40MzM0NyAzLjYwNDcyLDEzLjA0MjQ2IDkuMTE3MTksMTYuNzg5MDYgOC4zMjg5OSw1LjY2MDg3IDE5LjM2MjY1LDYuNTk4NyAyOS40NTExNyw2LjI3MzQ0IDIzLjMxMjQ2LC0wLjc1MTU5IDM5LjU1NTg4LC0xMi44ODc3IDQ1LjEwNzQzLDkuNDM3NSAxLjA1MzY3LDQuMjM3MjggLTMuOTE3OTcsOC4yMzQzNyAtMy45MTc5Nyw4LjIzNDM3IC00LjkxNTA1LDQuMzMyMzUgLTEyLjUwNDM5LDMuMTY3NjMgLTIwLjY3NTc4LDQuMTEzMjkgLTEwLjkwNDc0LDEuMjYxOTggLTE5Ljk4MDI3LDIuODIxNjMgLTI5LjQ4ODI5LDQuNjczODIgLTExLjUwMTk4LDIuMjQwNjEgLTE5LjMyNjk1LDMuMDQzNTQgLTI4LjM3Njk1LDMuODA0NjkgLTkuODQwMzIsMC44Mjc2MyAtMTkuODE1NzksMS4xMzg0OSAtMjkuNjI1LDAgLTUuNzEwMzUsLTAuNjYyNzYgLTExLjI1NjY1LC0yLjM4MDMyIC0xNi43ODcxMSwtMy45NDkyMiAtNC4wMDU2MywtMS4xMzYzMiAtOC40NjEwNCwtMi42NjU1NiAtMTEuODUxNTYsLTMuOTUxMTcgLTQuODA3NzYsLTEuODIzIC0xMS42MTY2MSwtNC43Mzg1IC0xMS44NDk2MSwtOS44NzUgLTAuMTA1NDgsLTIuMzI1MTggMi42Nzc2OSwtNC4zNzk5NiA0LjkzNzUsLTQuOTM3NSAzLjU1NTE0LC0wLjg3NzEyIDEwLjE5Mzg1LC0xLjYwMDg4IDEzLjgyNjE3LC00LjkzNzUgNC4wMTI2OSwtMy42ODYwMyA2LjEyMjk3LC0xMS44MDkxIDcuMDg1OTQsLTE3LjQzMTY0IDcuNjg3NjMsLTQ0Ljg4NjA2IC0wLjgwMDczLC0xMDUuNDI5MzIgLTAuMTczODMsLTEyOS40MTc5NyAwLjQzMDczLC0xNi40ODI1MSAzLjQ4ODQxLC0yOS4wNDM5MyAxNy43NzUzOSwtNDAuNDg2MzMgNS4zNDA4NCwtNC4yNzc0NiAxNS43MTA3NywtMTEuNjE0NzQgNzcuMDI1MzksLTE1LjEwMzUxIDEuNjM1NDcsLTAuMDkzMSAzLjAzNTM0LC0wLjE1MDYyIDQuMjIwNzEsLTAuMTc1NzggelxcXCJcXG4gICAgIGlkPVxcXCJwYXRoNDI2MVxcXCJcXG4gICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9XFxcIjBcXFwiIC8+PC9zdmc+XCIsXG4gICAgXCJmbG9wcHlcIjogXCI8P3htbCB2ZXJzaW9uPVxcXCIxLjBcXFwiIGVuY29kaW5nPVxcXCJVVEYtOFxcXCIgc3RhbmRhbG9uZT1cXFwibm9cXFwiPz5cXG48c3ZnXFxuICAgeG1sbnM6ZGM9XFxcImh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvXFxcIlxcbiAgIHhtbG5zOmNjPVxcXCJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyNcXFwiXFxuICAgeG1sbnM6cmRmPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjXFxcIlxcbiAgIHhtbG5zOnN2Zz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgIHhtbG5zOnNvZGlwb2RpPVxcXCJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZFxcXCJcXG4gICB4bWxuczppbmtzY2FwZT1cXFwiaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZVxcXCJcXG4gICBpZD1cXFwic3ZnMlxcXCJcXG4gICB2ZXJzaW9uPVxcXCIxLjFcXFwiXFxuICAgaW5rc2NhcGU6dmVyc2lvbj1cXFwiMC45MSByMTM3MjVcXFwiXFxuICAgc29kaXBvZGk6ZG9jbmFtZT1cXFwiZmxvcHB5LnN2Z1xcXCJcXG4gICB3aWR0aD1cXFwiMTUzNlxcXCJcXG4gICBoZWlnaHQ9XFxcIjE1MzZcXFwiPlxcbiAgPG1ldGFkYXRhXFxuICAgICBpZD1cXFwibWV0YWRhdGExMFxcXCI+XFxuICAgIDxyZGY6UkRGPlxcbiAgICAgIDxjYzpXb3JrXFxuICAgICAgICAgcmRmOmFib3V0PVxcXCJcXFwiPlxcbiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+XFxuICAgICAgICA8ZGM6dHlwZVxcbiAgICAgICAgICAgcmRmOnJlc291cmNlPVxcXCJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZVxcXCIgLz5cXG4gICAgICAgIDxkYzp0aXRsZT48L2RjOnRpdGxlPlxcbiAgICAgIDwvY2M6V29yaz5cXG4gICAgPC9yZGY6UkRGPlxcbiAgPC9tZXRhZGF0YT5cXG4gIDxkZWZzXFxuICAgICBpZD1cXFwiZGVmczhcXFwiIC8+XFxuICA8c29kaXBvZGk6bmFtZWR2aWV3XFxuICAgICBwYWdlY29sb3I9XFxcIiNmZmZmZmZcXFwiXFxuICAgICBib3JkZXJjb2xvcj1cXFwiIzY2NjY2NlxcXCJcXG4gICAgIGJvcmRlcm9wYWNpdHk9XFxcIjFcXFwiXFxuICAgICBvYmplY3R0b2xlcmFuY2U9XFxcIjEwXFxcIlxcbiAgICAgZ3JpZHRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBndWlkZXRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9XFxcIjJcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9XFxcIjExNDNcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PVxcXCI5MTVcXFwiXFxuICAgICBpZD1cXFwibmFtZWR2aWV3NlxcXCJcXG4gICAgIHNob3dncmlkPVxcXCJmYWxzZVxcXCJcXG4gICAgIGZpdC1tYXJnaW4tdG9wPVxcXCIwXFxcIlxcbiAgICAgZml0LW1hcmdpbi1sZWZ0PVxcXCIwXFxcIlxcbiAgICAgZml0LW1hcmdpbi1yaWdodD1cXFwiMFxcXCJcXG4gICAgIGZpdC1tYXJnaW4tYm90dG9tPVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6em9vbT1cXFwiMC4xMjc5MjgzMlxcXCJcXG4gICAgIGlua3NjYXBlOmN4PVxcXCI1MFxcXCJcXG4gICAgIGlua3NjYXBlOmN5PVxcXCIxMzU4XFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LXg9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3cteT1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPVxcXCJzdmcyXFxcIiAvPlxcbiAgPHBhdGhcXG4gICAgIGQ9XFxcIm0gMzg0LDE0MDggNzY4LDAgMCwtMzg0IC03NjgsMCAwLDM4NCB6IG0gODk2LDAgMTI4LDAgMCwtODk2IHEgMCwtMTQgLTEwLC0zOC41IFEgMTM4OCw0NDkgMTM3OCw0MzkgTCAxMDk3LDE1OCBxIC0xMCwtMTAgLTM0LC0yMCAtMjQsLTEwIC0zOSwtMTAgbCAwLDQxNiBxIDAsNDAgLTI4LDY4IC0yOCwyOCAtNjgsMjggbCAtNTc2LDAgcSAtNDAsMCAtNjgsLTI4IC0yOCwtMjggLTI4LC02OCBsIDAsLTQxNiAtMTI4LDAgMCwxMjgwIDEyOCwwIDAsLTQxNiBxIDAsLTQwIDI4LC02OCAyOCwtMjggNjgsLTI4IGwgODMyLDAgcSA0MCwwIDY4LDI4IDI4LDI4IDI4LDY4IGwgMCw0MTYgeiBNIDg5Niw0ODAgODk2LDE2MCBxIDAsLTEzIC05LjUsLTIyLjUgUSA4NzcsMTI4IDg2NCwxMjggbCAtMTkyLDAgcSAtMTMsMCAtMjIuNSw5LjUgUSA2NDAsMTQ3IDY0MCwxNjAgbCAwLDMyMCBxIDAsMTMgOS41LDIyLjUgOS41LDkuNSAyMi41LDkuNSBsIDE5MiwwIHEgMTMsMCAyMi41LC05LjUgUSA4OTYsNDkzIDg5Niw0ODAgWiBtIDY0MCwzMiAwLDkyOCBxIDAsNDAgLTI4LDY4IC0yOCwyOCAtNjgsMjggTCA5NiwxNTM2IFEgNTYsMTUzNiAyOCwxNTA4IDAsMTQ4MCAwLDE0NDAgTCAwLDk2IFEgMCw1NiAyOCwyOCA1NiwwIDk2LDAgbCA5MjgsMCBxIDQwLDAgODgsMjAgNDgsMjAgNzYsNDggbCAyODAsMjgwIHEgMjgsMjggNDgsNzYgMjAsNDggMjAsODggelxcXCJcXG4gICAgIGlkPVxcXCJwYXRoNFxcXCJcXG4gICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9XFxcIjBcXFwiXFxuICAgICBzdHlsZT1cXFwiZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxXFxcIiAvPlxcbjwvc3ZnPlxcblwiLFxuICAgIFwiZnVsbHNjcmVlblwiOiBcIjw/eG1sIHZlcnNpb249XFxcIjEuMFxcXCIgZW5jb2Rpbmc9XFxcIlVURi04XFxcIiBzdGFuZGFsb25lPVxcXCJub1xcXCI/PlxcbjxzdmdcXG4gICB4bWxuczpkYz1cXFwiaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS9cXFwiXFxuICAgeG1sbnM6Y2M9XFxcImh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zI1xcXCJcXG4gICB4bWxuczpyZGY9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyNcXFwiXFxuICAgeG1sbnM6c3ZnPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgeG1sbnM6c29kaXBvZGk9XFxcImh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkXFxcIlxcbiAgIHhtbG5zOmlua3NjYXBlPVxcXCJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlXFxcIlxcbiAgIGlkPVxcXCJzdmcyXFxcIlxcbiAgIHZlcnNpb249XFxcIjEuMVxcXCJcXG4gICBpbmtzY2FwZTp2ZXJzaW9uPVxcXCIwLjkxIHIxMzcyNVxcXCJcXG4gICBzb2RpcG9kaTpkb2NuYW1lPVxcXCJmdWxsc2NyZWVuLnN2Z1xcXCJcXG4gICB3aWR0aD1cXFwiMTUzNlxcXCJcXG4gICBoZWlnaHQ9XFxcIjE1MzZcXFwiPlxcbiAgPG1ldGFkYXRhXFxuICAgICBpZD1cXFwibWV0YWRhdGExMFxcXCI+XFxuICAgIDxyZGY6UkRGPlxcbiAgICAgIDxjYzpXb3JrXFxuICAgICAgICAgcmRmOmFib3V0PVxcXCJcXFwiPlxcbiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+XFxuICAgICAgICA8ZGM6dHlwZVxcbiAgICAgICAgICAgcmRmOnJlc291cmNlPVxcXCJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZVxcXCIgLz5cXG4gICAgICAgIDxkYzp0aXRsZSAvPlxcbiAgICAgIDwvY2M6V29yaz5cXG4gICAgPC9yZGY6UkRGPlxcbiAgPC9tZXRhZGF0YT5cXG4gIDxkZWZzXFxuICAgICBpZD1cXFwiZGVmczhcXFwiIC8+XFxuICA8c29kaXBvZGk6bmFtZWR2aWV3XFxuICAgICBwYWdlY29sb3I9XFxcIiNmZmZmZmZcXFwiXFxuICAgICBib3JkZXJjb2xvcj1cXFwiIzY2NjY2NlxcXCJcXG4gICAgIGJvcmRlcm9wYWNpdHk9XFxcIjFcXFwiXFxuICAgICBvYmplY3R0b2xlcmFuY2U9XFxcIjEwXFxcIlxcbiAgICAgZ3JpZHRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBndWlkZXRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9XFxcIjJcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9XFxcIjE2NzJcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PVxcXCIxMTMyXFxcIlxcbiAgICAgaWQ9XFxcIm5hbWVkdmlldzZcXFwiXFxuICAgICBzaG93Z3JpZD1cXFwiZmFsc2VcXFwiXFxuICAgICBmaXQtbWFyZ2luLXRvcD1cXFwiMFxcXCJcXG4gICAgIGZpdC1tYXJnaW4tbGVmdD1cXFwiMFxcXCJcXG4gICAgIGZpdC1tYXJnaW4tcmlnaHQ9XFxcIjBcXFwiXFxuICAgICBmaXQtbWFyZ2luLWJvdHRvbT1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOnpvb209XFxcIjAuMzU5MDc0MjlcXFwiXFxuICAgICBpbmtzY2FwZTpjeD1cXFwiMTIzNy43NzY1XFxcIlxcbiAgICAgaW5rc2NhcGU6Y3k9XFxcIjY4OS42MTQ2NFxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy14PVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LXk9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj1cXFwic3ZnMlxcXCIgLz5cXG4gIDxwYXRoXFxuICAgICBkPVxcXCJNIDEyMTMuOTAyMywxMDc1LjM2OTYgOTA2LjUzMjc3LDc2OC4wMDAwMSAxMjEzLjkwMjMsNDYwLjYzMDQ0IDEzMzguNTgxOSw1ODUuMzA5OTMgcSAyNS4xMDksMjYuODQwNzIgNjAuNjA4MSwxMi4xMjE2MSAzMy43NjczLC0xNC43MTkxIDMzLjc2NzMsLTUxLjA4Mzk1IGwgMCwtMzg3Ljg5MTczIHEgMCwtMjIuNTExNTggLTE2LjQ1MDksLTM4Ljk2MjM0IC0xNi40NTA3LC0xNi40NTA3NyAtMzguOTYyMywtMTYuNDUwNzcgbCAtMzg3Ljg5MTY3LDAgcSAtMzYuMzY0ODUsMCAtNTEuMDgzOTYsMzQuNjMzMTkgLTE0LjcxOTExLDMzLjc2NzM2IDEyLjEyMTYyLDU5Ljc0MjI1IEwgMTA3NS4zNjk2LDMyMi4wOTc2OCA3NjguMDAwMDEsNjI5LjQ2NzI0IDQ2MC42MzA0NCwzMjIuMDk3NjggNTg1LjMwOTkzLDE5Ny40MTgxOSBxIDI2Ljg0MDcyLC0yNS45NzQ4OSAxMi4xMjE2MSwtNTkuNzQyMjUgLTE0LjcxOTEsLTM0LjYzMzE5IC01MS4wODM5NSwtMzQuNjMzMTkgbCAtMzg3Ljg5MTc0LDAgcSAtMjIuNTExNTcsMCAtMzguOTYyMzQsMTYuNDUwNzcgLTE2LjQ1MDc2LDE2LjQ1MDc2IC0xNi40NTA3NiwzOC45NjIzNCBsIDAsMzg3Ljg5MTczIHEgMCwzNi4zNjQ4NSAzNC42MzMxOSw1MS4wODM5NSAzMy43NjczNiwxNC43MTkxMSA1OS43NDIyNSwtMTIuMTIxNjEgTCAzMjIuMDk3NjgsNDYwLjYzMDQ0IDYyOS40NjcyNCw3NjguMDAwMDEgMzIyLjA5NzY4LDEwNzUuMzY5NiAxOTcuNDE4MTksOTUwLjY5MDA5IHEgLTE2LjQ1MDc2LC0xNi40NTA3NyAtMzguOTYyMzQsLTE2LjQ1MDc3IC0xMC4zODk5NSwwIC0yMC43Nzk5MSw0LjMyOTE1IC0zNC42MzMxOSwxNC43MTkxMSAtMzQuNjMzMTksNTEuMDgzOTYgbCAwLDM4Ny44OTE3NyBxIDAsMjIuNTExNiAxNi40NTA3NiwzOC45NjIzIDE2LjQ1MDc3LDE2LjQ1MDggMzguOTYyMzQsMTYuNDUwOCBsIDM4Ny44OTE3NCwwIHEgMzYuMzY0ODUsMCA1MS4wODM5NSwtMzQuNjMzMiAxNC43MTkxMSwtMzMuNzY3MyAtMTIuMTIxNjEsLTU5Ljc0MjIgTCA0NjAuNjMwNDQsMTIxMy45MDI0IDc2OC4wMDAwMSw5MDYuNTMyNzcgMTA3NS4zNjk2LDEyMTMuOTAyNCA5NTAuNjkwMDksMTMzOC41ODE5IHEgLTI2Ljg0MDczLDI1Ljk3NDkgLTEyLjEyMTYyLDU5Ljc0MjIgMTQuNzE5MTEsMzQuNjMzMiA1MS4wODM5NiwzNC42MzMyIGwgMzg3Ljg5MTc3LDAgcSAyMi41MTE2LDAgMzguOTYyMiwtMTYuNDUwOSAxNi40NTA5LC0xNi40NTA3IDE2LjQ1MDksLTM4Ljk2MjIgbCAwLC0zODcuODkxNzcgcSAwLC0zNi4zNjQ4NSAtMzMuNzY3MywtNTEuMDgzOTYgLTExLjI1NTgsLTQuMzI5MTUgLTIxLjY0NTgsLTQuMzI5MTUgLTIyLjUxMTYsMCAtMzguOTYyMywxNi40NTA3NyB6XFxcIlxcbiAgICAgaWQ9XFxcInBhdGg0XFxcIlxcbiAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT1cXFwiMFxcXCJcXG4gICAgIHN0eWxlPVxcXCJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjFcXFwiIC8+XFxuPC9zdmc+XFxuXCIsXG4gICAgXCJsaW5rXCI6IFwiPD94bWwgdmVyc2lvbj1cXFwiMS4wXFxcIiBlbmNvZGluZz1cXFwiVVRGLThcXFwiIHN0YW5kYWxvbmU9XFxcIm5vXFxcIj8+XFxuPHN2Z1xcbiAgIHhtbG5zOmRjPVxcXCJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xL1xcXCJcXG4gICB4bWxuczpjYz1cXFwiaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjXFxcIlxcbiAgIHhtbG5zOnJkZj1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zI1xcXCJcXG4gICB4bWxuczpzdmc9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICB4bWxuczpzb2RpcG9kaT1cXFwiaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGRcXFwiXFxuICAgeG1sbnM6aW5rc2NhcGU9XFxcImh0dHA6Ly93d3cuaW5rc2NhcGUub3JnL25hbWVzcGFjZXMvaW5rc2NhcGVcXFwiXFxuICAgaWQ9XFxcInN2ZzJcXFwiXFxuICAgdmVyc2lvbj1cXFwiMS4xXFxcIlxcbiAgIGlua3NjYXBlOnZlcnNpb249XFxcIjAuOTEgcjEzNzI1XFxcIlxcbiAgIHNvZGlwb2RpOmRvY25hbWU9XFxcImxpbmsuc3ZnXFxcIlxcbiAgIHdpZHRoPVxcXCIxNTM2XFxcIlxcbiAgIGhlaWdodD1cXFwiMTUzNlxcXCI+XFxuICA8bWV0YWRhdGFcXG4gICAgIGlkPVxcXCJtZXRhZGF0YTEwXFxcIj5cXG4gICAgPHJkZjpSREY+XFxuICAgICAgPGNjOldvcmtcXG4gICAgICAgICByZGY6YWJvdXQ9XFxcIlxcXCI+XFxuICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD5cXG4gICAgICAgIDxkYzp0eXBlXFxuICAgICAgICAgICByZGY6cmVzb3VyY2U9XFxcImh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlXFxcIiAvPlxcbiAgICAgICAgPGRjOnRpdGxlPjwvZGM6dGl0bGU+XFxuICAgICAgPC9jYzpXb3JrPlxcbiAgICA8L3JkZjpSREY+XFxuICA8L21ldGFkYXRhPlxcbiAgPGRlZnNcXG4gICAgIGlkPVxcXCJkZWZzOFxcXCIgLz5cXG4gIDxzb2RpcG9kaTpuYW1lZHZpZXdcXG4gICAgIHBhZ2Vjb2xvcj1cXFwiI2ZmZmZmZlxcXCJcXG4gICAgIGJvcmRlcmNvbG9yPVxcXCIjNjY2NjY2XFxcIlxcbiAgICAgYm9yZGVyb3BhY2l0eT1cXFwiMVxcXCJcXG4gICAgIG9iamVjdHRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBncmlkdG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGd1aWRldG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz1cXFwiMlxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD1cXFwiMTY3MlxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9XFxcIjExMzJcXFwiXFxuICAgICBpZD1cXFwibmFtZWR2aWV3NlxcXCJcXG4gICAgIHNob3dncmlkPVxcXCJmYWxzZVxcXCJcXG4gICAgIGZpdC1tYXJnaW4tdG9wPVxcXCIwXFxcIlxcbiAgICAgZml0LW1hcmdpbi1sZWZ0PVxcXCIwXFxcIlxcbiAgICAgZml0LW1hcmdpbi1yaWdodD1cXFwiMFxcXCJcXG4gICAgIGZpdC1tYXJnaW4tYm90dG9tPVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6em9vbT1cXFwiMC4wODMyODEzOTFcXFwiXFxuICAgICBpbmtzY2FwZTpjeD1cXFwiNDk0LjEyMTU1XFxcIlxcbiAgICAgaW5rc2NhcGU6Y3k9XFxcIjkxMi40MDk3NlxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy14PVxcXCI1OFxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy15PVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LW1heGltaXplZD1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9XFxcInN2ZzJcXFwiIC8+XFxuICA8cGF0aFxcbiAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT1cXFwiMFxcXCJcXG4gICAgIHVuaWNvZGU9XFxcIu+DgVxcXCJcXG4gICAgIGhvcml6LWFkdi14PVxcXCIxNjY0XFxcIlxcbiAgICAgZD1cXFwibSAxMzQ5LjUzMjQsNDEwLjEzMzg3IHEgMCwzNy4yNzc3MiAtMjYuMDk0NCw2My4zNzIxMiBMIDExMjkuNTkzOSw2NjcuMzUwMSBxIC0yNi4wOTQ0LDI2LjA5NDQgLTYzLjM3MjIsMjYuMDk0NCAtMzkuMTQxNiwwIC02Ny4wOTk4NCwtMjkuODIyMTcgMi43OTU4NCwtMi43OTU4MyAxNy43MDY5NCwtMTcuMjQwOTQgMTQuOTExLC0xNC40NDUxMiAyMC4wMzY3LC0yMC4wMzY3NyA1LjEyNTcsLTUuNTkxNjYgMTMuOTc5MiwtMTcuNzA2OTIgOC44NTM0LC0xMi4xMTUyNiAxMi4xMTUyLC0yMy43NjQ1NCAzLjI2MTgsLTExLjY0OTI5IDMuMjYxOCwtMjUuNjI4NDMgMCwtMzcuMjc3NzEgLTI2LjA5NDQsLTYzLjM3MjEyIC0yNi4wOTQzLC0yNi4wOTQ0IC02My4zNzIwOSwtMjYuMDk0NCAtMTMuOTc5MTQsMCAtMjUuNjI4NDMsMy4yNjE4IC0xMS42NDkyOSwzLjI2MTggLTIzLjc2NDU0LDEyLjExNTI2IC0xMi4xMTUyNiw4Ljg1MzQ2IC0xNy43MDY5MiwxMy45NzkxNCAtNS41OTE2Niw1LjEyNTY5IC0yMC4wMzY3NywyMC4wMzY3OCAtMTQuNDQ1MTEsMTQuOTExMDggLTE3LjI0MDk0LDE3LjcwNjkxIC0zMC43NTQxMiwtMjguODkwMjMgLTMwLjc1NDEyLC02OC4wMzE4MyAwLC0zNy4yNzc3MSAyNi4wOTQ0LC02My4zNzIxMSBMIDEwNTkuNjk4MSwyMTIuNTYxOTggcSAyNS4xNjI1LC0yNS4xNjI0NiA2My4zNzIyLC0yNS4xNjI0NiAzNy4yNzc3LDAgNjMuMzcyMSwyNC4yMzA1MiBMIDEzMjMuNDM4LDM0Ny42OTM3IHEgMjYuMDk0NCwyNi4wOTQ0IDI2LjA5NDQsNjIuNDQwMTcgeiBNIDY5NC4zNzY1MywxMDY3LjE1MzcgcSAwLDM3LjI3NzcgLTI2LjA5NDQsNjMuMzcyMSBMIDQ3Ni4zMDE5LDEzMjMuNDM4IHEgLTI2LjA5NDQsMjYuMDk0NCAtNjMuMzcyMTIsMjYuMDk0NCAtMzYuMzQ1NzcsMCAtNjMuMzcyMTIsLTI1LjE2MjUgbCAtMTM2Ljk5NTYsLTEzNi4wNjM2IHEgLTI2LjA5NDQsLTI2LjA5NDQgLTI2LjA5NDQsLTYyLjQ0MDIgMCwtMzcuMjc3NyAyNi4wOTQ0LC02My4zNzIxIEwgNDA2LjQwNjE4LDg2OC42NDk4IHEgMjUuMTYyNDYsLTI1LjE2MjQ2IDYzLjM3MjEyLC0yNS4xNjI0NiAzOS4xNDE2LDAgNjcuMDk5ODgsMjguODkwMjMgLTIuNzk1ODMsMi43OTU4MyAtMTcuNzA2OTEsMTcuMjQwOTUgLTE0LjkxMTA5LDE0LjQ0NTExIC0yMC4wMzY3NywyMC4wMzY3NyAtNS4xMjU2OSw1LjU5MTY1IC0xMy45NzkxNSwxNy43MDY5MSAtOC44NTM0NSwxMi4xMTUyNiAtMTIuMTE1MjUsMjMuNzY0NSAtMy4yNjE4LDExLjY0OTMgLTMuMjYxOCwyNS42Mjg1IDAsMzcuMjc3NyAyNi4wOTQ0LDYzLjM3MjEgMjYuMDk0NCwyNi4wOTQ0IDYzLjM3MjExLDI2LjA5NDQgMTMuOTc5MTQsMCAyNS42Mjg0MywtMy4yNjE4IDExLjY0OTI5LC0zLjI2MTggMjMuNzY0NTQsLTEyLjExNTIgMTIuMTE1MjYsLTguODUzNSAxNy43MDY5MiwtMTMuOTc5MiA1LjU5MTY1LC01LjEyNTcgMjAuMDM2NzcsLTIwLjAzNjcgMTQuNDQ1MTEsLTE0LjkxMTEgMTcuMjQwOTQsLTE3LjcwNyAzMC43NTQxMiwyOC44OTAzIDMwLjc1NDEyLDY4LjAzMTkgeiBNIDE1MjguNDY1NCw0MTAuMTMzODcgcSAwLC0xMTEuODMzMTQgLTc5LjIxNTEsLTE4OS4xODQ0IEwgMTMxMi4yNTQ3LDg0Ljg4NTg2MSBRIDEyMzQuOTAzNCw3LjUzNDU5OSAxMTIzLjA3MDMsNy41MzQ1OTkgcSAtMTEyLjc2NTEsMCAtMTkwLjExNjQxLDc5LjIxNTE0MiBMIDc0MC45NzM2NiwyNzkuNjYxODcgcSAtNzcuMzUxMjUsNzcuMzUxMjYgLTc3LjM1MTI1LDE4OS4xODQ0IDAsMTE0LjYyODk3IDgyLjAxMDk3LDE5NC43NzYwNiBsIC04Mi4wMTA5Nyw4Mi4wMTA5NyBxIC04MC4xNDcwOCwtODIuMDEwOTcgLTE5My44NDQxMSwtODIuMDEwOTcgLTExMS44MzMxNSwwIC0xOTAuMTE2MzUsNzguMjgzMiBMIDg1LjgxNzg0Myw5MzUuNzQ5NjkgUSA3LjUzNDYzNzUsMTAxNC4wMzI5IDcuNTM0NjM3NSwxMTI1Ljg2NjEgcSAwLDExMS44MzMxIDc5LjIxNTE0NTUsMTg5LjE4NDQgbCAxMzYuOTk1NTk3LDEzNi4wNjM2IHEgNzcuMzUxMjYsNzcuMzUxMyAxODkuMTg0NCw3Ny4zNTEzIDExMi43NjUwOSwwIDE5MC4xMTYzNSwtNzkuMjE1MSBsIDE5MS45ODAyMiwtMTkyLjkxMjIgcSA3Ny4zNTEyNiwtNzcuMzUxMyA3Ny4zNTEyNiwtMTg5LjE4NDQgMCwtMTE0LjYyOSAtODIuMDEwOTgsLTE5NC43NzYxMyBsIDgyLjAxMDk4LC04Mi4wMTEwMSBxIDgwLjE0NzA4LDgyLjAxMTAxIDE5My44NDQwOSw4Mi4wMTEwMSAxMTEuODMzMiwwIDE5MC4xMTY0LC03OC4yODMyIGwgMTkzLjg0NDEsLTE5My44NDQxNSBxIDc4LjI4MzIsLTc4LjI4MzIgNzguMjgzMiwtMTkwLjExNjM1IHpcXFwiXFxuICAgICBpZD1cXFwicGF0aDQtNFxcXCJcXG4gICAgIHN0eWxlPVxcXCJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjFcXFwiIC8+XFxuPC9zdmc+XFxuXCIsXG4gICAgXCJwYWludFwiOiBcIjw/eG1sIHZlcnNpb249XFxcIjEuMFxcXCIgZW5jb2Rpbmc9XFxcIlVURi04XFxcIiBzdGFuZGFsb25lPVxcXCJub1xcXCI/PlxcbjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxNi4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT5cXG5cXG48c3ZnXFxuICAgeG1sbnM6ZGM9XFxcImh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvXFxcIlxcbiAgIHhtbG5zOmNjPVxcXCJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyNcXFwiXFxuICAgeG1sbnM6cmRmPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjXFxcIlxcbiAgIHhtbG5zOnN2Zz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgIHhtbG5zOnNvZGlwb2RpPVxcXCJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZFxcXCJcXG4gICB4bWxuczppbmtzY2FwZT1cXFwiaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZVxcXCJcXG4gICB2ZXJzaW9uPVxcXCIxLjFcXFwiXFxuICAgaWQ9XFxcIkNhcGFfMVxcXCJcXG4gICB4PVxcXCIwcHhcXFwiXFxuICAgeT1cXFwiMHB4XFxcIlxcbiAgIHdpZHRoPVxcXCI0MzIuNTQ0cHhcXFwiXFxuICAgaGVpZ2h0PVxcXCI0MzIuNTQ0cHhcXFwiXFxuICAgdmlld0JveD1cXFwiMCAwIDQzMi41NDQgNDMyLjU0NFxcXCJcXG4gICBzdHlsZT1cXFwiZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0MzIuNTQ0IDQzMi41NDQ7XFxcIlxcbiAgIHhtbDpzcGFjZT1cXFwicHJlc2VydmVcXFwiXFxuICAgaW5rc2NhcGU6dmVyc2lvbj1cXFwiMC45MSByMTM3MjVcXFwiXFxuICAgc29kaXBvZGk6ZG9jbmFtZT1cXFwicGVuY2lsLnN2Z1xcXCI+PG1ldGFkYXRhXFxuICAgICBpZD1cXFwibWV0YWRhdGE0NVxcXCI+PHJkZjpSREY+PGNjOldvcmtcXG4gICAgICAgICByZGY6YWJvdXQ9XFxcIlxcXCI+PGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+PGRjOnR5cGVcXG4gICAgICAgICAgIHJkZjpyZXNvdXJjZT1cXFwiaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2VcXFwiIC8+PC9jYzpXb3JrPjwvcmRmOlJERj48L21ldGFkYXRhPjxkZWZzXFxuICAgICBpZD1cXFwiZGVmczQzXFxcIiAvPjxzb2RpcG9kaTpuYW1lZHZpZXdcXG4gICAgIHBhZ2Vjb2xvcj1cXFwiI2ZmZmZmZlxcXCJcXG4gICAgIGJvcmRlcmNvbG9yPVxcXCIjNjY2NjY2XFxcIlxcbiAgICAgYm9yZGVyb3BhY2l0eT1cXFwiMVxcXCJcXG4gICAgIG9iamVjdHRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBncmlkdG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGd1aWRldG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz1cXFwiMlxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD1cXFwiMTQ0MlxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9XFxcIjg1NFxcXCJcXG4gICAgIGlkPVxcXCJuYW1lZHZpZXc0MVxcXCJcXG4gICAgIHNob3dncmlkPVxcXCJmYWxzZVxcXCJcXG4gICAgIGlua3NjYXBlOnpvb209XFxcIjAuNzcxNjA3OTdcXFwiXFxuICAgICBpbmtzY2FwZTpjeD1cXFwiMTk5LjYzMDYyXFxcIlxcbiAgICAgaW5rc2NhcGU6Y3k9XFxcIjIxNy4zNDU2NFxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy14PVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LXk9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj1cXFwiQ2FwYV8xXFxcIiAvPjxwYXRoXFxuICAgICBkPVxcXCJtIDAsMzEzLjc3NSAwLDExOC43NyAxMTguNzcxLDAgTCAzNTYuMzEyLDE5NS4wMDQgMjM3LjUzOSw3Ni4yMzIgMCwzMTMuNzc1IFogbSAxMDMuNjM4LDgyLjIyNCAwLDAgLTMwLjU1LDAuMDA0IDAsLTM2LjU0NiAtMzYuNTQzLDAgMCwtMzAuNTUzIDI1Ljk4MSwtMjUuOTgxIDY3LjA5Myw2Ny4wOTIgLTI1Ljk4MSwyNS45ODQgeiBNIDI0Ni42ODMsMTI0Ljc3IGMgNC4xODIsMCA2LjI3NiwyLjA5NSA2LjI3Niw2LjI4IDAsMS45MDYgLTAuNjY0LDMuNTIxIC0xLjk5OSw0Ljg1NiBMIDk2LjIxNCwyOTAuNjUxIGMgLTEuMzMzLDEuMzI4IC0yLjk1MiwxLjk5NSAtNC44NTQsMS45OTUgLTQuMTg0LDAgLTYuMjc5LC0yLjA5OCAtNi4yNzksLTYuMjc5IDAsLTEuOTA2IDAuNjY2LC0zLjUyMSAxLjk5NywtNC44NTYgTCAyNDEuODI1LDEyNi43NjggYyAxLjMyOSwtMS4zMzIgMi45NDgsLTEuOTk4IDQuODU4LC0xLjk5OCB6XFxcIlxcbiAgICAgaWQ9XFxcInBhdGg3XFxcIlxcbiAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT1cXFwiMFxcXCJcXG4gICAgIHN0eWxlPVxcXCJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjFcXFwiIC8+PHBhdGhcXG4gICAgIGQ9XFxcIk0gNDIxLjk3Niw3Ny42NTQgMzU0Ljg4NSwxMC44NDggQyAzNDcuNjUzLDMuNjE5IDMzOC45OTIsMCAzMjguOTAzLDAgMzE4LjYyLDAgMzEwLjA2MSwzLjYxOSAzMDMuMjEsMTAuODQ4IGwgLTQ3LjM5NCw0Ny4xMDkgMTE4Ljc3MywxMTguNzcgNDcuMzk0LC00Ny4zOTIgYyA3LjA0MiwtNy4wNDMgMTAuNTYxLC0xNS42MDggMTAuNTYxLC0yNS42OTcgLTAuMDA0LC05Ljg5NSAtMy41MjIsLTE4LjU1OCAtMTAuNTY4LC0yNS45ODQgelxcXCJcXG4gICAgIGlkPVxcXCJwYXRoOVxcXCJcXG4gICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9XFxcIjBcXFwiXFxuICAgICBzdHlsZT1cXFwiZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxXFxcIiAvPjxnXFxuICAgICBpZD1cXFwiZzExXFxcIiAvPjxnXFxuICAgICBpZD1cXFwiZzEzXFxcIiAvPjxnXFxuICAgICBpZD1cXFwiZzE1XFxcIiAvPjxnXFxuICAgICBpZD1cXFwiZzE3XFxcIiAvPjxnXFxuICAgICBpZD1cXFwiZzE5XFxcIiAvPjxnXFxuICAgICBpZD1cXFwiZzIxXFxcIiAvPjxnXFxuICAgICBpZD1cXFwiZzIzXFxcIiAvPjxnXFxuICAgICBpZD1cXFwiZzI1XFxcIiAvPjxnXFxuICAgICBpZD1cXFwiZzI3XFxcIiAvPjxnXFxuICAgICBpZD1cXFwiZzI5XFxcIiAvPjxnXFxuICAgICBpZD1cXFwiZzMxXFxcIiAvPjxnXFxuICAgICBpZD1cXFwiZzMzXFxcIiAvPjxnXFxuICAgICBpZD1cXFwiZzM1XFxcIiAvPjxnXFxuICAgICBpZD1cXFwiZzM3XFxcIiAvPjxnXFxuICAgICBpZD1cXFwiZzM5XFxcIiAvPjwvc3ZnPlwiLFxuICAgIFwicHJlY2lzZUN1cnNvclwiOiBcIjw/eG1sIHZlcnNpb249XFxcIjEuMFxcXCIgZW5jb2Rpbmc9XFxcIlVURi04XFxcIiBzdGFuZGFsb25lPVxcXCJub1xcXCI/PlxcbjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxNi4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT5cXG5cXG48c3ZnXFxuICAgeG1sbnM6ZGM9XFxcImh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvXFxcIlxcbiAgIHhtbG5zOmNjPVxcXCJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyNcXFwiXFxuICAgeG1sbnM6cmRmPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjXFxcIlxcbiAgIHhtbG5zOnN2Zz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgIHhtbG5zOnNvZGlwb2RpPVxcXCJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZFxcXCJcXG4gICB4bWxuczppbmtzY2FwZT1cXFwiaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZVxcXCJcXG4gICB2ZXJzaW9uPVxcXCIxLjFcXFwiXFxuICAgaWQ9XFxcIkNhcGFfMVxcXCJcXG4gICB4PVxcXCIwcHhcXFwiXFxuICAgeT1cXFwiMHB4XFxcIlxcbiAgIHdpZHRoPVxcXCI0MzguNTMzcHhcXFwiXFxuICAgaGVpZ2h0PVxcXCI0MzguNTMzcHhcXFwiXFxuICAgdmlld0JveD1cXFwiMCAwIDQzOC41MzMgNDM4LjUzM1xcXCJcXG4gICBzdHlsZT1cXFwiZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0MzguNTMzIDQzOC41MzM7XFxcIlxcbiAgIHhtbDpzcGFjZT1cXFwicHJlc2VydmVcXFwiXFxuICAgaW5rc2NhcGU6dmVyc2lvbj1cXFwiMC45MSByMTM3MjVcXFwiXFxuICAgc29kaXBvZGk6ZG9jbmFtZT1cXFwicHJlY2lzZUN1cnNvci5zdmdcXFwiPjxtZXRhZGF0YVxcbiAgICAgaWQ9XFxcIm1ldGFkYXRhNDVcXFwiPjxyZGY6UkRGPjxjYzpXb3JrXFxuICAgICAgICAgcmRmOmFib3V0PVxcXCJcXFwiPjxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PjxkYzp0eXBlXFxuICAgICAgICAgICByZGY6cmVzb3VyY2U9XFxcImh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlXFxcIiAvPjxkYzp0aXRsZSAvPjwvY2M6V29yaz48L3JkZjpSREY+PC9tZXRhZGF0YT48ZGVmc1xcbiAgICAgaWQ9XFxcImRlZnM0M1xcXCIgLz48c29kaXBvZGk6bmFtZWR2aWV3XFxuICAgICBwYWdlY29sb3I9XFxcIiNmZmZmZmZcXFwiXFxuICAgICBib3JkZXJjb2xvcj1cXFwiIzY2NjY2NlxcXCJcXG4gICAgIGJvcmRlcm9wYWNpdHk9XFxcIjFcXFwiXFxuICAgICBvYmplY3R0b2xlcmFuY2U9XFxcIjEwXFxcIlxcbiAgICAgZ3JpZHRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBndWlkZXRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9XFxcIjJcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9XFxcIjE0MjJcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PVxcXCI4NjlcXFwiXFxuICAgICBpZD1cXFwibmFtZWR2aWV3NDFcXFwiXFxuICAgICBzaG93Z3JpZD1cXFwiZmFsc2VcXFwiXFxuICAgICBpbmtzY2FwZTp6b29tPVxcXCIwLjM4MDUzNTExXFxcIlxcbiAgICAgaW5rc2NhcGU6Y3g9XFxcIi00MDIuMjI2NzVcXFwiXFxuICAgICBpbmtzY2FwZTpjeT1cXFwiMjE5LjI2NjQ5XFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LXg9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3cteT1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPVxcXCJDYXBhXzFcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMTFcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMTNcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMTVcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMTdcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMTlcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMjFcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMjNcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMjVcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMjdcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMjlcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMzFcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMzNcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMzVcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMzdcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnMzlcXFwiIC8+PGNpcmNsZVxcbiAgICAgc3R5bGU9XFxcIm9wYWNpdHk6MTtmaWxsOm5vbmU7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiNmZmZmZmY7c3Ryb2tlLXdpZHRoOjQ1O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDozLjI3NTkwMDEzO3N0cm9rZS1vcGFjaXR5OjFcXFwiXFxuICAgICBpZD1cXFwicGF0aDQyMThcXFwiXFxuICAgICBjeD1cXFwiMjY2LjkzNzEzXFxcIlxcbiAgICAgY3k9XFxcIjI2Ni40MjU2M1xcXCJcXG4gICAgIHI9XFxcIjE1MS40NDI1NFxcXCIgLz48cmVjdFxcbiAgICAgc3R5bGU9XFxcIm9wYWNpdHk6MTtmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM1O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDozLjI3NTkwMDEzO3N0cm9rZS1vcGFjaXR5OjFcXFwiXFxuICAgICBpZD1cXFwicmVjdDQ4MjFcXFwiXFxuICAgICB3aWR0aD1cXFwiOTkuODU5MzgzXFxcIlxcbiAgICAgaGVpZ2h0PVxcXCI5OS44NTkzODNcXFwiXFxuICAgICB4PVxcXCIyLjM5NTE0OTJcXFwiXFxuICAgICB5PVxcXCIwLjcwMDMyMzFcXFwiIC8+PC9zdmc+XCIsXG4gICAgXCJydWxlclwiOiBcIjw/eG1sIHZlcnNpb249XFxcIjEuMFxcXCIgZW5jb2Rpbmc9XFxcIlVURi04XFxcIiBzdGFuZGFsb25lPVxcXCJub1xcXCI/PlxcbjxzdmdcXG4gICB4bWxuczpkYz1cXFwiaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS9cXFwiXFxuICAgeG1sbnM6Y2M9XFxcImh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zI1xcXCJcXG4gICB4bWxuczpyZGY9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyNcXFwiXFxuICAgeG1sbnM6c3ZnPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgeG1sbnM6c29kaXBvZGk9XFxcImh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkXFxcIlxcbiAgIHhtbG5zOmlua3NjYXBlPVxcXCJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlXFxcIlxcbiAgIGlkPVxcXCJzdmcyXFxcIlxcbiAgIHZlcnNpb249XFxcIjEuMVxcXCJcXG4gICBpbmtzY2FwZTp2ZXJzaW9uPVxcXCIwLjkxIHIxMzcyNVxcXCJcXG4gICBzb2RpcG9kaTpkb2NuYW1lPVxcXCJydWxlci5zdmdcXFwiXFxuICAgd2lkdGg9XFxcIjE1MzZcXFwiXFxuICAgaGVpZ2h0PVxcXCIxNTM2XFxcIj5cXG4gIDxtZXRhZGF0YVxcbiAgICAgaWQ9XFxcIm1ldGFkYXRhMTBcXFwiPlxcbiAgICA8cmRmOlJERj5cXG4gICAgICA8Y2M6V29ya1xcbiAgICAgICAgIHJkZjphYm91dD1cXFwiXFxcIj5cXG4gICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PlxcbiAgICAgICAgPGRjOnR5cGVcXG4gICAgICAgICAgIHJkZjpyZXNvdXJjZT1cXFwiaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2VcXFwiIC8+XFxuICAgICAgICA8ZGM6dGl0bGUgLz5cXG4gICAgICA8L2NjOldvcms+XFxuICAgIDwvcmRmOlJERj5cXG4gIDwvbWV0YWRhdGE+XFxuICA8ZGVmc1xcbiAgICAgaWQ9XFxcImRlZnM4XFxcIiAvPlxcbiAgPHNvZGlwb2RpOm5hbWVkdmlld1xcbiAgICAgcGFnZWNvbG9yPVxcXCIjZmZmZmZmXFxcIlxcbiAgICAgYm9yZGVyY29sb3I9XFxcIiM2NjY2NjZcXFwiXFxuICAgICBib3JkZXJvcGFjaXR5PVxcXCIxXFxcIlxcbiAgICAgb2JqZWN0dG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGdyaWR0b2xlcmFuY2U9XFxcIjEwXFxcIlxcbiAgICAgZ3VpZGV0b2xlcmFuY2U9XFxcIjEwXFxcIlxcbiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PVxcXCIyXFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPVxcXCIxNjcyXFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD1cXFwiMTEzMlxcXCJcXG4gICAgIGlkPVxcXCJuYW1lZHZpZXc2XFxcIlxcbiAgICAgc2hvd2dyaWQ9XFxcImZhbHNlXFxcIlxcbiAgICAgZml0LW1hcmdpbi10b3A9XFxcIjBcXFwiXFxuICAgICBmaXQtbWFyZ2luLWxlZnQ9XFxcIjBcXFwiXFxuICAgICBmaXQtbWFyZ2luLXJpZ2h0PVxcXCIwXFxcIlxcbiAgICAgZml0LW1hcmdpbi1ib3R0b209XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTp6b29tPVxcXCIwLjQzNzA2NTU4XFxcIlxcbiAgICAgaW5rc2NhcGU6Y3g9XFxcIjg2NS4wNTI4OVxcXCJcXG4gICAgIGlua3NjYXBlOmN5PVxcXCIxMDAzLjkyOTJcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3cteD1cXFwiNThcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3cteT1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPVxcXCJzdmcyXFxcIiAvPlxcbiAgPHBhdGhcXG4gICAgIHN0eWxlPVxcXCJjb2xvcjojMDAwMDAwO2NsaXAtcnVsZTpub256ZXJvO2Rpc3BsYXk6aW5saW5lO292ZXJmbG93OnZpc2libGU7dmlzaWJpbGl0eTp2aXNpYmxlO29wYWNpdHk6MTtpc29sYXRpb246YXV0bzttaXgtYmxlbmQtbW9kZTpub3JtYWw7Y29sb3ItaW50ZXJwb2xhdGlvbjpzUkdCO2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVyczpsaW5lYXJSR0I7c29saWQtY29sb3I6IzAwMDAwMDtzb2xpZC1vcGFjaXR5OjE7ZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDowLjk1ODYwODY5O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTo1Ljc1MTY1MjMxLCA1Ljc1MTY1MjMxO3N0cm9rZS1kYXNob2Zmc2V0OjA7c3Ryb2tlLW9wYWNpdHk6MTttYXJrZXI6bm9uZTtjb2xvci1yZW5kZXJpbmc6YXV0bztpbWFnZS1yZW5kZXJpbmc6YXV0bztzaGFwZS1yZW5kZXJpbmc6YXV0bzt0ZXh0LXJlbmRlcmluZzphdXRvO2VuYWJsZS1iYWNrZ3JvdW5kOmFjY3VtdWxhdGVcXFwiXFxuICAgICBkPVxcXCJNIDIuNzQwMjg1OCwxMTYxLjE0NjQgMzc0Ljg1MzU2LDE1MzMuMjU5NyAxNTMzLjI1OTcsMzc0Ljg1MzU4IDExNjEuMTQ2NSwyLjc0MDMwNjkgMTA0NC41NTYyLDExOS4zMzA2MSAxMjYxLjk4NDksMzM2Ljc1OTQzIDEyMTMuNTIzOCwzODUuMjIwNjUgOTk2LjA5NDkyLDE2Ny43OTE4MyA4NjMuMTg0NSwzMDAuNzAyMjQgOTkyLjEwNTg0LDQyOS42MjM1NyA5NDMuNjIyNDksNDc4LjEwNjg3IDgxNC43MDExOSwzNDkuMTg1NTUgNjgxLjgwMTEyLDQ4Mi4wODU2MSA4MTAuNzIyNDQsNjExLjAwNjkzIDc2Mi4yMzkxNyw2NTkuNDkwMjIgNjMzLjMxNzg0LDUzMC41Njg5IDUwMC40MDc0MSw2NjMuNDc5MzIgNzE3LjgzNjIzLDg4MC45MDgxNCA2NjkuMzc1MDgsOTI5LjM2OTI5IDQ1MS45NDYyNiw3MTEuOTQwNDggMzE5LjAzNTgxLDg0NC44NTA5MyA0NDcuOTU3MTMsOTczLjc3MjIyIDM5OS40NzI1MSwxMDIyLjI1NjkgMjcwLjU1MTE5LDg5My4zMzU1NSAxMzcuNjUzNzcsMTAyNi4yMzI5IDI2Ni41NzUxLDExNTUuMTU0MyAyMTguMDkwNDgsMTIwMy42Mzg5IDg5LjE2OTE2MiwxMDc0LjcxNzYgMi43NDAyODU4LDExNjEuMTQ2NCBaXFxcIlxcbiAgICAgaWQ9XFxcInJlY3Q0MTM3XFxcIlxcbiAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT1cXFwiMFxcXCIgLz5cXG48L3N2Zz5cXG5cIixcbiAgICBcInNob3dcIjogXCI8P3htbCB2ZXJzaW9uPVxcXCIxLjBcXFwiIGVuY29kaW5nPVxcXCJVVEYtOFxcXCIgc3RhbmRhbG9uZT1cXFwibm9cXFwiPz5cXG48c3ZnXFxuICAgeG1sbnM6ZGM9XFxcImh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvXFxcIlxcbiAgIHhtbG5zOmNjPVxcXCJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyNcXFwiXFxuICAgeG1sbnM6cmRmPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjXFxcIlxcbiAgIHhtbG5zOnN2Zz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgIHhtbG5zOnNvZGlwb2RpPVxcXCJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZFxcXCJcXG4gICB4bWxuczppbmtzY2FwZT1cXFwiaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZVxcXCJcXG4gICBpZD1cXFwic3ZnMlxcXCJcXG4gICB2ZXJzaW9uPVxcXCIxLjFcXFwiXFxuICAgaW5rc2NhcGU6dmVyc2lvbj1cXFwiMC45MSByMTM3MjVcXFwiXFxuICAgc29kaXBvZGk6ZG9jbmFtZT1cXFwic2hvdy5zdmdcXFwiXFxuICAgd2lkdGg9XFxcIjE1MzZcXFwiXFxuICAgaGVpZ2h0PVxcXCIxNTM2XFxcIj5cXG4gIDxtZXRhZGF0YVxcbiAgICAgaWQ9XFxcIm1ldGFkYXRhMTBcXFwiPlxcbiAgICA8cmRmOlJERj5cXG4gICAgICA8Y2M6V29ya1xcbiAgICAgICAgIHJkZjphYm91dD1cXFwiXFxcIj5cXG4gICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PlxcbiAgICAgICAgPGRjOnR5cGVcXG4gICAgICAgICAgIHJkZjpyZXNvdXJjZT1cXFwiaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2VcXFwiIC8+XFxuICAgICAgICA8ZGM6dGl0bGU+PC9kYzp0aXRsZT5cXG4gICAgICA8L2NjOldvcms+XFxuICAgIDwvcmRmOlJERj5cXG4gIDwvbWV0YWRhdGE+XFxuICA8ZGVmc1xcbiAgICAgaWQ9XFxcImRlZnM4XFxcIiAvPlxcbiAgPHNvZGlwb2RpOm5hbWVkdmlld1xcbiAgICAgcGFnZWNvbG9yPVxcXCIjZmZmZmZmXFxcIlxcbiAgICAgYm9yZGVyY29sb3I9XFxcIiM2NjY2NjZcXFwiXFxuICAgICBib3JkZXJvcGFjaXR5PVxcXCIxXFxcIlxcbiAgICAgb2JqZWN0dG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGdyaWR0b2xlcmFuY2U9XFxcIjEwXFxcIlxcbiAgICAgZ3VpZGV0b2xlcmFuY2U9XFxcIjEwXFxcIlxcbiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PVxcXCIyXFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPVxcXCIxNjcyXFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD1cXFwiMTEzMlxcXCJcXG4gICAgIGlkPVxcXCJuYW1lZHZpZXc2XFxcIlxcbiAgICAgc2hvd2dyaWQ9XFxcImZhbHNlXFxcIlxcbiAgICAgZml0LW1hcmdpbi10b3A9XFxcIjBcXFwiXFxuICAgICBmaXQtbWFyZ2luLWxlZnQ9XFxcIjBcXFwiXFxuICAgICBmaXQtbWFyZ2luLXJpZ2h0PVxcXCIwXFxcIlxcbiAgICAgZml0LW1hcmdpbi1ib3R0b209XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTp6b29tPVxcXCIwLjIzNTU1NTM0XFxcIlxcbiAgICAgaW5rc2NhcGU6Y3g9XFxcIjY0My40ODM2M1xcXCJcXG4gICAgIGlua3NjYXBlOmN5PVxcXCIzNzIuMDcyOTZcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3cteD1cXFwiMjBcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3cteT1cXFwiMjVcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj1cXFwic3ZnMlxcXCIgLz5cXG4gIDxlbGxpcHNlXFxuICAgICBzdHlsZT1cXFwib3BhY2l0eToxO2ZpbGw6bm9uZTtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6I2ZmZmZmZjtzdHJva2Utd2lkdGg6OTAuNzQ4O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDozLjI3NTkwMDEzO3N0cm9rZS1vcGFjaXR5OjFcXFwiXFxuICAgICBpZD1cXFwicGF0aDQxNThcXFwiXFxuICAgICBjeT1cXFwiLTc2OS4wMjU3XFxcIlxcbiAgICAgY3g9XFxcIi03NzIuNjY3MTFcXFwiXFxuICAgICB0cmFuc2Zvcm09XFxcInNjYWxlKC0xLC0xKVxcXCJcXG4gICAgIHJ4PVxcXCI2NTQuNzQ4MjlcXFwiXFxuICAgICByeT1cXFwiNjU3LjM4MzA2XFxcIiAvPlxcbiAgPHJlY3RcXG4gICAgIHN0eWxlPVxcXCJvcGFjaXR5OjE7ZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDo5MC43NDgwMDExO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDozLjI3NTkwMDEzO3N0cm9rZS1vcGFjaXR5OjFcXFwiXFxuICAgICBpZD1cXFwicmVjdDQxNThcXFwiXFxuICAgICB3aWR0aD1cXFwiOTcuNjQxNjAyXFxcIlxcbiAgICAgaGVpZ2h0PVxcXCI0MDcuNTQ3NTVcXFwiXFxuICAgICB4PVxcXCI3MTkuMTc5MlxcXCJcXG4gICAgIHk9XFxcIi05Ljc3NDk5NThcXFwiXFxuICAgICByeT1cXFwiMi40MDIzMDg3XFxcIiAvPlxcbiAgPHJlY3RcXG4gICAgIHN0eWxlPVxcXCJvcGFjaXR5OjE7ZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDo5MC43NDgwMDExO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDozLjI3NTkwMDEzO3N0cm9rZS1vcGFjaXR5OjFcXFwiXFxuICAgICBpZD1cXFwicmVjdDQxNTgtNVxcXCJcXG4gICAgIHdpZHRoPVxcXCI5Ny42NDE2MDJcXFwiXFxuICAgICBoZWlnaHQ9XFxcIjQwNy41NDc1NVxcXCJcXG4gICAgIHg9XFxcIjcxOS4xNzkyXFxcIlxcbiAgICAgeT1cXFwiMTE0MS40MzM2XFxcIlxcbiAgICAgcnk9XFxcIjIuNDAyMzA4N1xcXCIgLz5cXG4gIDxyZWN0XFxuICAgICBzdHlsZT1cXFwib3BhY2l0eToxO2ZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6OTAuNzQ4MDAxMTtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6My4yNzU5MDAxMztzdHJva2Utb3BhY2l0eToxXFxcIlxcbiAgICAgaWQ9XFxcInJlY3Q0MTU4LTBcXFwiXFxuICAgICB3aWR0aD1cXFwiOTcuNjQxNjAyXFxcIlxcbiAgICAgaGVpZ2h0PVxcXCI0MDcuNTQ3NTVcXFwiXFxuICAgICB4PVxcXCI3MTkuMTc5MlxcXCJcXG4gICAgIHk9XFxcIi0xNTQxLjAzOTJcXFwiXFxuICAgICByeT1cXFwiMi40MDIzMDg3XFxcIlxcbiAgICAgdHJhbnNmb3JtPVxcXCJtYXRyaXgoMCwxLC0xLDAsMCwwKVxcXCIgLz5cXG4gIDxyZWN0XFxuICAgICBzdHlsZT1cXFwib3BhY2l0eToxO2ZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6OTAuNzQ4MDAxMTtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6My4yNzU5MDAxMztzdHJva2Utb3BhY2l0eToxXFxcIlxcbiAgICAgaWQ9XFxcInJlY3Q0MTU4LTAtNVxcXCJcXG4gICAgIHdpZHRoPVxcXCI5Ny42NDE2MDJcXFwiXFxuICAgICBoZWlnaHQ9XFxcIjQwNy41NDc1NVxcXCJcXG4gICAgIHg9XFxcIjcxOS4xNzkyXFxcIlxcbiAgICAgeT1cXFwiLTQwNy41NDc1NVxcXCJcXG4gICAgIHJ5PVxcXCIyLjQwMjMwODdcXFwiXFxuICAgICB0cmFuc2Zvcm09XFxcIm1hdHJpeCgwLDEsLTEsMCwwLDApXFxcIiAvPlxcbjwvc3ZnPlxcblwiLFxuICAgIFwic3VuLW9cIjogXCI8P3htbCB2ZXJzaW9uPVxcXCIxLjBcXFwiIGVuY29kaW5nPVxcXCJVVEYtOFxcXCIgc3RhbmRhbG9uZT1cXFwibm9cXFwiPz5cXG48c3ZnXFxuICAgeG1sbnM6ZGM9XFxcImh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvXFxcIlxcbiAgIHhtbG5zOmNjPVxcXCJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyNcXFwiXFxuICAgeG1sbnM6cmRmPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjXFxcIlxcbiAgIHhtbG5zOnN2Zz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgIHhtbG5zOnNvZGlwb2RpPVxcXCJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZFxcXCJcXG4gICB4bWxuczppbmtzY2FwZT1cXFwiaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZVxcXCJcXG4gICB3aWR0aD1cXFwiMTc5MlxcXCJcXG4gICBoZWlnaHQ9XFxcIjE3OTJcXFwiXFxuICAgdmlld0JveD1cXFwiMCAwIDE3OTIgMTc5MlxcXCJcXG4gICBpZD1cXFwic3ZnMlxcXCJcXG4gICB2ZXJzaW9uPVxcXCIxLjFcXFwiXFxuICAgaW5rc2NhcGU6dmVyc2lvbj1cXFwiMC45MSByMTM3MjVcXFwiXFxuICAgc29kaXBvZGk6ZG9jbmFtZT1cXFwic3VuLW8uc3ZnXFxcIj5cXG4gIDxtZXRhZGF0YVxcbiAgICAgaWQ9XFxcIm1ldGFkYXRhMTBcXFwiPlxcbiAgICA8cmRmOlJERj5cXG4gICAgICA8Y2M6V29ya1xcbiAgICAgICAgIHJkZjphYm91dD1cXFwiXFxcIj5cXG4gICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PlxcbiAgICAgICAgPGRjOnR5cGVcXG4gICAgICAgICAgIHJkZjpyZXNvdXJjZT1cXFwiaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2VcXFwiIC8+XFxuICAgICAgPC9jYzpXb3JrPlxcbiAgICA8L3JkZjpSREY+XFxuICA8L21ldGFkYXRhPlxcbiAgPGRlZnNcXG4gICAgIGlkPVxcXCJkZWZzOFxcXCIgLz5cXG4gIDxzb2RpcG9kaTpuYW1lZHZpZXdcXG4gICAgIHBhZ2Vjb2xvcj1cXFwiI2ZmZmZmZlxcXCJcXG4gICAgIGJvcmRlcmNvbG9yPVxcXCIjNjY2NjY2XFxcIlxcbiAgICAgYm9yZGVyb3BhY2l0eT1cXFwiMVxcXCJcXG4gICAgIG9iamVjdHRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBncmlkdG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGd1aWRldG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz1cXFwiMlxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD1cXFwiNzcxXFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD1cXFwiNDgwXFxcIlxcbiAgICAgaWQ9XFxcIm5hbWVkdmlldzZcXFwiXFxuICAgICBzaG93Z3JpZD1cXFwiZmFsc2VcXFwiXFxuICAgICBpbmtzY2FwZTp6b29tPVxcXCIwLjEzMTY5NjQzXFxcIlxcbiAgICAgaW5rc2NhcGU6Y3g9XFxcIjg5NlxcXCJcXG4gICAgIGlua3NjYXBlOmN5PVxcXCI4OTZcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3cteD1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy15PVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LW1heGltaXplZD1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9XFxcInN2ZzJcXFwiIC8+XFxuICA8cGF0aFxcbiAgICAgZD1cXFwiTTE0NzIgODk2cTAtMTE3LTQ1LjUtMjIzLjV0LTEyMy0xODQtMTg0LTEyMy0yMjMuNS00NS41LTIyMy41IDQ1LjUtMTg0IDEyMy0xMjMgMTg0LTQ1LjUgMjIzLjUgNDUuNSAyMjMuNSAxMjMgMTg0IDE4NCAxMjMgMjIzLjUgNDUuNSAyMjMuNS00NS41IDE4NC0xMjMgMTIzLTE4NCA0NS41LTIyMy41em0yNzYgMjc3cS00IDE1LTIwIDIwbC0yOTIgOTZ2MzA2cTAgMTYtMTMgMjYtMTUgMTAtMjkgNGwtMjkyLTk0LTE4MCAyNDhxLTEwIDEzLTI2IDEzdC0yNi0xM2wtMTgwLTI0OC0yOTIgOTRxLTE0IDYtMjktNC0xMy0xMC0xMy0yNnYtMzA2bC0yOTItOTZxLTE2LTUtMjAtMjAtNS0xNyA0LTI5bDE4MC0yNDgtMTgwLTI0OHEtOS0xMy00LTI5IDQtMTUgMjAtMjBsMjkyLTk2di0zMDZxMC0xNiAxMy0yNiAxNS0xMCAyOS00bDI5MiA5NCAxODAtMjQ4cTktMTIgMjYtMTJ0MjYgMTJsMTgwIDI0OCAyOTItOTRxMTQtNiAyOSA0IDEzIDEwIDEzIDI2djMwNmwyOTIgOTZxMTYgNSAyMCAyMCA1IDE2LTQgMjlsLTE4MCAyNDggMTgwIDI0OHE5IDEyIDQgMjl6XFxcIlxcbiAgICAgaWQ9XFxcInBhdGg0XFxcIlxcbiAgICAgc3R5bGU9XFxcImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MVxcXCIgLz5cXG48L3N2Zz5cXG5cIixcbiAgICBcInRpbWVzLWNpcmNsZVwiOiBcIjw/eG1sIHZlcnNpb249XFxcIjEuMFxcXCIgZW5jb2Rpbmc9XFxcIlVURi04XFxcIiBzdGFuZGFsb25lPVxcXCJub1xcXCI/PlxcbjxzdmdcXG4gICB4bWxuczpkYz1cXFwiaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS9cXFwiXFxuICAgeG1sbnM6Y2M9XFxcImh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zI1xcXCJcXG4gICB4bWxuczpyZGY9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyNcXFwiXFxuICAgeG1sbnM6c3ZnPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgeG1sbnM6c29kaXBvZGk9XFxcImh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkXFxcIlxcbiAgIHhtbG5zOmlua3NjYXBlPVxcXCJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlXFxcIlxcbiAgIGlkPVxcXCJzdmcyXFxcIlxcbiAgIHZlcnNpb249XFxcIjEuMVxcXCJcXG4gICBpbmtzY2FwZTp2ZXJzaW9uPVxcXCIwLjkxIHIxMzcyNVxcXCJcXG4gICBzb2RpcG9kaTpkb2NuYW1lPVxcXCJ0aW1lcy1jaXJjbGUuc3ZnXFxcIlxcbiAgIHdpZHRoPVxcXCIxNTM2XFxcIlxcbiAgIGhlaWdodD1cXFwiMTUzNlxcXCI+XFxuICA8bWV0YWRhdGFcXG4gICAgIGlkPVxcXCJtZXRhZGF0YTEwXFxcIj5cXG4gICAgPHJkZjpSREY+XFxuICAgICAgPGNjOldvcmtcXG4gICAgICAgICByZGY6YWJvdXQ9XFxcIlxcXCI+XFxuICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD5cXG4gICAgICAgIDxkYzp0eXBlXFxuICAgICAgICAgICByZGY6cmVzb3VyY2U9XFxcImh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlXFxcIiAvPlxcbiAgICAgICAgPGRjOnRpdGxlPjwvZGM6dGl0bGU+XFxuICAgICAgPC9jYzpXb3JrPlxcbiAgICA8L3JkZjpSREY+XFxuICA8L21ldGFkYXRhPlxcbiAgPGRlZnNcXG4gICAgIGlkPVxcXCJkZWZzOFxcXCIgLz5cXG4gIDxzb2RpcG9kaTpuYW1lZHZpZXdcXG4gICAgIHBhZ2Vjb2xvcj1cXFwiI2ZmZmZmZlxcXCJcXG4gICAgIGJvcmRlcmNvbG9yPVxcXCIjNjY2NjY2XFxcIlxcbiAgICAgYm9yZGVyb3BhY2l0eT1cXFwiMVxcXCJcXG4gICAgIG9iamVjdHRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBncmlkdG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGd1aWRldG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz1cXFwiMlxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD1cXFwiMTQyMVxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9XFxcIjkyN1xcXCJcXG4gICAgIGlkPVxcXCJuYW1lZHZpZXc2XFxcIlxcbiAgICAgc2hvd2dyaWQ9XFxcImZhbHNlXFxcIlxcbiAgICAgZml0LW1hcmdpbi10b3A9XFxcIjBcXFwiXFxuICAgICBmaXQtbWFyZ2luLWxlZnQ9XFxcIjBcXFwiXFxuICAgICBmaXQtbWFyZ2luLXJpZ2h0PVxcXCIwXFxcIlxcbiAgICAgZml0LW1hcmdpbi1ib3R0b209XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTp6b29tPVxcXCIwLjI0OTgzNTc4XFxcIlxcbiAgICAgaW5rc2NhcGU6Y3g9XFxcIjYwMy42OTk2NlxcXCJcXG4gICAgIGlua3NjYXBlOmN5PVxcXCI3MTcuNTc5MzJcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3cteD1cXFwiM1xcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy15PVxcXCI5NFxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPVxcXCJzdmcyXFxcIiAvPlxcbiAgPGNpcmNsZVxcbiAgICAgc3R5bGU9XFxcIm9wYWNpdHk6MTtmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjQ5LjIyNDA3MTU7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1kYXNob2Zmc2V0OjMuMjc1OTAwMTM7c3Ryb2tlLW9wYWNpdHk6MFxcXCJcXG4gICAgIGlkPVxcXCJwYXRoNDE2M1xcXCJcXG4gICAgIGN4PVxcXCI3NzEuMzY4NzdcXFwiXFxuICAgICBjeT1cXFwiNzY5LjU4MDA4XFxcIlxcbiAgICAgcj1cXFwiNzQxLjQ0Mjk5XFxcIiAvPlxcbiAgPHBhdGhcXG4gICAgIHN0eWxlPVxcXCJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjFcXFwiXFxuICAgICBkPVxcXCJtIDQ3Ni41NDc5Miw0MjUuOTcxNzEgcSAxMC4wNjYyMywtMTAuMDMxMTUgMzAuODMzODcsLTMuOTAzMTQgMjAuNzY3NjUsNi4xMjggMzkuMTIwMzEsMjQuNTQ0ODQgbCA1NDIuMTA5NCw1NDQuMDA0OTkgcSAxOC4zNTI2LDE4LjQxNjggMjQuNDA4MSwzOS4yMDU3IDYuMDU1NSwyMC43ODg5IC00LjAxMDcsMzAuODIwMSBsIC00OS41NTY4LDQ5LjM4NDEgcSAtMTAuMDY2MiwxMC4wMzExIC0zMC44MzM5LDMuOTAzMSAtMjAuNzY3NiwtNi4xMjggLTM5LjEyMDMsLTI0LjU0NDggTCA0NDcuMzg4NTQsNTQ1LjM4MTYgcSAtMTguMzUyNjYsLTE4LjQxNjg0IC0yNC40MDgxNCwtMzkuMjA1NzQgLTYuMDU1NDgsLTIwLjc4ODkxIDQuMDEwNzUsLTMwLjgyMDA2IGwgNDkuNTU2NzgsLTQ5LjM4NDEgelxcXCJcXG4gICAgIGlkPVxcXCJwYXRoNFxcXCJcXG4gICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9XFxcIjBcXFwiIC8+XFxuICA8cGF0aFxcbiAgICAgc3R5bGU9XFxcImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MVxcXCJcXG4gICAgIGQ9XFxcIm0gMTExMC4wMjgzLDQ3Ni41NDc5MSBxIDEwLjAzMTEsMTAuMDY2MjIgMy45MDMxLDMwLjgzMzg3IC02LjEyOCwyMC43Njc2NSAtMjQuNTQ0OCwzOS4xMjAzMSBMIDU0NS4zODE1OSwxMDg4LjYxMTUgcSAtMTguNDE2ODMsMTguMzUyNiAtMzkuMjA1NzQsMjQuNDA4MSAtMjAuNzg4OSw2LjA1NTUgLTMwLjgyMDA1LC00LjAxMDcgbCAtNDkuMzg0MDksLTQ5LjU1NjggcSAtMTAuMDMxMTUsLTEwLjA2NjIgLTMuOTAzMTYsLTMwLjgzMzkgNi4xMjgwMiwtMjAuNzY3NiAyNC41NDQ4NSwtMzkuMTIwMyBMIDk5MC42MTg0MSw0NDcuMzg4NTMgcSAxOC40MTY3OSwtMTguMzUyNjYgMzkuMjA1NjksLTI0LjQwODE1IDIwLjc4OSwtNi4wNTU0NyAzMC44MjAxLDQuMDEwNzYgbCA0OS4zODQxLDQ5LjU1Njc4IHpcXFwiXFxuICAgICBpZD1cXFwicGF0aDQtNlxcXCJcXG4gICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9XFxcIjBcXFwiIC8+XFxuPC9zdmc+XFxuXCIsXG4gICAgXCJ1bmRvXCI6IFwiPD94bWwgdmVyc2lvbj1cXFwiMS4wXFxcIiBlbmNvZGluZz1cXFwiVVRGLThcXFwiIHN0YW5kYWxvbmU9XFxcIm5vXFxcIj8+XFxuPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPlxcblxcbjxzdmdcXG4gICB4bWxuczpkYz1cXFwiaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS9cXFwiXFxuICAgeG1sbnM6Y2M9XFxcImh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zI1xcXCJcXG4gICB4bWxuczpyZGY9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyNcXFwiXFxuICAgeG1sbnM6c3ZnPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gICB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgeG1sbnM6c29kaXBvZGk9XFxcImh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkXFxcIlxcbiAgIHhtbG5zOmlua3NjYXBlPVxcXCJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlXFxcIlxcbiAgIHZlcnNpb249XFxcIjEuMVxcXCJcXG4gICBpZD1cXFwiQ2FwYV8xXFxcIlxcbiAgIHg9XFxcIjBweFxcXCJcXG4gICB5PVxcXCIwcHhcXFwiXFxuICAgd2lkdGg9XFxcIjQzOC41MzZweFxcXCJcXG4gICBoZWlnaHQ9XFxcIjQzOC41MzZweFxcXCJcXG4gICB2aWV3Qm94PVxcXCIwIDAgNDM4LjUzNiA0MzguNTM2XFxcIlxcbiAgIHN0eWxlPVxcXCJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDQzOC41MzYgNDM4LjUzNjtcXFwiXFxuICAgeG1sOnNwYWNlPVxcXCJwcmVzZXJ2ZVxcXCJcXG4gICBpbmtzY2FwZTp2ZXJzaW9uPVxcXCIwLjkxIHIxMzcyNVxcXCJcXG4gICBzb2RpcG9kaTpkb2NuYW1lPVxcXCJ1bmRvLnN2Z1xcXCI+PG1ldGFkYXRhXFxuICAgICBpZD1cXFwibWV0YWRhdGE0MVxcXCI+PHJkZjpSREY+PGNjOldvcmtcXG4gICAgICAgICByZGY6YWJvdXQ9XFxcIlxcXCI+PGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+PGRjOnR5cGVcXG4gICAgICAgICAgIHJkZjpyZXNvdXJjZT1cXFwiaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2VcXFwiIC8+PGRjOnRpdGxlIC8+PC9jYzpXb3JrPjwvcmRmOlJERj48L21ldGFkYXRhPjxkZWZzXFxuICAgICBpZD1cXFwiZGVmczM5XFxcIiAvPjxzb2RpcG9kaTpuYW1lZHZpZXdcXG4gICAgIHBhZ2Vjb2xvcj1cXFwiI2ZmZmZmZlxcXCJcXG4gICAgIGJvcmRlcmNvbG9yPVxcXCIjNjY2NjY2XFxcIlxcbiAgICAgYm9yZGVyb3BhY2l0eT1cXFwiMVxcXCJcXG4gICAgIG9iamVjdHRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBncmlkdG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGd1aWRldG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz1cXFwiMlxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD1cXFwiMTI1M1xcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9XFxcIjc4OVxcXCJcXG4gICAgIGlkPVxcXCJuYW1lZHZpZXczN1xcXCJcXG4gICAgIHNob3dncmlkPVxcXCJmYWxzZVxcXCJcXG4gICAgIGlua3NjYXBlOnpvb209XFxcIjAuNzYxMDY0OThcXFwiXFxuICAgICBpbmtzY2FwZTpjeD1cXFwiMjM5LjI5OFxcXCJcXG4gICAgIGlua3NjYXBlOmN5PVxcXCIyMjMuNzc2NzdcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3cteD1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy15PVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LW1heGltaXplZD1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9XFxcIkNhcGFfMVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImczXFxcIlxcbiAgICAgc3R5bGU9XFxcImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MVxcXCJcXG4gICAgIHRyYW5zZm9ybT1cXFwibWF0cml4KDAuNzc5NjYwNTEsMCwwLDAuNzc5NjYwNTEsNDguMzEzNzk0LDQ4LjMxMjYyNSlcXFwiPjxwYXRoXFxuICAgICAgIGQ9XFxcIk0gMzg4LjU0NDE0LDE0Ny45MjMwNCBDIDM3OC44MDk3MywxMjUuMjU1ODIgMzY1LjcyMDEsMTA1LjcwMjMxIDM0OS4yODE5Nyw4OS4yNjQxODIgMzMyLjg0MDQ4LDcyLjgyNTIwMiAzMTMuMjg3ODEsNTkuNzM4MDk2IDI5MC42MTk3NSw0OS45OTk0OTYgYyAtMjIuNjY1NTMsLTkuNzM4NiAtNDYuNDQ0NzMsLTE0LjYwNDEyNyAtNzEuMzQ1OTYsLTE0LjYwNDEyNyAtMjMuNDYyMiwwIC00Ni4xNjYzMSw0LjQyNTI2NCAtNjguMTE2NTMsMTMuMjg1ODU2IC0yMS45NDUxOCw4Ljg1ODkxNSAtNDEuNDU4NDUsMjEuMzQ4MTA3IC01OC41MzgxMDMsMzcuNDcwOTI3IEwgNjEuNDkwNTE3LDU1LjI2MjUxNyBDIDU2LjcwMTMwMyw1MC4zMTM5NjkgNTEuMTk2NzY3LDQ5LjE5NzggNDQuOTY5MzYzLDUxLjkwODk3NiAzOC41ODM0NjQsNTQuNjI2MDIzIDM1LjM5MDkzNCw1OS4zMzY0MSAzNS4zOTA5MzQsNjYuMDM5MzAyIGwgMCwxMDcuMjYyMTI4IGMgMCw0LjE0OTM3IDEuNTE3MDE4LDcuNzQxMDcgNC41NTAyMTUsMTAuNzczNDMgMy4wMzQ4NzQsMy4wMzMxOSA2LjYyNjU3NSw0LjU1MDIxIDEwLjc3NTk0Miw0LjU1MDIxIGwgMTA3LjI2MjEzOSwwIGMgNi43MDU0LDAgMTEuNDEzMjcsLTMuMTkyNTMgMTQuMTI2OTYsLTkuNTc3NTkgMi43MTIwMiwtNi4yMjQ4OSAxLjU5NTg1LC0xMS43MzAyNiAtMy4zNTM1NCwtMTYuNTIxMTUgbCAtMzIuODAxNjMsLTMzLjAzODk2IGMgMTEuMTc2NzksLTEwLjUzNTI2IDIzLjk0NDQsLTE4LjYzNTI1IDM4LjMwOTUyLC0yNC4zMDI0NyAxNC4zNjU5NywtNS42NjYzODggMjkuMzY4NDMsLTguNTAxNjc4IDQ1LjAxMTU4LC04LjUwMTY3OCAxNi41OTgzLDAgMzIuNDQyNzEsMy4yMzUzIDQ3LjUyNjUxLDkuNjk2NjY4IDE1LjA4NjMyLDYuNDY1NTcgMjguMTI5ODIsMTUuMjA0NTYgMzkuMTQ0NzcsMjYuMjE4NjcgMTEuMDE0MSwxMS4wMTE1OCAxOS43NTMwOSwyNC4wNTkyOCAyNi4yMTg2NiwzOS4xNDQ3NiA2LjQ1OTY5LDE1LjA4MzggOS42OTQxNSwzMC45MjMxOCA5LjY5NDE1LDQ3LjUyNjUyIDAsMTYuNjAyNSAtMy4yMzM2MiwzMi40NDE4NyAtOS42OTQxNSw0Ny41MjQ4NCAtNi40NjU1NywxNS4wODM4IC0xNS4yMDQ1NiwyOC4xMjk4MiAtMjYuMjE4NjYsMzkuMTQ0NzYgLTExLjAxNDk1LDExLjAxNDEgLTI0LjA2MzQ4LDE5Ljc1NTYxIC0zOS4xNDQ3NywyNi4yMTg2NiAtMTUuMDgzOCw2LjQ2MzA1IC0zMC45MjgyMSw5LjY5NSAtNDcuNTI2NTEsOS42OTUgLTE4Ljk5NTAxLDAgLTM2Ljk1MTg0LC00LjE1MDIxIC01My44NzIxNywtMTIuNDQ3MjYgLTE2LjkxNzgxLC04LjI5NzA2IC0zMS4yMDMyNywtMjAuMDI4MTYgLTQyLjg1NTU0LC0zNS4xOTgzNCAtMS4xMTYxNywtMS41OTUwMSAtMi45NTI2OSwtMi41NTQzNiAtNS41MDcwNSwtMi44NzU1NCAtMi4zOTUwMywwIC00LjM5MDg4LDAuNzE3IC01Ljk4NjczLDIuMTUxODMgTCA3OC4yNDk4MzcsMzI2LjUyNjEgYyAtMS4yNzU1MSwxLjI4MzA1IC0xLjk1MzkzLDIuOTE2NjMgLTIuMDM0NDQsNC45MDgzIC0wLjA3ODgsMi4wMDAwNCAwLjQ0MTk0LDMuNzkzOCAxLjU1ODExLDUuMzg5NjQgMTcuNDAwMDEsMjEuMDY5NyAzOC40NjcxODMsMzcuMzkwNDMgNjMuMjA3NDAzLDQ4Ljk1ODg0IDI0Ljc0MDIyLDExLjU3MDkzIDUwLjgzOTgxLDE3LjM1OTc1IDc4LjI5Mjg4LDE3LjM1OTc1IDI0LjkwMTIzLDAgNDguNjgwNDMsLTQuODcwNTYgNzEuMzQ1OTYsLTE0LjYwNDk3IDIyLjY2ODA2LC05LjczMzU2IDQyLjIxNDg2LC0yMi44MjY1NCA1OC42NTg4NywtMzkuMjYzODQgMTYuNDQwNjUsLTE2LjQ0NCAyOS41Mjc3NSwtMzUuOTkzMzIgMzkuMjY0NjgsLTU4LjY1ODg2IDkuNzM2OTIsLTIyLjY2NTU0IDE0LjYwMDc3LC00Ni40NTE0NCAxNC42MDA3NywtNzEuMzQ3NjQgOC40ZS00LC0yNC45MDQ1OCAtNC44NjYzNywtNDguNjc3OTEgLTE0LjU5OTkzLC03MS4zNDQyOCB6XFxcIlxcbiAgICAgICBpZD1cXFwicGF0aDVcXFwiXFxuICAgICAgIHN0eWxlPVxcXCJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjFcXFwiXFxuICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9XFxcIjBcXFwiIC8+PC9nPjxnXFxuICAgICBpZD1cXFwiZzdcXFwiIC8+PGdcXG4gICAgIGlkPVxcXCJnOVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcxMVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcxM1xcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcxNVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcxN1xcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcxOVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcyMVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcyM1xcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcyNVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcyN1xcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcyOVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImczMVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImczM1xcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImczNVxcXCIgLz48L3N2Zz5cIixcbiAgICBcInVwbG9hZFwiOiBcIjw/eG1sIHZlcnNpb249XFxcIjEuMFxcXCIgZW5jb2Rpbmc9XFxcIlVURi04XFxcIiBzdGFuZGFsb25lPVxcXCJub1xcXCI/PlxcbjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxNi4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT5cXG5cXG48c3ZnXFxuICAgeG1sbnM6ZGM9XFxcImh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvXFxcIlxcbiAgIHhtbG5zOmNjPVxcXCJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyNcXFwiXFxuICAgeG1sbnM6cmRmPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjXFxcIlxcbiAgIHhtbG5zOnN2Zz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICAgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgIHhtbG5zOnNvZGlwb2RpPVxcXCJodHRwOi8vc29kaXBvZGkuc291cmNlZm9yZ2UubmV0L0RURC9zb2RpcG9kaS0wLmR0ZFxcXCJcXG4gICB4bWxuczppbmtzY2FwZT1cXFwiaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZVxcXCJcXG4gICB2ZXJzaW9uPVxcXCIxLjFcXFwiXFxuICAgaWQ9XFxcIkNhcGFfMVxcXCJcXG4gICB4PVxcXCIwcHhcXFwiXFxuICAgeT1cXFwiMHB4XFxcIlxcbiAgIHdpZHRoPVxcXCI0MzguNTMzcHhcXFwiXFxuICAgaGVpZ2h0PVxcXCI0MzguNTMzcHhcXFwiXFxuICAgdmlld0JveD1cXFwiMCAwIDQzOC41MzMgNDM4LjUzM1xcXCJcXG4gICBzdHlsZT1cXFwiZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0MzguNTMzIDQzOC41MzM7XFxcIlxcbiAgIHhtbDpzcGFjZT1cXFwicHJlc2VydmVcXFwiXFxuICAgaW5rc2NhcGU6dmVyc2lvbj1cXFwiMC45MSByMTM3MjVcXFwiXFxuICAgc29kaXBvZGk6ZG9jbmFtZT1cXFwidXBsb2FkLnN2Z1xcXCI+PG1ldGFkYXRhXFxuICAgICBpZD1cXFwibWV0YWRhdGE0NVxcXCI+PHJkZjpSREY+PGNjOldvcmtcXG4gICAgICAgICByZGY6YWJvdXQ9XFxcIlxcXCI+PGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+PGRjOnR5cGVcXG4gICAgICAgICAgIHJkZjpyZXNvdXJjZT1cXFwiaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2VcXFwiIC8+PGRjOnRpdGxlIC8+PC9jYzpXb3JrPjwvcmRmOlJERj48L21ldGFkYXRhPjxkZWZzXFxuICAgICBpZD1cXFwiZGVmczQzXFxcIiAvPjxzb2RpcG9kaTpuYW1lZHZpZXdcXG4gICAgIHBhZ2Vjb2xvcj1cXFwiI2ZmZmZmZlxcXCJcXG4gICAgIGJvcmRlcmNvbG9yPVxcXCIjNjY2NjY2XFxcIlxcbiAgICAgYm9yZGVyb3BhY2l0eT1cXFwiMVxcXCJcXG4gICAgIG9iamVjdHRvbGVyYW5jZT1cXFwiMTBcXFwiXFxuICAgICBncmlkdG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGd1aWRldG9sZXJhbmNlPVxcXCIxMFxcXCJcXG4gICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PVxcXCIwXFxcIlxcbiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz1cXFwiMlxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD1cXFwiMTUyMFxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9XFxcIjkzMVxcXCJcXG4gICAgIGlkPVxcXCJuYW1lZHZpZXc0MVxcXCJcXG4gICAgIHNob3dncmlkPVxcXCJmYWxzZVxcXCJcXG4gICAgIGlua3NjYXBlOnpvb209XFxcIjAuMTM0NTM5NDhcXFwiXFxuICAgICBpbmtzY2FwZTpjeD1cXFwiLTQzNS4xNzM0OVxcXCJcXG4gICAgIGlua3NjYXBlOmN5PVxcXCItOTY5Ljk3NTUyXFxcIlxcbiAgICAgaW5rc2NhcGU6d2luZG93LXg9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTp3aW5kb3cteT1cXFwiMFxcXCJcXG4gICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9XFxcIjBcXFwiXFxuICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPVxcXCJDYXBhXzFcXFwiIC8+PHBhdGhcXG4gICAgIGQ9XFxcIm0gMTI2LjI4OTQ1LDE0OC41MDM3IDU1LjcxNDc2LDAgMCwxMDUuNjE0MzQgYyAwLDIuODAxNTUgMC44NzYxNyw1LjA5OTc2IDIuNjE1MzMsNi45MDA5MSAxLjczMjAyLDEuNzk1OSAzLjk1OTA4LDIuNjk4NTggNi42NjQ4NiwyLjY5ODU4IGwgNTUuNzI0OSwwIGMgMi43MDc4MywwIDQuOTMzODUsLTAuOTAyNjggNi42NzUwNCwtMi42OTg1OCAxLjc0MjE5LC0xLjgwMjIgMi42MTIyNywtNC4wOTkzNiAyLjYxMjI3LC02LjkwMDkxIGwgMCwtMTA1LjYxMDE0IDU1LjcyMDg0LDAgYyA0LjI1NDg3LDAgNy4xNTc4NCwtMi4wMDE4NiA4LjcwNjkyLC01Ljk5OTI4IDEuNTQ5MDcsLTMuODA1MTIgMC44NjgwNSwtNy4zMDAyNCAtMi4wMzE4OCwtMTAuNTA0MjcgTCAyMjUuODI2NDUsMzUuOTk3OTA1IGMgLTIuMTMwNDYsLTEuNzk4IC00LjM1MzQ1LC0yLjY5NzUzIC02LjY3NTAyLC0yLjY5NzUzIC0yLjMxODU0LDAgLTQuNTQ0NTYsMC44OTk1MyAtNi42NzcwNiwyLjY5NzUzIGwgLTkyLjU3NTM0LDk1LjcwMzgwNSBjIC0xLjkzMzI5LDIuMzk5MDggLTIuODk3OSw0LjgwODY3IC0yLjg5NzksNy4yMDA0IDAsMi43OTczNiAwLjg2OTA3LDUuMDk5NzYgMi42MTUzNCw2LjkwNDA3IDEuNzM3MTEsMS43OTkwNSAzLjk2MzEzLDIuNjk3NTIgNi42NzI5OCwyLjY5NzUyIHpcXFwiXFxuICAgICBpZD1cXFwicGF0aDlcXFwiXFxuICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPVxcXCIwXFxcIlxcbiAgICAgc3R5bGU9XFxcImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcxMVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcxM1xcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcxNVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcxN1xcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcxOVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcyMVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcyM1xcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcyNVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcyN1xcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImcyOVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImczMVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImczM1xcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImczNVxcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImczN1xcXCIgLz48Z1xcbiAgICAgaWQ9XFxcImczOVxcXCIgLz48cGF0aFxcbiAgICAgc3R5bGU9XFxcIm9wYWNpdHk6MTtmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjM1O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDozLjI3NTkwMDEzO3N0cm9rZS1vcGFjaXR5OjFcXFwiXFxuICAgICBkPVxcXCJtIDM2LjIzNTI0NCwzMDUuODE0NDUgMCw5OC40ODQzOCAzNjYuMDYyNTA2LDAgMCwtOTguNDg0MzggLTQyLjczODI4LDAgMCw1NS43NDYxIC0yODAuNTg1OTQ1LDAgMCwtNTUuNzQ2MSB6XFxcIlxcbiAgICAgaWQ9XFxcInJlY3Q0MTUwXFxcIlxcbiAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT1cXFwiMFxcXCJcXG4gICAgIHNvZGlwb2RpOm5vZGV0eXBlcz1cXFwiY2NjY2NjY2NjXFxcIiAvPjwvc3ZnPlwiXG4gIH1cbn07XG4iLCIvKiEgQXRsYXNNYWtlciAqL1xuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuaW1wb3J0ICdmYXN0LWpzb24tcGF0Y2gnO1xuaW1wb3J0ICogYXMgU3RydWN0IGZyb20gJy4uLy4uL2Rvd25sb2Fkcy9zdHJ1Y3QuanMnO1xuXG5pbXBvcnQge0F0bGFzTWFrZXJEcmF3fSBmcm9tICcuL2F0bGFzTWFrZXItZHJhdy5qcyc7XG5pbXBvcnQge0F0bGFzTWFrZXJJbnRlcmFjdGlvbn0gZnJvbSAnLi9hdGxhc01ha2VyLWludGVyYWN0aW9uLmpzJztcbmltcG9ydCB7QXRsYXNNYWtlcklPfSBmcm9tICcuL2F0bGFzTWFrZXItaW8uanMnO1xuaW1wb3J0IHtBdGxhc01ha2VyUGFpbnR9IGZyb20gJy4vYXRsYXNNYWtlci1wYWludC5qcyc7XG5pbXBvcnQge0F0bGFzTWFrZXJVSX0gZnJvbSAnLi9hdGxhc01ha2VyLXVpLmpzJztcbmltcG9ydCB7QXRsYXNNYWtlcldTfSBmcm9tICcuL2F0bGFzTWFrZXItd3MuanMnO1xuXG5pbXBvcnQge0F0bGFzTWFrZXJSZXNvdXJjZXN9IGZyb20gJy4uLy4uL2Rpc3QvYXRsYXNNYWtlci1yZXNvdXJjZXMuanMnO1xuXG4vKipcbiAqIEBwYWdlIEF0bGFzTWFrZXJcbiAqL1xuZXhwb3J0IHZhciBBdGxhc01ha2VyV2lkZ2V0ID0ge1xuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEdsb2JhbHNcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBkZWJ1ZzogICAgICAgICAgICAxLFxuICAgIGhvc3RuYW1lOiAnaHR0cDovL2xvY2FsaG9zdDozMDAxJywgLy8gJycsIC8vICdodHRwOi8vYnJhaW5ib3gucGFzdGV1ci5mcicsXG4gICAgd3Nob3N0bmFtZTogJ3dzOi8vbG9jYWxob3N0OjgwODAnLCAvLyAnd3M6Ly9icmFpbmJveC5wYXN0ZXVyLmZyOjgwODAnLFxuICAgIGNvbnRhaW5lcjogICAgICAgIG51bGwsICAgIC8vIEVsZW1lbnQgd2hlcmUgYXRsYXNNYWtlciBsaXZlc1xuICAgIGJyYWluX29mZmNuOiAgICBudWxsLFxuICAgIGJyYWluX29mZnR4OiAgICBudWxsLFxuICAgIGNhbnZhczogICAgICAgICAgICBudWxsLFxuICAgIGNvbnRleHQ6ICAgICAgICBudWxsLFxuICAgIGJyYWluX3B4OiAgICAgICAgbnVsbCxcbiAgICBicmFpbl9XOiAgICAgICAgbnVsbCxcbiAgICBicmFpbl9IOiAgICAgICAgbnVsbCxcbiAgICBicmFpbl9EOiAgICAgICAgbnVsbCxcbiAgICBicmFpbl9XZGltOiAgICAgICAgbnVsbCxcbiAgICBicmFpbl9IZGltOiAgICAgICAgbnVsbCxcbiAgICBtYXg6ICAgICAgICAgICAgMCxcbiAgICAvKlxuICAgICAgICB7RklYOiBUUlkgVE8gS0VFUCBBTEwgM0QgU1RVRkYgSU5TSURFIFVzZXJzXG4gICAgKi9cbiAgICBicmFpbl9kaW06ICAgICAgICBuZXcgQXJyYXkoMyksXG4gICAgYnJhaW5fcGl4ZGltOiAgICBuZXcgQXJyYXkoMyksXG4gICAgYnJhaW5fZGF0YXR5cGU6ICAgIG51bGwsXG4gICAgLypcbiAgICAgICAgfVxuICAgICovXG4gICAgYnJhaW5faW1nOiAgICAgIHsgICAgIGltZzogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2U6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICBicmFpbjogICAgICAgICAgICAwLFxuICAgIGFscGhhTGV2ZWw6ICAgICAgICAwLjUsXG4gICAgYW5ub3RhdGlvbkxlbmd0aDowLFxuICAgIG1lYXN1cmVMZW5ndGg6ICAgIG51bGwsXG4gICAgVXNlcjogICAgICAgICAgICB7ICB2aWV3Om51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgIHRvb2w6J3Nob3cnLFxuICAgICAgICAgICAgICAgICAgICAgIHNsaWNlOm51bGwsXG4gICAgICAgICAgICAgICAgICAgIHBlblNpemU6MSxcbiAgICAgICAgICAgICAgICAgICBwZW5WYWx1ZToxLFxuICAgICAgICAgICAgICAgICAgICAgZG9GaWxsOmZhbHNlLFxuICAgICAgICAgICAgICAgIG1vdXNlSXNEb3duOmZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHgwOi0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHkwOi0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXJpOm5ldyBPYmplY3QoKVxuICAgICAgICAgICAgfSxcbiAgICBDb2xsYWI6ICAgICAgICAgICAgICAgICBbXSxcbiAgICBhdGxhczogICAgICAgICAgICAgICAgIG51bGwsXG4gICAgYXRsYXNfb2ZmY246ICAgICAgICAgbnVsbCxcbiAgICBhdGxhc19vZmZ0eDogICAgICAgICBudWxsLCAgICBcbiAgICBhdGxhc19weDogICAgICAgICAgICAgbnVsbCxcbiAgICBuYW1lOiAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICB1cmw6ICAgICAgICAgICAgICAgICBudWxsLFxuICAgIGF0bGFzRmlsZW5hbWU6ICAgICAgICAgbnVsbCxcbiAgICBzb2NrZXQ6ICAgICAgICAgICAgICAgICBudWxsLFxuICAgIHJlY2VpdmVGdW5jdGlvbnM6ICAgIFtdLFxuICAgIHNlbmRGdW5jdGlvbnM6ICAgICAgIFtdLFxuICAgIGZsYWdDb25uZWN0ZWQ6ICAgICAgICAgMCxcbiAgICByZWNvbm5lY3Rpb25UaW1lb3V0OiA1LCAvLyByZWNvbm5lY3Rpb24gdGltZW91dCBzdGFydHMgYXQgNSBzZWNvbmRzXG4gICAgZmxhZ0xvYWRpbmdJbWc6ICAgICAge2xvYWRpbmc6ZmFsc2V9LFxuICAgIGZsYWdVc2VQcmVjaXNlQ3Vyc29yOiBmYWxzZSxcbiAgICBtc2c6ICAgICAgICAgICAgICAgICBudWxsLFxuICAgIG1zZzA6ICAgICAgICAgICAgICAgICBcIlwiLFxuICAgIHByZXZEYXRhOiAgICAgICAgICAgICAwLFxuICAgIENyc3I6ICAgICAgICAgICAgeyB4OnVuZGVmaW5lZCwgICAgICAgICAgICAvLyBjdXJzb3IgeCBjb29yZFxuICAgICAgICAgICAgICAgICAgICAgICB5OnVuZGVmaW5lZCwgICAgICAgICAgICAvLyBjdXJzb3IgeSBjb29yZFxuICAgICAgICAgICAgICAgICAgICAgICBmeDp1bmRlZmluZWQsICAgICAgICAvLyBmaW5nZXIgeCBjb29yZFxuICAgICAgICAgICAgICAgICAgICAgICBmeTp1bmRlZmluZWQsICAgICAgICAvLyBmaW5nZXIgeSBjb29yZFxuICAgICAgICAgICAgICAgICAgICAgICB4MDp1bmRlZmluZWQsICAgICAgICAvLyBwcmV2aW91cyBmaW5nZXIgeCBjb29yZFxuICAgICAgICAgICAgICAgICAgICAgICB5MDp1bmRlZmluZWQsICAgICAgICAvLyBwcmV2aW91cyBmaW5nZXIgeSBjb29yZFxuICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWRYOnVuZGVmaW5lZCwgICAgLy8gZmluZ2VyIHggY29vcmQgYXQgdG91Y2ggc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkWTp1bmRlZmluZWQsICAgIC8vIGZpbmdlciB5IGNvb3JkIGF0IHRvdWNoIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOlwibW92ZVwiLCAgICAgICAgLy8gY3Vyc29yIHN0YXRlOiBtb3ZlLCBkcmF3LCBjb25maWd1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgcHJldlN0YXRlOnVuZGVmaW5lZCwgICAgLy8gc3RhdGUgYmVmb3JlIGNvbmZpZ3VyZVxuICAgICAgICAgICAgICAgICAgICAgICB0b3VjaFN0YXJ0ZWQ6ZmFsc2UgICAgLy8gdG91Y2ggc3RhcnRlZCBmbGFnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgZWRpdE1vZGU6ICAgICAgICAwLCAgICAvLyBlZGl0TW9kZT0wIHRvIHByZXZlbnQgZWRpdGluZywgZWRpdE1vZGU9MSB0byBhY2NlcHQgaXRcbiAgICBmdWxsc2NyZWVuOiAgICAgICAgZmFsc2UsICAgIC8vIGZ1bGxzY3JlZW4gbW9kZVxuICAgIGluZm86e30sICAgIC8vIGluZm9ybWF0aW9uIGRpc3BsYXllZCBvdmVyIGVhY2ggYnJhaW4gc2xpY2VcbiAgICAvLyB1bmRvIHN0YWNrXG4gICAgLyogREVQUkVDQVRFRCBVbmRvOltdLCAqL1xuICAgIHZlcnNpb246ICAgIDEsIC8vIHZlcnNpb24gb2YgdGhlIGNvbmZpZ3VyYXRpb24gZmlsZSAoc2xpY2UgbnVtYmVyLCBwbGFuZSwgZXRjKS4gRGVmYXVsdD0xXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gdHJhY2VMb2dcbiAgICAgKi9cbiAgICB0cmFjZUxvZzogZnVuY3Rpb24gdHJhY2VMb2coZixsLGMpIHtcbiAgICAvKlxuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgaWYobWUuZGVidWcgJiYgKGw9PXVuZGVmaW5lZCB8fCBtZS5kZWJ1Zz5sKSkge1xuICAgICAgICAgICAgdmFyIHN0cixhcmc9W107XG4gICAgICAgICAgICAvLyBzdHI9XCJhbT4gXCIrKGYubmFtZSkrXCIgXCIrKGYuY2FsbGVyPyhmLmNhbGxlci5uYW1lfHxcImFubm9ueW1vdXNcIik6XCJyb290XCIpO1xuICAgICAgICAgICAgc3RyPVwiYW0+IFwiOy8vKyhmLm5hbWUpO1xuICAgICAgICAgICAgaWYoYykge1xuICAgICAgICAgICAgICAgIHN0cj1cIiVjXCIrc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJnLnB1c2goc3RyKTtcbiAgICAgICAgICAgIGlmKGMpIHtcbiAgICAgICAgICAgICAgICBhcmcucHVzaChcImNvbG9yOlwiK2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgfVxuICAgICovXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gcXVpdFxuICAgICAqL1xuICAgIHF1aXQ6IGZ1bmN0aW9uIHF1aXQoKSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyhxdWl0LDAsXCIjYmJkXCIpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuICAgIFxuICAgICAgICBtZS5sb2coXCJcIixcIkdvb2RieWUhXCIpO1xuICAgICAgICBtZS5zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgbWUuc29ja2V0ID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBDb25maWd1cmF0aW9uXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gaW5pdEF0bGFzTWFrZXJcbiAgICAgKi9cbiAgICBpbml0QXRsYXNNYWtlcjogZnVuY3Rpb24gaW5pdEF0bGFzTWFrZXIoZWxlbSkge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2coaW5pdEF0bGFzTWFrZXIsMCxcIiNiYmRcIik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG5cbiAgICAgICAgJC5leHRlbmQoQXRsYXNNYWtlcldpZGdldCxBdGxhc01ha2VyRHJhdyk7XG4gICAgICAgICQuZXh0ZW5kKEF0bGFzTWFrZXJXaWRnZXQsQXRsYXNNYWtlckludGVyYWN0aW9uKTtcbiAgICAgICAgJC5leHRlbmQoQXRsYXNNYWtlcldpZGdldCxBdGxhc01ha2VySU8pO1xuICAgICAgICAkLmV4dGVuZChBdGxhc01ha2VyV2lkZ2V0LEF0bGFzTWFrZXJQYWludCk7XG4gICAgICAgICQuZXh0ZW5kKEF0bGFzTWFrZXJXaWRnZXQsQXRsYXNNYWtlclVJKTtcbiAgICAgICAgJC5leHRlbmQoQXRsYXNNYWtlcldpZGdldCxBdGxhc01ha2VyV1MpO1xuICAgICAgICAkLmV4dGVuZChBdGxhc01ha2VyV2lkZ2V0LEF0bGFzTWFrZXJSZXNvdXJjZXMpO1xuXG4gICAgICAgIC8vIEFkZCBjc3NcbiAgICAgICAgdmFyIGNzcztcbiAgICAgICAgZm9yKGNzcyBpbiBtZS5jc3MpIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgIG5vZGUuaW5uZXJIVE1MID0gbWUuY3NzW2Nzc107XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdXNlciBpcyBsb2dlZCBpblxuICAgICAgICAkLmdldChcIi9sb2dnZWRJblwiLGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgY29uc29sZS5sb2cocmVzKTtcbiAgICAgICAgICAgIGlmKHJlcy5sb2dnZWRJbilcbiAgICAgICAgICAgICAgICBtZS5Vc2VyLnVzZXJuYW1lPXJlcy51c2VybmFtZVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1lLlVzZXIudXNlcm5hbWU9J0Fub255bW91cyc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENyZWF0ZSBvZmZzY3JlZW4gY2FudmFzIGZvciBtcmkgYW5kIGF0bGFzXG4gICAgICAgIG1lLmJyYWluX29mZmNuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBtZS5icmFpbl9vZmZ0eD1tZS5icmFpbl9vZmZjbi5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBtZS5hdGxhc19vZmZjbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgbWUuYXRsYXNfb2ZmdHg9bWUuYXRsYXNfb2ZmY24uZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAvLyBTZXQgd2lkZ2V0IGRpdiAoY3JlYXRlIG9uZSBpZiBub25lKVxuICAgICAgICBpZihlbGVtPT11bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1lLmNvbnRhaW5lcj0kKFwiPGRpdiBjbGFzcz0nYXRsYXNNYWtlcidcIik7XG4gICAgICAgICAgICAkKGRvY3VtZW50LmJvZHkpLmFwcGVuZChtZS5jb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWUuY29udGFpbmVyPWVsZW07XG4gICAgICAgICAgICBpZihtZS5kZWJ1ZykgY29uc29sZS5sb2coXCJDb250YWluZXI6IFwiLG1lLmNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEluaXQgZHJhd2luZyBjYW52YXNcbiAgICAgICAgbWUuY29udGFpbmVyLmFwcGVuZCgnPGRpdiBpZD1cInJlc2l6YWJsZVwiPjxjYW52YXMgaWQ9XCJjYW52YXNcIj48L2NhbnZhcz48L2Rpdj4nKTtcbiAgICAgICAgbWUuY2FudmFzID0gbWUuY29udGFpbmVyLmZpbmQoJ2NhbnZhcycpWzBdO1xuICAgICAgICBtZS5jb250ZXh0ID0gbWUuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgZGl2IHRvIGRpc3BsYXkgc2xpY2UgbnVtYmVyXG4gICAgICAgIG1lLmNvbnRhaW5lci5maW5kKFwiI3Jlc2l6YWJsZVwiKS5hcHBlbmQoXCI8ZGl2IGlkPSd0ZXh0LWxheWVyJz48L2Rpdj5cIik7XG5cbiAgICAgICAgLy8gQWRkIGRpdiB0byBkaXNwbGF5IHNsaWNlIG51bWJlclxuICAgICAgICBtZS5jb250YWluZXIuZmluZChcIiNyZXNpemFibGVcIikuYXBwZW5kKFwiPHN2ZyBpZD0ndmVjdG9yLWxheWVyJz48L3N2Zz5cIik7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgY3Vyc29yIChhIHNtYWxsIGRpdilcbiAgICAgICAgbWUuY29udGFpbmVyLmZpbmQoXCIjcmVzaXphYmxlXCIpLmFwcGVuZChcIjxkaXYgaWQ9J2N1cnNvcic+PC9kaXY+XCIpO1xuICAgICAgICBcbiAgICAgICAgJCgnYm9keScpLmF0dHIoJ2RhdGEtdG9vbGJhckRpc3BsYXknLCdyaWdodCcpO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIHByZWNpc2UgY3Vyc29yXG4gICAgICAgIHZhciBpc1RvdWNoQXJyPVtdOy8vW1wiaVBhZFwiLFwiaVBvZFwiXTtcbiAgICAgICAgdmFyIGN1ckRldmljZT1uYXZpZ2F0b3IudXNlckFnZW50LnNwbGl0KC9bKDtdLylbMV07XG4gICAgICAgIGlmKCQuaW5BcnJheShjdXJEZXZpY2UsaXNUb3VjaEFycik+PTApIHtcbiAgICAgICAgICAgIG1lLmZsYWdVc2VQcmVjaXNlQ3Vyc29yPXRydWU7XG4gICAgICAgICAgICBtZS5pbml0Q3Vyc29yKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb25maWd1cmUgbW91c2UgZXZlbnRzIGZvciBkZXNrdG9wIGNvbXB1dGVyc1xuICAgICAgICBtZS5jYW52YXMub25tb3VzZWRvd24gPSBtZS5tb3VzZWRvd247XG4gICAgICAgIG1lLmNhbnZhcy5vbm1vdXNlbW92ZSA9IG1lLm1vdXNlbW92ZTtcbiAgICAgICAgbWUuY2FudmFzLm9ubW91c2V1cCA9IG1lLm1vdXNldXA7XG5cbiAgICAgICAgLy8gQ29ubmVjdCBldmVudCB0byByZXNwb25kIHRvIHdpbmRvdyByZXNpemluZ1xuICAgICAgICAkKHdpbmRvdykucmVzaXplKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbWUucmVzaXplV2luZG93KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGdldCBwb2ludGVyIHRvIHByb2dyZXNzIGRpdlxuICAgICAgICBtZS5wcm9ncmVzcz0kKFwiYS5kb3dubG9hZF9NUklcIik7XG5cbiAgICAgICAgLy8gSW5pdCB0aGUgdG9vbGJhclxuICAgICAgICAvLyBjb25maWd1cmUgYW5kIGFwcGVuZCB0b29sc1xuICAgICAgICBsZXQgc3ZnLCB0b29scztcblxuICAgICAgICBpZih0eXBlb2YgbWUudXNlRnVsbFRvb2xzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbWUudXNlRnVsbFRvb2xzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZihtZS51c2VGdWxsVG9vbHMpIHtcbiAgICAgICAgICAgIHRvb2xzID0gbWUuaHRtbC50b29sc0Z1bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b29scyA9IG1lLmh0bWwudG9vbHNMaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihzdmcgaW4gbWUuc3ZnKSB7XG4gICAgICAgICAgICB0b29scyA9IHRvb2xzLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgbmV3IFJlZ0V4cCgnL2ltZy8nICsgc3ZnICsgJy5zdmcnLCAnZycpLFxuICAgICAgICAgICAgICAgICdkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCwnICsgbWUuc3ZnW3N2Z11cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzdmcpO1xuICAgICAgICB9XG4gICAgICAgIG1lLmNvbnRhaW5lci5hcHBlbmQodG9vbHMpO1xuICAgICAgICAvLyBpbnRlcmNlcHQga2V5Ym9hcmQgZXZlbnRzXG4gICAgICAgICQoZG9jdW1lbnQpLmtleWRvd24oZnVuY3Rpb24oZSl7bWUua2V5RG93bihlKX0pO1xuICAgICAgICAvLyBjb25maWd1cmUgYW5ub3RhdGlvbiB0b29sc1xuICAgICAgICAkKFwiI3Rvb2xzLW1pbmltaXplZFwiKS5jbGljayhmdW5jdGlvbigpe21lLmNoYW5nZVRvb2xiYXJEaXNwbGF5KFwibWF4aW1pemVcIil9KTtcbiAgICAgICAgbWUucHVzaCgkKFwiLnB1c2gjZGlzcGxheS1taW5pbWl6ZVwiKSxmdW5jdGlvbigpe21lLmNoYW5nZVRvb2xiYXJEaXNwbGF5KFwibWluaW1pemVcIil9KTtcbiAgICAgICAgbWUucHVzaCgkKFwiLnB1c2gjZGlzcGxheS1sZWZ0XCIpLGZ1bmN0aW9uKCl7bWUuY2hhbmdlVG9vbGJhckRpc3BsYXkoXCJsZWZ0XCIpfSk7XG4gICAgICAgIG1lLnB1c2goJChcIi5wdXNoI2Rpc3BsYXktcmlnaHRcIiksZnVuY3Rpb24oKXttZS5jaGFuZ2VUb29sYmFyRGlzcGxheShcInJpZ2h0XCIpfSk7XG4gICAgICAgIG1lLnNsaWRlcigkKFwiLnNsaWRlciNzbGljZVwiKSxmdW5jdGlvbih4KXttZS5jaGFuZ2VTbGljZShNYXRoLnJvdW5kKHgpKX0pO1xuICAgICAgICBtZS5jaG9zZSgkKFwiLmNob3NlI3BsYW5lXCIpLG1lLmNoYW5nZVZpZXcpO1xuICAgICAgICBtZS5jaG9zZSgkKFwiLmNob3NlI3BhaW50VG9vbFwiKSxtZS5jaGFuZ2VUb29sKTtcbiAgICAgICAgbWUuY2hvc2UoJChcIi5jaG9zZSNwZW5TaXplXCIpLG1lLmNoYW5nZVBlblNpemUpO1xuICAgICAgICBtZS50b2dnbGUoJChcIi50b2dnbGUjcHJlY2lzZVwiKSxtZS50b2dnbGVQcmVjaXNlQ3Vyc29yKTtcbiAgICAgICAgbWUudG9nZ2xlKCQoXCIudG9nZ2xlI2ZpbGxcIiksbWUudG9nZ2xlRmlsbCk7XG4gICAgICAgIG1lLnRvZ2dsZSgkKFwiLnRvZ2dsZSNmdWxsc2NyZWVuXCIpLG1lLnRvZ2dsZUZ1bGxzY3JlZW4pO1xuICAgICAgICBtZS50b2dnbGUoJChcIi50b2dnbGUjYnViYmxlXCIpLG1lLnRvZ2dsZUNoYXQpO1xuICAgICAgICBtZS5wdXNoKCQoXCIucHVzaCMzZHJlbmRlclwiKSxtZS5yZW5kZXIzRCk7XG4gICAgICAgIG1lLnB1c2goJChcIi5wdXNoI2xpbmtcIiksbWUubGluayk7XG4gICAgICAgIG1lLnB1c2goJChcIi5wdXNoI3VwbG9hZFwiKSxtZS51cGxvYWQpO1xuICAgICAgICBtZS5wdXNoKCQoXCIucHVzaCNkb3dubG9hZFwiKSxtZS5kb3dubG9hZCk7XG4gICAgICAgIG1lLnB1c2goJChcIi5wdXNoI2NvbG9yXCIpLG1lLmNvbG9yKTtcbiAgICAgICAgbWUucHVzaCgkKFwiLnB1c2gjdW5kb1wiKSxtZS5zZW5kVW5kb01lc3NhZ2UpO1xuICAgICAgICBtZS5wdXNoKCQoXCIucHVzaCNzYXZlXCIpLG1lLnNlbmRTYXZlTWVzc2FnZSk7XG4gICAgICAgIG1lLnB1c2goJChcIi5wdXNoI3ByZXZcIiksbWUucHJldlNsaWNlKTtcbiAgICAgICAgbWUucHVzaCgkKFwiLnB1c2gjbmV4dFwiKSxtZS5uZXh0U2xpY2UpO1xuXG4gICAgICAgIC8vIGNvbm5lY3QgY2hhdCBtZXNzYWdlIGlucHV0XG4gICAgICAgICQoXCIjbXNnXCIpLmtleXByZXNzKGZ1bmN0aW9uIGtleXByZXNzX2Zyb21Jbml0QXRsYXNNYWtlcihlKSB7bWUub25rZXkoZSl9KTtcblxuICAgICAgICAkKFwiI3Rvb2xzLW1pbmltaXplZFwiKS5oaWRlKCk7XG5cbiAgICAgICAgbGV0IHByID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBtZS5pbml0U29ja2V0Q29ubmVjdGlvbigpXG4gICAgICAgICAgICAudGhlbiggKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRVJST1I6XCIsZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcHI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gY29uZmlndXJlQXRsYXNNYWtlclxuICAgICAqL1xuICAgIGNvbmZpZ3VyZUF0bGFzTWFrZXI6IGZ1bmN0aW9uIGNvbmZpZ3VyZUF0bGFzTWFrZXIoaW5mbywgaW5kZXgpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKGNvbmZpZ3VyZUF0bGFzTWFrZXIsMCxcIiNiYmRcIik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG5cbiAgICAgICAgdmFyIHByID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBtZS5jb25maWd1cmVNUkkoaW5mbyxpbmRleClcbiAgICAgICAgICAgIC50aGVuKGluZm8yID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgcHIyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZTIsIHJlamVjdDIpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5mbyA9IGluZm8yO1xuICAgICAgICAgICAgICAgICAgICAkLmdldEpTT04obWUuaG9zdG5hbWUgKyBcIi9sYWJlbHMvXCIraW5mby5tcmkuYXRsYXNbaW5kZXhdLmxhYmVscylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZTIoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnIyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1I6XCIsZXJyMik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QyKGVycjIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gcHIyO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIGZyb21fY29uZmlndXJlQXRsYXNNYWtlcihkYXRhKSB7XG4gICAgICAgICAgICAgICAgbWUuY29uZmlndXJlT250b2xvZ3koZGF0YSk7XG4gICAgICAgICAgICAgICAgbWUuVXNlci5wZW5WYWx1ZT1tZS5vbnRvbG9neS5sYWJlbHNbMF0udmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZihtZS5mdWxsc2NyZWVuPT10cnVlKSB7IC8vIFdBUk5JTkc6IEhBQ0suLi4gd291bGQgYmUgYmV0dGVyIHRvIGltcGxlbWVudCBlbnRlci9leGl0IGZ1bGxzY3JlZW5cbiAgICAgICAgICAgICAgICAgICAgbWUuZnVsbHNjcmVlbj1mYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbWUudG9nZ2xlRnVsbHNjcmVlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYobWUuVXNlci52aWV3IT1udWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICQoXCIuY2hvc2UjcGxhbmUgLmFcIikucmVtb3ZlQ2xhc3MoXCJwcmVzc2VkXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmlldz1tZS5Vc2VyLnZpZXcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbWUuVXNlci52aWV3LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICAkKFwiLmNob3NlI3BsYW5lIC5hOmNvbnRhaW5zKCdcIit2aWV3K1wiJylcIikuYWRkQ2xhc3MoXCJwcmVzc2VkXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lLnNlbmRVc2VyRGF0YU1lc3NhZ2UoXCJhbGxVc2VyRGF0YVwiKTtcbiAgICAgICAgICAgICAgICBtZS5zZW5kVXNlckRhdGFNZXNzYWdlKFwic2VuZEF0bGFzXCIpO1xuXG4gICAgICAgICAgICAgICAgbWUuY2hhbmdlUGVuQ29sb3IoIDAgKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGluZm8pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCggKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1I6XCIsZXJyKTtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcHI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gY29uZmlndXJlT250b2xvZ3lcbiAgICAgKi9cbiAgICBjb25maWd1cmVPbnRvbG9neTogZnVuY3Rpb24gY29uZmlndXJlT250b2xvZ3koanNvbikge1xuICAgICAgICB2YXIgbWU9QXRsYXNNYWtlcldpZGdldDtcbiAgICAgICAgdmFyIGw9bWUudHJhY2VMb2coY29uZmlndXJlT250b2xvZ3ksMCxcIiNiYmRcIik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG5cbiAgICAgICAgbWUub250b2xvZ3k9anNvblxuICAgICAgICBtZS5vbnRvbG9neS52YWx1ZVRvSW5kZXg9W107XG4gICAgICAgIG1lLm9udG9sb2d5LmxhYmVscy5mb3JFYWNoKGZ1bmN0aW9uKG8saSl7bWUub250b2xvZ3kudmFsdWVUb0luZGV4W28udmFsdWVdPWl9KTtcbiAgICAgICAgLy8gdG8gY2xlYXIgdGhlIHJlZ2lvbiBuYW1lIGJlaW5nIGRpc3BsYXllZCBvbiB0aGUgaW5mbyB0ZXh0LWxheWVyIHdoZW4gaGF2aW5nIHVzZWQgZXllZHJvcFxuICAgICAgICBkZWxldGUgbWUuaW5mby5yZWdpb247XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gcmVxdWVzdE1SSUluZm9cbiAgICAgKiBAZGVzYyBSZXF1ZXN0IHRvIGRvd25sb2FkIGFuIE1SSSwgd2l0aCBwb2xsaW5nIHRvIHByZXZlbnQgaGFuZ291dHMgb24gbGVuZ3RoeVxuICAgICAqICAgICAgIGRvd25sb2Fkc1xuICAgICAqL1xuICAgIHJlcXVlc3RNUklJbmZvOiBmdW5jdGlvbiByZXF1ZXN0TVJJSW5mbyhzb3VyY2UpIHtcbiAgICAgICAgdmFyIG1lPUF0bGFzTWFrZXJXaWRnZXQ7XG4gICAgICAgIHZhciBsPW1lLnRyYWNlTG9nKHJlcXVlc3RNUklJbmZvLDAsXCIjYmJkXCIpO2lmKGwpY29uc29sZS5sb2cuYXBwbHkodW5kZWZpbmVkLGwpO1xuXG4gICAgICAgICQoXCIjbG9hZGluZ0luZGljYXRvciBwXCIpLnRleHQoXCJMb2FkaW5nLi4uIFwiKTtcbiAgICAgICAgdmFyIHByID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgdGltZXIgPSBzZXRJbnRlcnZhbCggZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicG9sbGluZyBmb3IgZGF0YS4uLlwiKTtcbiAgICAgICAgICAgICAgICAkLnBvc3QobWUuaG9zdG5hbWUgKyBcIi9tcmkvanNvblwiLHt1cmw6c291cmNlfSwgZnVuY3Rpb24oaW5mbykge1xuICAgICAgICAgICAgICAgICAgICBpZihpbmZvLnN1Y2Nlc3MgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3JlcXVlc3RNUklJbmZvIHByb21pc2UgcmVzb2x2ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihpbmZvLnN1Y2Nlc3MgPT0gJ2Rvd25sb2FkaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYobWUuVXNlci5zb3VyY2UgIT0gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KFwiRVJST1I6IHNvdXJjZSBjaGFuZ2VkLiBQcm9iYWJseSBubyBsb25nZXIgcmVxdWVzdGVkP1wiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjbG9hZGluZ0luZGljYXRvciBwXCIpLnRleHQoXCJMb2FkaW5nLi4uIFwiK3BhcnNlSW50KGluZm8uY3VyL2luZm8ubGVuKjEwMCwxMCkrXCIlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFUlJPUjogcmVxdWVzdE1SSUluZm9cIixpbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KFwiRVJST1I6IHJlcXVlc3RNUklJbmZvXCIgKyBpbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgMjAwMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwcjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBjb25maWd1cmVNUklcbiAgICAgKi9cbiAgICBjb25maWd1cmVNUkk6IGZ1bmN0aW9uIGNvbmZpZ3VyZU1SSShpbmZvLGluZGV4KSB7XG4gICAgICAgIHZhciBtZT1BdGxhc01ha2VyV2lkZ2V0O1xuICAgICAgICB2YXIgbD1tZS50cmFjZUxvZyhjb25maWd1cmVNUkksMCxcIiNiYmRcIik7aWYobCljb25zb2xlLmxvZy5hcHBseSh1bmRlZmluZWQsbCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgbWUuVXNlci5zb3VyY2UgPSBpbmZvLnNvdXJjZTtcbiAgICAgICAgICAgIG1lLnJlcXVlc3RNUklJbmZvKGluZm8uc291cmNlKVxuICAgICAgICAgICAgLnRoZW4oKGluZm8yKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYoIWluZm8uZGltKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBtcmkgb2JqZWN0IHVzZWQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IGhhdmUgYSAnZGltJ1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0eSwgaW5kaWNhdGluZyB0aGF0IGl0IGhhZCBub3QgYmVlbiBkb3dubG9hZGVkIGF0IHRoZSB0aW1lIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsLiBIZXJlIHdlIG1lcmdlIHRoZSBmaWVsZHMgZnJvbSBpbmZvMiB0aGF0IGFyZSBpbml0aWFsaXNlZCB1cG9uXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvd25sb2FkIG9mIHRoZSBtcmkgc2VydmVyLXNpZGUuIFRoZSBtcmkgZmllbGQgaW4gdGhlIG9yaWdpbmFsICdpbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggY29udGFpbnMgdGhlIG5ld2x5IGNyZWF0ZWQgdGV4dCAnYW5ub3RhdGlvbnMnLCBpcyBjb25zZXJ2ZWRcbiAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgaW5mbywgaW5mbzIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmZvMiA9IGluZm87XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgZGF0YSBmcm9tIEF0bGFzTWFrZXIgb2JqZWN0XG4gICAgICAgICAgICAgICAgbWUubmFtZT1pbmZvMi5uYW1lfHxcIlVudGl0bGVkXCI7XG4gICAgICAgICAgICAgICAgbWUudXJsPWluZm8yLnVybDtcbiAgICAgICAgICAgICAgICBtZS5hdGxhc0ZpbGVuYW1lPWluZm8yLm1yaS5hdGxhc1tpbmRleF0uZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgbWUuYXRsYXNOYW1lPWluZm8yLm1yaS5hdGxhc1tpbmRleF0ubmFtZTtcblxuICAgICAgICAgICAgICAgIC8vIGdldCBsb2NhbCBmaWxlIHBhdGggZnJvbSB1cmxcbiAgICAgICAgICAgICAgICBtZS5Vc2VyLmRpcm5hbWU9bWUudXJsOyAvLyBURU1QT1JBUllcbiAgICAgICAgICAgICAgICBtZS5Vc2VyLm1yaT1pbmZvMi5tcmkuYnJhaW47XG4gICAgICAgICAgICAgICAgbWUuVXNlci5zcGVjaW1lbk5hbWU9bWUubmFtZTtcbiAgICAgICAgICAgICAgICBtZS5Vc2VyLmF0bGFzRmlsZW5hbWU9aW5mbzIubXJpLmF0bGFzW2luZGV4XS5maWxlbmFtZTtcbiAgICAgICAgICAgICAgICBtZS5Vc2VyLmlzTVJJTG9hZGVkPWZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaXQncyBzaWxseSB0byBoYXZlIHRvIHB1dCB2b2wgZGltIHR3aWNlLi4uXG4gICAgICAgICAgICAgICAgLy8gKGZpcnN0IGhlcmUsIG9uY2UgYWdhaW4gZnVydGhlciBkb3duKVxuICAgICAgICAgICAgICAgIG1lLlVzZXIuZGltPWluZm8yLmRpbTtcbiAgICAgICAgICAgICAgICBtZS5Vc2VyLnBpeGRpbT1pbmZvMi5waXhkaW07XG5cbiAgICAgICAgICAgICAgICAvLyBjb21wdXRlIHNwYWNlIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICAgICAgICAgIG1lLlVzZXIudjJ3PWluZm8yLnZveGVsMndvcmxkO1xuICAgICAgICAgICAgICAgIG1lLlVzZXIud29yaT1pbmZvMi53b3JsZE9yaWdpbjtcbiAgICAgICAgICAgICAgICBtZS5jb21wdXRlUzJWVHJhbnNmb3JtYXRpb24oKTtcblxuICAgICAgICAgICAgICAgIC8vbWUudGVzdFMyVlRyYW5zZm9ybWF0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICBtZS5mbGFnTG9hZGluZ0ltZz17bG9hZGluZzpmYWxzZX07XG5cbiAgICAgICAgICAgICAgICBtZS5icmFpbl9pbWcuaW1nPW51bGw7XG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgdm9sdW1lIGRpbWVuc2lvbnNcbiAgICAgICAgICAgICAgICBtZS5icmFpbl9kaW09aW5mbzIuZGltO1xuICAgICAgICAgICAgICAgIGlmKGluZm8yLnBpeGRpbSlcbiAgICAgICAgICAgICAgICAgICAgbWUuYnJhaW5fcGl4ZGltPWluZm8yLnBpeGRpbTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG1lLmJyYWluX3BpeGRpbT1bMSwgMSwgMV07XG5cbiAgICAgICAgICAgICAgICByZXNvbHZlKGluZm8yKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFUlJPUjogRE9XTkxPQUQgRkFJTEVEXCIsIGVycik7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n')}]).AtlasMakerWidget;